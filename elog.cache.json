{
  "docs": [
    {
      "id": "003fd62e-3f11-47f8-8479-9eb728ac6df8",
      "doc_id": "003fd62e-3f11-47f8-8479-9eb728ac6df8",
      "title": "003fd62e-3f11-47f8-8479-9eb728ac6df8",
      "updated": 1695779340000,
      "body_original": "\n# 推荐\n\n\n我目前已经不参与[yuque-hexo](https://github.com/x-cold/yuque-hexo)库维护了。推荐使用我自己开发的Elog——开放式跨平台博客解决方案。无论是从头搭建自己的博客还是备份线上博客，Elog都是一个不错的选择。而且支持不开语雀会员也能导出md文档，同时也支持Notion、FlowUs写作平台。\n\n\nGithub地址：[https://github.com/LetTTGACO/elog](https://github.com/LetTTGACO/elog)\nElog使用文档：[https://elog.1874.cool](https://elog.1874.cool/)\n\n\n# 引言\n\n\n在使用[yuque-hexo](https://github.com/x-cold/yuque-hexo)同步文章到博客后，由于语雀的图片由有防盗链的限制，会导致部署后，博客网站显示图片异常。 处理办法有两种：\n\n1. 在语雀上使用图片的时候，避开直接复制图片到语雀。先将图片上传到自己的图床后，直接使用`markdown`的图片语法：`![](https://xxxx.com/a.jpg)`插入图片到适当位置，例如：\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FioacWCiuPFjNteg-vR3cLc1WLxS.png)\n\n1. 为了不破坏语雀编辑器的体验，我修改了`yuque-hexo`的源代码，发布了`yuqe-hexo-with-cdn`插件。适配了将语雀中的图片上传到腾讯云 COS 图床后，将原有的语雀图片链接替换掉。\n\n# yuqe-hexo-with-cdn 插件\n\n\n使用文档说明：[yuqe-hexo-with-cdn](https://github.com/LetTTGACO/yuque-hexo-with-cdn)\n\n\n> 目前x-code已经将我的方案合并到主分支了，可以直接使用[yuque-hexo](https://github.com/x-cold/yuque-hexo)进行配置\n\n\n## 改造思路\n\n\n### 原 yuque-hexo 生成.md 文章简易流程\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fmw6JzWt77eNl8bZEjm9DfXkUzvi.png)\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FvbBK8CcTjuw-otaGM04maJnn5bL.jpeg)\n\n\n### yuqe-hexo-with-cdn 改造思路\n\n\n整体思路主要是在生成`yuque.json`之前进行语雀图片的替换\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FkKB938kloJ_Q8sFG9mMSGIU1x5s.png)\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FrYOy2OlY8r1quTwMxbUF3ditE-E.jpeg)\n\n\n具体实现流程\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FucxIXLK1tooOCX012sNpAtppMRc.png)\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fuji-vgBnpY7Yg3Tev-jZ-DbnDDP.jpeg)\n\n\n## 具体实现\n\n\n```javascript\n// mock数据格式作为参考\nconst article = {\n  title: '博客标题',\n  body: '图片1：![image.png](https://dfas.qqc/test1.png#a=1) 图片2:![image.png](https://dfas.qqc/test2.png#a=1)'\n}\n\n// 获取语雀的图片链接的正则表达式，返回匹配到的多条记录\nconst imageUrlRegExp = /!\\[(.*?)]\\((.*?)\\)/mg;\n\nasync function img2Cos(article) {\n  // 1. 从文章中获取语雀的图片URL列表\n  const matchYuqueImgUrlList = article.body.match(imageUrlRegExp);\n  // matchYuqueImgUrlList: [\"![image.png](https://dfas.qqc/test1.png#a=1)\", \"![image.png](https://dfas.qqc/test2.png#a=1)\"]\n\n  // 如果没有匹配到，说明该文章不存在图片\n  if (!matchYuqueImgUrlList) return article;\n  \n  // 循环列表进行处理\n  const promiseList = matchYuqueImgUrlList.map(async matchYuqueImgUrl => {\n    \n    // 获取真正的图片url\n    const yuqueImgUrl = getImgUrl(matchYuqueImgUrl);\n    // yuqueImgUrl: https://dfas.qqc/test1.png#a=1\n    \n    // 2.将图片转成buffer文件\n    const imgBuffer = await img2Buffer(yuqueImgUrl);\n    \n    // 如果解析错误，说明图片有问题，直接跳过后续步骤\n    if (!imgBuffer) {\n      return {\n        originalUrl: matchYuqueImgUrl,\n        yuqueRealImgUrl: yuqueImgUrl,\n        url: yuqueImgUrl,\n      };\n    }\n    // 3. 根据buffer文件生成唯一的hash文件名\n    const fileName = await getFileName(imgBuffer, yuqueImgUrl);\n    // fileName: abcdefg-tudnamdana.png\n    \n    try {\n      // 4. 检查图床中是否存在该文件\n      let url = await hasObject(fileName);\n      // 存在：url: 腾讯云图床链接\n      // 不存在 url: ''\n      \n      // 5. 如果图床已经存在，直接替换\n      // \t\t如果图床不存在，则先上传到图床，再将原本的语雀url进行替换\n      if (!url) {\n        url = await uploadImg(imgBuffer, fileName);\n        // url: 腾讯云图床链接\n      }\n      return {\n        // 原始的语雀图片：originalUrl: ![image.png](https://dfas.qqc/test1.png#a=1)\n        originalUrl: matchYuqueImgUrl,\n        // 真正的语雀图片：yuqueRealImgUrl: https://dfas.qqc/test1.png\n        yuqueRealImgUrl: yuqueImgUrl,\n        // 图床中的图片：url: 腾讯云图床链接\n        url,\n      };\n    } catch (e) {\n      out.error(`访问COS出错，请检查配置: ${e}`);\n      process.exit(-1);\n    }\n  })\n  \n  // 得到图片对象数组\n  const urlList = await Promise.all(promiseList);\n  // [\n  //   {\n  //     originalUrl: \"![image.png](https://dfas.qqc/test1.png#a=1)\",\n  //     yuqueRealImgUrl: \"https://dfas.qqc/test1.png\",\n  //     url: \"腾讯云图床链接1\"\n  //   },\n  //   {\n  //     originalUrl: \"![image.png](https://dfas.qqc/test2.png#a=1)\",\n  //     yuqueRealImgUrl: \"https://dfas.qqc/test2.png\",\n  //     url: \"腾讯云图床链接2\"\n  //   }\n  // ]\n  \n  // 6. 将语雀图片链接进行替换\n  urlList.forEach(function(url) {\n    if (url) {\n      article.body = article.body.replace(url.originalUrl, `![](${url.url})`);\n      out.info(`replace ${url.yuqueRealImgUrl} to ${url.url}`);\n    }\n  });\n  \n  // 7. 返回新的文章对象\n  return article;\n  // article: {\n  //   title: '博客标题',\n  //   body: '图片1：![](腾讯云图床链接1) 图片2:![](腾讯云图床链接2)'\n  // }\n}\n\n\n// 工具类\n\n// 从markdown格式的url中获取url\nfunction getImgUrl(markdownImgUrl) {\n  const _temp = markdownImgUrl.replace(/\\!\\[(.*?)]\\(/, '');\n  const _temp_index = _temp.indexOf(')');\n  // 得到真正的语雀的url\n  return _temp.substring(0, _temp_index)\n    .split('#')[0];\n}\n\n// 将图片转成buffer\n// 这里用到了superagent库进行转换\nasync function img2Buffer(yuqueImgUrl) {\n  return await new Promise(async function(resolve) {\n    try {\n      await superagent\n        .get(yuqueImgUrl)\n        .buffer(true)\n        .parse(res => {\n          const buffer = [];\n          res.on('data', chunk => {\n            buffer.push(chunk);\n          });\n          res.on('end', () => {\n            const data = Buffer.concat(buffer);\n            resolve(data);\n          });\n        });\n    } catch (e) {\n      // 非法图片返回null\n      out.warn(`invalid img: ${yuqueImgUrl}`);\n      resolve(null);\n    }\n  });\n}\n\n// 根据文件内容获取唯一文件名称\n// 这里用到了开源的七牛云的算法，详情：https://juejin.cn/post/6844903775660933133\nasync function getFileName(imgBuffer, yuqueImgUrl) {\n  return new Promise(resolve => {\n    getEtag(imgBuffer, hash => {\n      const imgName = hash;\n      // 获取文件名后缀\n      const imgSuffix = yuqueImgUrl.substring(yuqueImgUrl.lastIndexOf('.'));\n      // 拼接文件名\n      const fileName = `${imgName}${imgSuffix}`;\n      // 返回文件名\n      resolve(fileName);\n    });\n  });\n}\n\n// 检查COS是否已经存在图片，存在则返回url\nasync function hasObject(fileName) {\n  // prefixKey: blog-image\n  \n  if (!bucket.length || !region.length) {\n    out.error('请检查COS配置');\n    process.exit(-1);\n  }\n  return new Promise(resolve => {\n    cos.headObject({\n      Bucket: bucket, // 存储桶名字（必须）\n      Region: region, // 存储桶所在地域，必须字段\n      Key: `${prefixKey}/${fileName}`, //  文件名  必须\n    }, function(err, data) {\n      if (data) {\n        // 拼接腾讯云图床的图片URL\n        const url = `https://${bucket}.cos.${region}.myqcloud.com/${prefixKey}/${fileName}`;\n        resolve(url);\n      } else {\n        // 不存在返回空\n        resolve('');\n      }\n    });\n  });\n}\n\n\n// 上传图片到COS\nasync function uploadImg(imgBuffer, fileName) {\n  return new Promise((resolve, reject) => {\n    cos.putObject({\n      Bucket: bucket, // 存储桶名字（必须）\n      Region: region, // 存储桶所在地域，必须字段\n      Key: `${prefixKey}/${fileName}`, //  文件名  必须\n      StorageClass: 'STANDARD', // 上传模式（标准模式）\n      Body: imgBuffer, // 上传文件对象\n    }, function(err, data) {\n      if (data) {\n        // 返回图片链接\n        resolve(`https://${data.Location}`);\n      }\n      if (err) {\n        reject(err);\n      }\n    });\n  });\n}\n```\n\n\n# 常见问题\n\n\n## 语雀的流程图/文本绘图等不适配\n\n\n语雀的流程图/文本绘图等无法生成 markdown 展示，所以我的做法是，在语雀编辑器书写的时候，先编写流程图，写好了再截图，作为图片放在流程图的前面。这样生成的 md 文件就只有图片被解析出来了。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FkL8pPinDyxnak397bwQVlM57eeL.png)\n\n\n## 特殊情况下需要使用 markdown 语法的图片链接示例\n\n\n因为该插件会将匹配到的所有 markdown 语法的图片都上传到图床（包括代码块中的示例），所以在书写语雀文章时，非特殊情况不要使用该语法。或者在书写的时候，将链接非法化即可，例如：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FkPytQbCfcYdtboEpkB4tiGh3iDz.png)\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FnGGls9yxHv_YyeqhxKl6Z_BLOI8.png)\n\n\n插件在处理的过程中会检测出来非法链接，就不会上传该图片了\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FolAZNE4CANdcXxPIH2mjlBbzrjG.png)\n\n\n# 关于\n\n\n如果你不想用腾讯云 COS 图床，你也可以按照这个思路，将 COS 相关的配置进行改造，上传到你自己的图床！\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-01-20",
        "type": "Post",
        "slug": "osar7h",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了yuque-hexo插件语雀图片防盗链的解决方案，包括具体的实现流程和常见问题的解决方案。同时，提供了对于其他云服务的实现思路。",
        "更新时间": "2023-09-27T01:49:00.000Z",
        "title": "yuque-hexo插件语雀图片防盗链的解决方案",
        "category": "技术分享",
        "tags": [
          "Hexo"
        ],
        "status": "Invisible",
        "urlname": "003fd62e-3f11-47f8-8479-9eb728ac6df8",
        "updated": "2023-09-27 01:49:00"
      },
      "body": "",
      "realName": "yuque-hexo插件语雀图片防盗链的解决方案",
      "relativePath": "/yuque-hexo插件语雀图片防盗链的解决方案.md",
      "needUpdate": 1
    },
    {
      "id": "dda51961-f514-4a53-8d18-3a0c1ece2132",
      "doc_id": "dda51961-f514-4a53-8d18-3a0c1ece2132",
      "title": "dda51961-f514-4a53-8d18-3a0c1ece2132",
      "updated": 1695785700000,
      "body_original": "\n> 💡 1. 今日学习的文章链接和视频链接  \n> 2. 自己看到题目的第一想法  \n> 3. 看完代码随想录之后的想法  \n> 4. 自己实现过程中遇到哪些困难  \n> 5. 今日收获，记录一下自己的学习时长\n\n\n# 题目链接\n\n\n## **数组理论基础**\n\n\n文章链接：[https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)\n\n\n**题目建议**： 了解一下数组基础，以及数组的内存空间地址，数组也没那么简单。\n\n\n## **704. 二分查找**\n\n\n**题目建议**： 大家能把 704 掌握就可以，35.搜索插入位置 和 34. 在排序数组中查找元素的第一个和最后一个位置 ，如果有时间就去看一下，没时间可以先不看，二刷的时候在看。\n\n\n先把 704写熟练，要**熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法**。\n\n\n题目链接：[https://leetcode.cn/problems/binary-search/](https://leetcode.cn/problems/binary-search/)\n\n\n文章讲解：[https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html)\n\n\n视频讲解：[https://www.bilibili.com/video/BV1fA4y1o715](https://www.bilibili.com/video/BV1fA4y1o715)\n\n\n## **27. 移除元素**\n\n\n**题目建议**：  暴力的解法，可以锻炼一下我们的代码实现能力，建议先把暴力写法写一遍。 **双指针法 是本题的精髓，今日需要掌握**，至于拓展题目可以先不看。\n\n\n题目链接：[https://leetcode.cn/problems/remove-element/](https://leetcode.cn/problems/remove-element/)\n\n\n文章讲解：[https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html](https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html)\n\n\n视频讲解：[https://www.bilibili.com/video/BV12A4y1Z7LP](https://www.bilibili.com/video/BV12A4y1Z7LP)\n\n\n# 解题思路\n\n\n## 704.二分查找\n\n\n### 关键词\n\n1. **有序数组**\n2. **无重复元素**，因为一旦有了重复元素，二分查找法返回的元素下标不一定是唯一的\n\n### 思路\n\n- 找到数组中间的下标\n- 如果中间下标对应的值大于目标值，则说明目标值在左半边数组\n- 如果中间下标对应的值小于目标值，则说明目标值在右半边数组\n- 循环往复，直到中间下标对应的值等于目标值，返回下标值，否则返回-1\n- 可以构建两个指针，通过移动指针的位置来缩小区间范围\n- 需要注意区间的边界值，也就是左闭右闭、左闭右开两种情况的取值和判断\n- 左闭右闭测试用例为单个元素数组，即左===右，所以while循环需要≤\n- 左闭右开其实对while循环边界无要求，因为左不可能等于右，是无效空间\n\n## 27.移除元素\n\n\n### 关键词\n\n1. 原地删除/修改\n\n### 思路\n\n- 没思路，不知道什么是原地修改，看了解析才知道什么是原地修改，暴力解法比较通俗易懂，就是后面的数组覆盖前面的数组。每一次覆盖后，最外层的下标需要减1，因为被后面新的数组覆盖了。数组的size也需要减1，因为元素被删除了\n- 双指针法。\n\n\t> 双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。\n\n\t1. 定义一个快指针，用于寻找目标元素\n\t2. 定义一个慢指针，当寻找到目标元素时，就跳过前进。\n\t3. 最后返回慢指针的下标\n\n# 题解\n\n\n## 704.二分查找\n\n\n```javascript\n/**\n * 左闭右开\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    // right是数组最后一个数的下标+1，nums[right]不在查找范围内，是左闭右开区间\n    let left = 0, right = nums.length;    \n    // 当left=right时，由于nums[right]不在查找范围，所以没必要包括此情况。\n    // 但是这种情况稳妥，可以不考虑边界\n    while (left < right) {\n      // 位运算 + 防止大数溢出\n      const mid = left + ((right - left) >> 1);\n      // const mid = left + ((right - left) / 2);\n      // 如果中间值大于目标值，中间值不应在下次查找的范围内，但中间值的前一个值应在；\n      // 由于right本来就不在查找范围内，所以将右边界更新为中间值，如果更新右边界为mid-1则将中间值的前一个值也踢出了下次寻找范围\n      if (nums[mid] > target) {\n        right = mid;  // 去左区间寻找\n      } else if (nums[mid] < target) {\n        left = mid + 1;  // 去右区间寻找\n      } else {\n        return mid;\n      }\n    }\n    return -1;\n};\n```\n\n\n```javascript\n/**\n * 左闭右闭\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    // right是数组最后一个数的下标，num[right]在查找范围内，是左闭右闭区间\n    let left = 0, right = nums.length - 1\n    // 当left=right时，由于nums[right]在查找范围内，所以要包括此情况\n    while(left <= right) {\n      // 位运算 + 防止大数溢出 取中间值\n      const mid = left + ((right - left) >> 1);\n      if(nums[mid] === target) {\n        return mid\n      // 如果中间数大于目标值，要把中间数排除查找范围，所以右边界更新为mid-1；\n      // 如果右边界更新为mid，那中间数还在下次查找范围内\n      } else if(nums[mid] < target) {\n        // 去右面闭区间寻找\n        left = mid + 1\n      } else {\n        // 去左面闭区间寻找\n        right = mid - 1\n      }\n    }\n    return -1\n};\n```\n\n\n## 27.移除元素\n\n\n```javascript\n/**\n * 暴力解法\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n  let size = nums.length\n  for (let i = 0; i < size; i++) {\n    if (nums[i] === val) {\n      // 将后面的元素整体前移\n      for (let j = i; j < size; j++) {\n        // 赋值操作，将后面的元素赋给前一个元素\n        nums[j] = nums[j + 1]\n      }\n      // 每一次成功前移，都会造成外层下标需要前移，才能保证下一个元素能被正确检测\n      i = i - 1\n      // 每一次成功前移，都会造成数组的长度减1\n      size = size - 1\n    }\n  }\n  return size\n};\n```\n\n\n```javascript\n/**\n * 双指针法（快慢指针）\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nvar removeElement = function(nums, val) {\n  // 慢指针\n  let slowIndex = 0\n  // 快指针\n  for (let falseIndex = 0; falseIndex < nums.length; falseIndex++) {\n    // 如果慢指针所对应的值不为目标值\n    if (nums[slowIndex] !== val) {\n      // 并且把快指针的值赋值给慢指针\n      // 如果相等过，则当下一次不相等时，慢指针指向的元素就会被覆盖为不相等的元素，\n      // 也就相当于和目标值相等的元素被原地删除了\n      nums[slowIndex] = nums[falseIndex]\n      // 慢指针+1\n      slowIndex = slowIndex + 1\n    }\n  }\n};\n```\n\n\n# 收获\n\n- 位运算取中间下标`const mid = left + ((right - left) >> 1)`，相当于`Math.floor`舍掉多余\n- 双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。\n- 好久没刷题，全忘光了，基本都是跟着题解的思路做题，希望第二遍的时候可以有点自己的思路\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-12T03:20:00.000Z",
        "date": "2023-07-12",
        "type": "Post",
        "slug": "leetcode-day-1",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-09-27T03:35:00.000Z",
        "title": "【代码随想录】算法训练营第1天",
        "category": "算法刷题",
        "tags": [
          "算法训练营",
          "数组专题"
        ],
        "status": "Invisible",
        "urlname": "dda51961-f514-4a53-8d18-3a0c1ece2132",
        "updated": "2023-09-27 03:35:00"
      },
      "body": "",
      "realName": "【代码随想录】算法训练营第1天",
      "relativePath": "/【代码随想录】算法训练营第1天.md"
    },
    {
      "id": "385c919d-f253-4976-9819-824ea05304e4",
      "doc_id": "385c919d-f253-4976-9819-824ea05304e4",
      "title": "385c919d-f253-4976-9819-824ea05304e4",
      "updated": 1693905240000,
      "body_original": "\n# 适用场景\n\n\n当开发一个组件包时，由于平台的差异，所以在某些实现上需要实现两套。\n\n\n例如，`multi-input`是一个可以同时用于微信小程序和浏览器环境的`npm`库，其中的`request`请求库在不同客户端的实现不一样。在微信环境下用的是`wx.request`，在浏览器环境用的是`fetch`。\n\n\n但是在微信环境使用时，我不希望我引入的代码中包含用不到的适用于浏览器环境的`fetch`等相关代码。再加上微信小程序对于代码体积的严格限制。所以我希望`multi-input`再引入的时候可以有多个入口，主逻辑代码直接引入`multi-input`，`request`库相关逻辑单独有个入口。\n\n\n解决办法有两种\n\n1. 将`request`库相关逻辑抽离成另外一个`npm`包\n2. `rollup`打包多入口文件并配合`package.json`中的`exports`字段实现\n\n本文介绍第二种方法，使用示例如下：\n\n\n```javascript\nimport { TestCore } from 'multi-input'\nimport { WebRequest } from 'multi-input/lib/web-request'\nimport { WxRequest } from 'multi-input/lib/web-request'\n```\n\n\n这样在微信小程序端使用并打包时，就不会将`WebRequest`相关代码打包到微信小程序代码中，实现按需引入。\n\n\n# 代码结构\n\n\n｜ 代码源码：[multi-input](https://github.com/LetTTGACO/build-project/tree/master/rollup/multi-input)\n\n\n`multi-input`库代码结构如下\n\n\n```text\n.\n|-multi-input\n  |-.gitignore\n  |-adapter // 这里面就是不同客户端的request请求库的实现\n  |  |-web-request.ts\n  |  |-wx-request.ts\n  |-src\n  |  |-core.ts\n  |  |-index.ts\n  |  |-manager\n  |  |  |-message-manager.ts\n  |  |-utils\n  |  |  |-url.ts\n  |-rollup.config.js // rollup打包配置\n  |-tsconfig.json\n  |-package.json\n```\n\n\n# 注意事项\n\n\n要想要外部以这样的方式引用，有五个必要条件\n\n1. `adapter`下的文件只能引用`adapter`目录中的文件\n2. `src`下中的文件只能引用`src`中的文件\n3. `multi-input`根目录下必须存在打包后的`lib/web-request`文件\n4. `package.json`中的`exports`字段中需要有`lib/web-request`的路径映射\n5. `rollup`需要分别打包`src`和`adapter`下的文件，多入口打包\n\n# Rollup配置\n\n\n功能点如下\n\n- 将`multi-input`以`esm`和`cjs`的模式导出，并分别导出到`dist/esm`和`dist/cjs`下\n- `adapter`下的请求库也分别以`esm`和`cjs`的模式导出，并分别导出到`dist/esm/adapter`和`dist/cjs/adapter`下\n- 打包后的类型声明文件和`js`文件和原文件目录结构保持一致\n\n```typescript\n// rollup.config.js\nimport resolve from \"@rollup/plugin-node-resolve\";\nimport commonjs from \"@rollup/plugin-commonjs\"; // 解析js\nimport typescript from \"@rollup/plugin-typescript\"; // 解析ts\n\nconst getBasePlugins = (tsConfig) => {\n  return [\n    resolve(),\n    commonjs(),\n    typescript({\n      ...tsConfig,\n    }),\n  ];\n};\n\nexport default [\n  // 主逻辑代码打包\n  {\n    input: \"src/index.ts\",\n    output: {\n      dir: \"dist/cjs\", // 打包到cjs目录\n      format: \"cjs\", // 以cjs模式打包\n      exports: \"named\", // 指定导出模式（自动、默认、命名、无）\n      preserveModules: true, // 保留模块结构，以原来的文件夹结构输出js\n      preserveModulesRoot: \"src\", // 将保留的模块放在根级别的此路径下\n    },\n    plugins: [\n      ...getBasePlugins({\n        outDir: \"dist/cjs\", // 声明文件输出目录\n        declaration: true,\n        // 指定声明文件的解析目录，这里主要是用于忽略adapter目录\n        filterRoot: \"src\",\n      }),\n    ],\n  },\n  {\n    input: \"src/index.ts\",\n    output: {\n      dir: \"dist/esm\",\n      format: \"esm\",\n      exports: \"named\",\n      preserveModules: true,\n      preserveModulesRoot: \"src\",\n    },\n    plugins: [\n      ...getBasePlugins({\n        outDir: \"dist/esm\",\n        declaration: true,\n        filterRoot: \"src\",\n      }),\n    ],\n  },\n  // adapter导出\n  {\n    input: {\n      \"web-request\": \"adapter/web-request.ts\",\n      \"wx-request\": \"adapter/wx-request.ts\",\n    },\n    output: [\n      {\n        dir: \"dist/cjs/adapter\",\n        format: \"cjs\",\n      },\n    ],\n    plugins: [\n      ...getBasePlugins({\n        outDir: \"dist/cjs/adapter\",\n        declaration: true,\n        // 指定声明文件的解析目录，这里主要是用于忽略src目录\n        // 注意tsconfig.json中不要指定rootDir，否则会导致adapter目录识别不到\n        filterRoot: \"adapter\",\n      }),\n    ],\n  },\n  {\n    input: {\n      \"web-request\": \"adapter/web-request.ts\",\n      \"wx-request\": \"adapter/wx-request.ts\",\n    },\n    output: [\n      {\n        dir: \"dist/esm/adapter\",\n        format: \"esm\",\n      },\n    ],\n    plugins: [\n      ...getBasePlugins({\n        outDir: \"dist/esm/adapter\",\n        declaration: true,\n        filterRoot: \"adapter\",\n      }),\n    ],\n  },\n];\n```\n\n\n# package.json配置\n\n\n```typescript\n// package.json\n{\n  \"name\": \"multi-input\",\n  \"version\": \"1.0.0\",\n  \"description\": \"多入口打包\",\n  \"main\": \"dist/cjs/index.js\",\n  \"module\": \"dist/esm/index.js\",\n  \"typings\": \"dist/esm/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"rollup -c rollup.config.js --bundleConfigAsCjs\",\n    \"clean\": \"rimraf -rf ./dist\"\n  },\n  \"exports\": {\n    // 定义multi-input路径引用文件\n    \".\": {\n      \"import\": \"./dist/esm/index.js\", // esm import时引用时的文件路径\n      \"require\": \"./dist/cjs/index.js\", // cjs require时引用时的文件路径\n      \"types\": \"./dist/esm/index.d.ts\" // 类型声明文件路径\n    },\n    // 定义multi-input/adapter/web-request路径引用文件\n    \"./adapter/web-request\": {\n      \"import\": \"./dist/esm/adapter/web-request.js\", // esm import时引用时的文件路径\n      \"require\": \"./dist/cjs/adapter/web-request.cjs\", // cjs require时引用时的文件路径\n      \"types\": \"./dist/esm/adapter/web-request.d.ts\" // 类型声明文件路径\n    },\n    // 定义multi-input/adapter/wx-request路径引用文件\n    \"./adapter/wx-request\": {\n      \"import\": \"./dist/esm/adapter/wx-request.js\", // esm import时引用时的文件路径\n      \"require\": \"./dist/cjs/adapter/wx-request.cjs\", // cjs require时引用时的文件路径\n      \"types\": \"./dist/esm/adapter/wx-request.d.ts\" // 类型声明文件路径\n    }\n  },\n  \"files\": [\"dist\"],\n  \"author\": \"1874\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@rollup/plugin-commonjs\": \"^25.0.4\",\n    \"@rollup/plugin-node-resolve\": \"^15.2.1\",\n    \"@rollup/plugin-typescript\": \"^11.1.3\",\n    \"rimraf\": \"^5.0.1\",\n    \"rollup\": \"^3.28.1\",\n    \"tslib\": \"^2.6.2\",\n    \"typescript\": \"^5.2.2\"\n  }\n}\n```\n\n\n# 打包后代码结构\n\n\n```typescript\n.\n|-multi-input\n  |-.gitignore\n  |-adapter\n  |  |-web-request.ts\n  |  |-wx-request.ts\n  |-dist // 打包产物\n  |  |-cjs\n  |  |  |-adapter\n  |  |  |  |-web-request.d.ts\n  |  |  |  |-web-request.js\n  |  |  |  |-wx-request.d.ts\n  |  |  |  |-wx-request.js\n  |  |  |-core.d.ts\n  |  |  |-core.js\n  |  |  |-index.d.ts\n  |  |  |-index.js\n  |  |  |-manager\n  |  |  |  |-message.d.ts\n  |  |  |  |-message.js\n  |  |  |-utils\n  |  |  |  |-url.d.ts\n  |  |  |  |-url.js\n  |  |-esm\n  |  |  |-adapter\n  |  |  |  |-web-request.d.ts\n  |  |  |  |-web-request.js\n  |  |  |  |-wx-request.d.ts\n  |  |  |  |-wx-request.js\n  |  |  |-core.d.ts\n  |  |  |-core.js\n  |  |  |-index.d.ts\n  |  |  |-index.js\n  |  |  |-manager\n  |  |  |  |-message.d.ts\n  |  |  |  |-message.js\n  |  |  |-utils\n  |  |  |  |-url.d.ts\n  |  |  |  |-url.js\n  |-src\n  |  |-core.ts\n  |  |-index.ts\n  |  |-manager\n  |  |  |-message.ts\n  |  |-utils\n  |  |  |-url.ts\n  |-rollup.config.js\n  |-tsconfig.json\n  |-package.json\n  |-pnpm-lock.yaml\n```\n\n\n# 参考资料\n\n- [Rollup中文文档](https://cn.rollupjs.org/introduction/)\n- [rollup/plugin-typescript插件配置](https://www.npmjs.com/package/@rollup/plugin-typescript)\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-09-02T17:33:00.000Z",
        "date": "2023-09-03",
        "type": "Post",
        "slug": "rollup-multi-input",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "用Rollup打包多入口npm库，实现文件按需引入",
        "更新时间": "2023-09-05T09:14:00.000Z",
        "title": "Rollup打包——多入口配置",
        "category": "技术分享",
        "tags": [
          "Rollup",
          "打包构建"
        ],
        "status": "Draft",
        "urlname": "385c919d-f253-4976-9819-824ea05304e4",
        "updated": "2023-09-05 09:14:00"
      },
      "body": "",
      "realName": "Rollup打包——多入口配置",
      "relativePath": "/Rollup打包——多入口配置.md"
    },
    {
      "id": "5d58e4df-d7ea-46d6-9c6a-19b9d301d672",
      "doc_id": "5d58e4df-d7ea-46d6-9c6a-19b9d301d672",
      "title": "5d58e4df-d7ea-46d6-9c6a-19b9d301d672",
      "updated": 1693064280000,
      "body_original": "\n1 - 「学习 / 感悟🥕」\n\n\n最近看了一些大佬的博客，发现好多大佬都有写随笔的习惯。他们会把每天的经历和思考汇总成随笔在各个平台发布。我很佩服&羡慕他们有这样的毅力和热情。\n\n\n我之前在微博也写过一些随笔和观影日记之类的，也只是坚持了小半个月左右就放弃了。\n\n\n所以呐～热情是一种难得的品质，坚持是一份难得的信念！我多么希望自己能坚持热爱一个游戏、一个活动，一份永恒的热情。\n\n\n所以接下来我将会给自己制定一些每日/每周/每月/年终总结，通过每天的思考和记录，让自己能随时回味过往的经历。\n\n\n老一辈的人总说：我吃过的盐比你走过的路都多。大人和小孩的本质区别就在于经历的丰富度上，而经历在我看来就是坎儿。只有只要你犯过足够多的错，你就能成为人们常说的百事通。\n\n\n放到编程上也是，面向 Bug 开发。我是觉得踩过足够多的坑就有成为架构师的前提了，知识的深度和广度都是必不可少的环节。\n\n\n而每日的记录和分享就会反向推动你去了解各种技术资讯，从而总结出自己的知识网络。\n\n\n干吧！从现在这篇文章开始！\n\n\n2 - 「感恩❤️」\n\n\n今天在 Notion 群里面遇到一个大佬，看了他的微信朋友圈和博客真的受益匪浅。自己也终于开始行动起来了，走出属于自己的路～\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-10T17:12:00.000Z",
        "date": "2023-04-10",
        "type": "Post",
        "slug": "day-1",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:38:00.000Z",
        "title": "Seven的成长笔记【第1篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "5d58e4df-d7ea-46d6-9c6a-19b9d301d672",
        "updated": "2023-08-26 15:38:00"
      },
      "body": "",
      "realName": "Seven的成长笔记【第1篇】",
      "relativePath": "/Seven的成长笔记【第1篇】.md"
    },
    {
      "id": "dfc6606a-ab95-45f7-94c2-4a736afdf57a",
      "doc_id": "dfc6606a-ab95-45f7-94c2-4a736afdf57a",
      "title": "dfc6606a-ab95-45f7-94c2-4a736afdf57a",
      "updated": 1693064280000,
      "body_original": "\n1 - 「学习 / 感悟🥕」\n\n\n今天在看群友们聊天才知道，Notion不是基于ChatGPT，而是Chat2.0（Notion AI自己说的），不过我从网上没找到Chat2.0相关的资讯。根据 Notion AI 对自己的解释。\n\n\n> ChatGPT 3.5是基于GPT-3语言模型的对话生成应用，它具有逼真的人工智能对话体验，能够产生高度准确、自然的文本内容。与此不同，Chat2.0是Notion内置的对话工具，主要用于与团队成员进行实时交流和合作。它注重实用性和协作功能，能够提高团队协作效率。\n\n\n我日常用到Notion AI最常用的就是帮我写代码。不同于ChatGPT需要翻墙，Notion AI 则直接可以用，而且还能顺便保存到文档里。所以我专门开了一个页面用来问问题。\n\n\n我没有专门对比过ChatGPT 3.5和 Notion AI的编程能力。到目前为止，从准确度上来说，Notion AI的编程能力还是相当可以的，虽然有时候不能完全正确，但是他至少给我提供了不错思路。这已经足够了，而且只会越来越好用。\n\n\n接触编程不久后，我就基本抛弃了百度搜索，全心全意用Google。现在来看，大部份的问题都可以直接问ChatGPT/Notion AI了。甚至我前段时间问同事一个技术问题，他直接贴了一个ChatGPT的回答给我哈哈哈哈，这确实可以减少不必要的客服时间。\n\n\nNotion AI 真香～\n\n\n2 - 「感恩❤️」\n\n\n第二天写成长日记，发现自己想说的话还挺多。至少没有感觉到写日记会很难开始。这几天准备把我女朋友也拉近团队，一起写日记、读书笔记、观影记录、桌游记录、一起打卡～ \n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-11T12:56:00.000Z",
        "date": "2023-04-11",
        "type": "Post",
        "slug": "day-2",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "Notion AI 真香～",
        "更新时间": "2023-08-26T15:38:00.000Z",
        "title": "Seven的成长笔记【第2篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "dfc6606a-ab95-45f7-94c2-4a736afdf57a",
        "updated": "2023-08-26 15:38:00"
      },
      "body": "",
      "realName": "Seven的成长笔记【第2篇】",
      "relativePath": "/Seven的成长笔记【第2篇】.md"
    },
    {
      "id": "6776bd5c-0ef2-4b60-b651-b08e0f4a4b24",
      "doc_id": "6776bd5c-0ef2-4b60-b651-b08e0f4a4b24",
      "title": "6776bd5c-0ef2-4b60-b651-b08e0f4a4b24",
      "updated": 1693064160000,
      "body_original": "\n1 - 「学习 / 感悟🥕」\n\n\n今天写了一晚上的Notion 的函数，用来给TODO List DataBase增加每周看板和上周看板\n\n\n<details>\n  <summary>如何判断该TODO为本周内的任务</summary>\n\n\n```typescript\n// 1. 获取本周起始时间（相对于现在时间的周一的00:00）\n// 1.1 获取今天的00:00\n// 1.1.1 获取今天的xx:00\nconst time1 = dateSubtract(now(), minute(now()), \"minutes\")\n// 1.1.2 获取今天的00:00\nconst time2 = dateSubtract(time1, hour(now()), \"hours\")\n// 1.2 获取周一的00:00\nconst 本周一 = dateSubtract(time2, day(now()) - 1, \"days\")\n// 函数\ndateSubtract(dateSubtract(dateSubtract(now(), minute(now()), \"minutes\"), hour(now()), \"hours\"), day(now()) - 1, \"days\")\n\n// 2. 获取本周的结束时间（相对于现在时间的周日的23:59）\n// 2.1 获取今天的23:59\n// 2.1.1 获取今天的xx:59\nconst time1 = dateAdd(dateAdd(now(), 59 - minute(now()), \"minutes\")\n// 2.1.2 获取今天的23:59\nconst time2 = dateAdd(time1, 23 - hour(now()), \"hours\")\n// 2.2 获取周天的23:59\nconst 本周天 = dateAdd(time2, 7 - day(now()), \"days\")\n// 函数\ndateAdd(dateAdd(dateAdd(now(), 59 - minute(now()), \"minutes\"), 23 - hour(now()), \"hours\"), 7 - day(now()), \"days\")\n\n// 3. 判断是否是本周\nconst 是否是本周 = and(largerEq(prop(\"日期\"), prop(\"本周一\")), smallerEq(prop(\"日期\"), prop(\"本周天\")))\n```\n\n\n\n  </details>\n\n\n<details>\n  <summary>如何判断该TODO为上周内的任务</summary>\n\n\n```typescript\n// 1. 获取上周起始时间（相对于现在时间的上周一的00:00）\n// 1.1 获取本周一的时间\nconst time1 = dateSubtract(now(), day(now()) - 1, \"days\")\n// 1.2 获取上周一的时间\nconst time2 = dateSubtract(time1, 7, \"days\")\n// 1.3 获取上周一的xx:00\nconst time3 = dateSubtract(time2, minute(time2), \"minutes\")\n// 1.4 获取上周一的00:00\nconst 上周一 = dateSubtract(time3, hour(time2), \"hours\")\n// 函数\ndateSubtract(dateSubtract(dateSubtract(dateSubtract(now(), day(now()) - 1, \"days\"), 7, \"days\"), minute(dateSubtract(dateSubtract(now(), day(now()) - 1, \"days\"), 7, \"days\")), \"minutes\"), hour(dateSubtract(dateSubtract(now(), day(now()) - 1, \"days\"), 7, \"days\")), \"hours\")\n\n// 2. 获取上周的结束时间（相对于现在时间的上周日的23:59）\n// 2.1 获取本周日的时间\nconst time1 = dateAdd(now(), 7 - day(now()), \"days\")\n// 2.2 获取上周日的时间\nconst time2 = dateSubtract(time1, 7, \"days\")\n// 2.3 获取上周日的xx:59\nconst time3 = dateAdd(time2, 59 - minute(time2), \"minutes\")\n// 2.4 获取上周日的23:59\nconst 上周日 = dateAdd(time3, 23 - hour(time2), \"hours\")\n// 函数\ndateAdd(dateAdd(dateSubtract(dateAdd(now(), 7 - day(now()), \"days\"), 7, \"days\"), 59 - minute(dateSubtract(dateAdd(now(), 7 - day(now()), \"days\"), 7, \"days\")), \"minutes\"), 23 - hour(dateSubtract(dateAdd(now(), 7 - day(now()), \"days\"), 7, \"days\")), \"hours\")\n\n// 3. 判断是否是上周\nconst 是否是上周 = and(largerEq(prop(\"日期\"), prop(\"上周一\")), smallerEq(prop(\"日期\"), prop(\"上周日\")))\n```\n\n\n\n  </details>\n\n\n2 - 「轻松一刻 🎮」\n\n\n6点准时下班，耶稣也拦不住我！去佛山听草莓音乐节咯～\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-13T15:46:00.000Z",
        "date": "2023-04-14",
        "type": "Post",
        "slug": "day-4",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "Notion 函数写起来真要命",
        "更新时间": "2023-08-26T15:36:00.000Z",
        "title": "Seven的成长笔记【第4篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "6776bd5c-0ef2-4b60-b651-b08e0f4a4b24",
        "updated": "2023-08-26 15:36:00"
      },
      "body": "",
      "realName": "Seven的成长笔记【第4篇】",
      "relativePath": "/Seven的成长笔记【第4篇】.md"
    },
    {
      "id": "7a8d6502-371a-49f8-baa2-c6e0127040f4",
      "doc_id": "7a8d6502-371a-49f8-baa2-c6e0127040f4",
      "title": "7a8d6502-371a-49f8-baa2-c6e0127040f4",
      "updated": 1693064160000,
      "body_original": "\n1 - 「总结 🥕」\n\n\n今天把之前记录的Notion函数的使用总结成一篇文档 [玩转Notion系列——TODO List](https://www.notion.so/6c0aa69b7ec647acb2fd4984e2f4e020) ，算是我搭建Notion个人主页的一个开端吧。我会把这个系列按照我自己的需求更新下去，自己获益的同时也能帮助到别人。这也是我做博客的意义：用老师的视角写文章，就会发现许多自己实践过程中的各种问题细节，这对于自己对技术的理解会更加的完善，也是一个试错的过程。\n\n\n`Seven的成长笔记`更像是一个每日总结，每天记录的一些灵感或者技术点都有可能孵化成一篇技术分享。就像在公司中，一般组内或者公司内都会组织一些技术分享会，而很多人包括我自己对于类似的分享会总是会有一些抗拒：因为根本不知道自己能分享什么。平时975的两点一线和页面仔日常，放在以前我基本总结不出什么来。\n\n\n现在分析看来，没有可分享的点的其中一个原因就是忘了自己做过什么，即使想起来后也会觉得这个点好像没啥可分享的。而现在我最直观的感觉就是：成长日记 ⇒ 孵化为头脑风暴 ⇒ 孵化为技术分享。因为平时有记录，所以回过头来写分享文章就会得心应手，稍微一拓展就是一篇技术文档。\n\n\n所以我现在是把头脑风暴直接和博客文档关联起来，尽力让每一个头脑风暴都能孵化为一篇技术文档。\n\n\n2 - 「感恩❤️」\n\n\n今天把玩转Notion系列文档分享到群里后，意外收获了一个好评 🤣，就很感谢哈哈哈哈\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-16T16:39:00.000Z",
        "date": "2023-04-15",
        "type": "Post",
        "slug": "day-5",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:36:00.000Z",
        "title": "Seven的成长笔记【第5篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "7a8d6502-371a-49f8-baa2-c6e0127040f4",
        "updated": "2023-08-26 15:36:00"
      },
      "body": "",
      "realName": "Seven的成长笔记【第5篇】",
      "relativePath": "/Seven的成长笔记【第5篇】.md"
    },
    {
      "id": "48389da8-9151-4994-9902-2166f2208925",
      "doc_id": "48389da8-9151-4994-9902-2166f2208925",
      "title": "48389da8-9151-4994-9902-2166f2208925",
      "updated": 1693064040000,
      "body_original": "\n1 - 「学习 / 感悟🥕」\n\n\n停更蛮久时间的，前段时间对自己的规划比较迷茫，最近正在在调整中…\n\n\n给自己每天晚上留30分钟来写作是我调整的第一步。\n\n\n最近在挑战 [FlowUs](https://flowus.cn/) 的客户端渲染：研究它的 Open API ，然后实现客户端渲染逻辑，甚至加强客户端渲染。预计这个月能出一个 [Demo](https://github.com/FlowUsX) ，拭目以待吧！\n\n\n刚刚在洗澡的时候，突然灵光一闪。我认识的很多大佬都有自己的公众号，很多文章都是同步更新到微信公众号上。那么Elog是否支持直接把写作平台的文档直接发布到公众号呢。虽然想过可能性不大，但是我有一个新的点子：就是把写作平台的`markdown`文档转成符合公众号排版的富文本。之前就有体验过在某个网站将`markdown`文档转成公众号排版，所以可以把这个功能集成到Elog中，最好能做到一键预览和发布！\n\n\n2 - 「感恩❤️」\n\n\n[Elog](https://elog.1874.cool/) 的 Star 数每天都有涨一两个，也有很多体验者提了一些意见，感恩TA们，这段时间会抽空重新整理下 Elog 教程和提升体验优化。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-04T15:51:00.000Z",
        "date": "2023-07-04",
        "type": "Post",
        "slug": "day-7",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "FlowUs X",
        "更新时间": "2023-08-26T15:34:00.000Z",
        "title": "Seven的成长笔记【第7篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "48389da8-9151-4994-9902-2166f2208925",
        "updated": "2023-08-26 15:34:00"
      },
      "body": "",
      "realName": "Seven的成长笔记【第7篇】",
      "relativePath": "/Seven的成长笔记【第7篇】.md"
    },
    {
      "id": "cf511d6f-d2c2-49c2-a3a2-84a1f55a546a",
      "doc_id": "cf511d6f-d2c2-49c2-a3a2-84a1f55a546a",
      "title": "cf511d6f-d2c2-49c2-a3a2-84a1f55a546a",
      "updated": 1693063680000,
      "body_original": "\n1 - 「学习 / 感悟🥕」笔记\n\n\n自从调到新组之后，发现大家基本没有写技术方案和技术评审的习惯，而且一个需求上线过程中，测试、前端、后端都不怎么沟通的。这一点让我很诧异，难道产品、测试、开发对一个需求的理解会这么同步吗？\n\n\n在之前小组，产品经理讲完需求后，开发人员会理解完需求再召集测试和产品经理重新复述一遍。而且还会开一次技术方案评审、一次测试用例评审，开发完还得再把产品经理叫过来演示一下，保证需求点的明确和一致性。但是在新组就没看到有这样的流程，想了下可能有以下几个原因：\n\n1. 新组的大部分需求点非常的小，所以相当的明确，基本上大家做好自己的事就行\n2. 再加上每个人负责的模块相对独立，所以技术细节基本上都是自己说了算\n3. 相对之前的组，确实缺少一些技术氛围\n\n这其实让我有点不太适应，但因为我时间相对比较充裕，而且需要理解新的业务和需求。我还是尽量保持之前的习惯，基本上每个需求都写了技术方案。方便自己也方便测试人员，至少在出问题的时候能溯源，到底是需求问题还是我的代码问题。\n\n\n2 - 「感恩❤️」\n\n\nV2EX这个网站真的是摸鱼神器，无聊的时候刷刷帖子还挺能学到很多知识的，里面的大佬是真的多，非常Nice！\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-05T15:26:00.000Z",
        "date": "2023-07-05",
        "type": "Post",
        "slug": "day-8",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:28:00.000Z",
        "title": "Seven的成长笔记【第8篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "cf511d6f-d2c2-49c2-a3a2-84a1f55a546a",
        "updated": "2023-08-26 15:28:00"
      },
      "body": "",
      "realName": "Seven的成长笔记【第8篇】",
      "relativePath": "/Seven的成长笔记【第8篇】.md"
    },
    {
      "id": "dce9227d-2771-4829-8748-2f85fe4f57ca",
      "doc_id": "dce9227d-2771-4829-8748-2f85fe4f57ca",
      "title": "dce9227d-2771-4829-8748-2f85fe4f57ca",
      "updated": 1693063680000,
      "body_original": "\n1 - 「学习 / 感悟🥕」\n\n\n今天遇到了一个宝藏博主，他的知识库的规划让我醍醐灌顶。\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/ea428668-4d33-404b-a53e-fc49705ebef9/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230927T015942Z&X-Amz-Expires=3600&X-Amz-Signature=8a187252a5a7aa799c0d61f232be00ca5b345df726bb23a26bd3bbc0d6941b70&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n首先，从布局上就很舒适，也很好看。随意翻看了几篇文档，以为他是一个产品经理，不是一个程序员，但是又回想到他自己有开发前端工具来着。随后我又认真看了他的花园定位\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a3c965e4-e9c3-4cab-b4ca-de0a6bba4a4d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230927T015942Z&X-Amz-Expires=3600&X-Amz-Signature=fe5d0b079b493cbcf53c023eb503fda7e74be07b8ec4c8163b57dbc203771393&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n突然有了一种豁然开朗的感觉。因为在我的潜意识里，程序员就是单纯搞技术的人。但是博主给我的感觉就是，程序员是是可以「不设限-技术之外」的。这让我重新审视了自己的一些规划，甚至解决了困扰我的一个问题：如果我今天没有学到什么，我拿什么写成长日记？现在已经解决了，我没必要总结一些仅限于技术和我认为的领域内的东西，我有无限的知识海洋可以翱翔！\n\n\n我瞬间就罗列了很多我之前存在的痛点，然后有了一个大概的计划去实施。\n\n\n至少，未来一阵子不会彷徨了～\n\n\n2 - 「感恩❤️」\n\n\n感谢 [vannvan](https://www.yuque.com/vannvan)，让我受益匪浅。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-08T15:34:00.000Z",
        "date": "2023-07-09",
        "type": "Post",
        "slug": "day-9",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:28:00.000Z",
        "title": "Seven的成长笔记【第9篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "dce9227d-2771-4829-8748-2f85fe4f57ca",
        "updated": "2023-08-26 15:28:00"
      },
      "body": "",
      "realName": "Seven的成长笔记【第9篇】",
      "relativePath": "/Seven的成长笔记【第9篇】.md"
    },
    {
      "id": "0b80c709-5327-47c1-80e4-383090c64040",
      "doc_id": "0b80c709-5327-47c1-80e4-383090c64040",
      "title": "0b80c709-5327-47c1-80e4-383090c64040",
      "updated": 1693063560000,
      "body_original": "\n# 引言\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-03-29",
        "type": "Post",
        "slug": "react-state",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第六章 状态更新",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "0b80c709-5327-47c1-80e4-383090c64040",
        "updated": "2023-08-26 15:26:00"
      },
      "body": "",
      "realName": "第六章 状态更新",
      "relativePath": "/第六章 状态更新.md"
    },
    {
      "id": "8c1f610f-80e0-45a6-821f-ba595c26e48a",
      "doc_id": "8c1f610f-80e0-45a6-821f-ba595c26e48a",
      "title": "8c1f610f-80e0-45a6-821f-ba595c26e48a",
      "updated": 1693063560000,
      "body_original": "\n# 引言\n\n\n对于`update`的组件，`React`会将当前组件与该组件在上次更新时对应的`Fiber`节点比较（也就是俗称的`Diff`算法），将比较的结果生成新`Fiber`节点。\n\n\n> 你可以从[这里](https://zh-hans.reactjs.org/docs/reconciliation.html#the-diffing-algorithm)看到Diff算法的介绍。\n\n\n一个 DOM 节点在某一时刻最多会有 4 个节点和他相关。\n\n1. `current Fiber`。如果该`DOM`节点已在页面中，`current Fiber`代表该`DOM`节点对应的`Fiber`节点。\n2. `workInProgress Fiber`。如果该`DOM`节点将在本次更新中渲染到页面中，`workInProgress Fiber`代表该`DOM`节点对应的`Fiber`节点。\n3. `DOM`节点本身。\n4. `JSX`对象。即`ClassComponent`的`render`方法的返回结果，或`FunctionComponent`的调用结果。`JSX`对象中包含描述`DOM`节点的信息。\n\n`Diff`算法的本质是对比 1 和 4，生成 2。\n\n\n# Diff 的瓶颈以及 React 如何应对\n\n\n由于`Diff`操作本身也会带来性能损耗，`React`文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 `O(n3)`，其中`n`是树中元素的数量。 如果在`React`中使用了该算法，那么展示`1000`个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。 为了降低算法复杂度，`React`的`diff`会预设三个限制：\n\n1. 只对同级元素进行`Diff`。如果一个`DOM`节点在前后两次更新中跨越了层级，那么`React`不会尝试复用他。\n2. 两个不同类型的元素会产生出不同的树。如果元素由`div`变为`p`，`React`会销毁`div`及其子孙节点，并新建`p`及其子孙节点。\n3. 开发者可以通过 `key prop`来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：\n\n```html\n// 更新前\n<div>\n  <p key=\"ka\">ka</p>\n  <h3 key=\"song\">song</h3>\n</div>\n\n// 更新后\n<div>\n  <h3 key=\"song\">song</h3>\n  <p key=\"ka\">ka</p>\n</div>\n```\n\n\n如果没有`key`，`React`会认为`div`的第一个子节点由`p`变为`h3`，第二个子节点由`h3`变为`p`。这符合限制 2 的设定，会销毁并新建。 但是当我们用`key`指明了节点前后对应关系后，`React`知道`key === \"ka\"`的`p`在更新后还存在，所以`DOM`节点可以复用，只是需要交换下顺序。 这就是`React`为了应对算法性能瓶颈做出的三条限制。\n\n\n# Diff 是如何实现的\n\n\n从`Diff`的入口函数`reconcileChildFibers`出发，该函数会根据`newChild`（即`JSX`对象）类型调用不同的处理函数。\n\n\n> 你可以从[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1280)看到`reconcileChildFibers`的源码。\n\n\n```typescript\n// 根据newChild类型选择不同diff函数处理\nfunction reconcileChildFibers(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChild: any\n): Fiber | null {\n  const isObject = typeof newChild === \"object\" && newChild !== null;\n\n  if (isObject) {\n    // object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE\n    switch (newChild.$$typeof) {\n      case REACT_ELEMENT_TYPE:\n      // 调用 reconcileSingleElement 处理\n      // // ...省略其他case\n    }\n  }\n\n  if (typeof newChild === \"string\" || typeof newChild === \"number\") {\n    // 调用 reconcileSingleTextNode 处理\n    // ...省略\n  }\n\n  if (isArray(newChild)) {\n    // 调用 reconcileChildrenArray 处理\n    // ...省略\n  }\n\n  // 一些其他情况调用处理函数\n  // ...省略\n\n  // 以上都没有命中，删除节点\n  return deleteRemainingChildren(returnFiber, currentFirstChild);\n}\n```\n\n\n可以从同级的节点数量将`Diff`分为两类：\n\n1. 当`newChild`类型为`object`、`number`、`string`，代表同级只有一个节点\n2. 当`newChild`类型为`Array`，同级有多个节点\n\n# 单节点 Diff\n\n\n对于单个节点，以类型`object`为例，会进入`reconcileSingleElement`\n\n\n> 你可以从[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1141)看到`reconcileSingleElement`源码\n\n\n```typescript\nconst isObject = typeof newChild === \"object\" && newChild !== null;\n\nif (isObject) {\n  // 对象类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE\n  switch (newChild.$$typeof) {\n    case REACT_ELEMENT_TYPE:\n    // 调用 reconcileSingleElement 处理\n    // ...其他case\n  }\n}\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fob_llXO4IWuOz8t8LLXpU1vWzZv.png)\n\n\n```typescript\n// returnFiber: current fiber的父级fiber\n// currentFirstChild: 当前的current fiber，mount时不存在\n// element: JSX对象\n// lanes: 优先级相关，透传\nfunction reconcileSingleElement(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  element: ReactElement,\n  lanes: Lanes\n): Fiber {\n  const key = element.key;\n  let child = currentFirstChild;\n\n  // 首先判断是否存在对应DOM节点\n  // 在mount时，不存在current fiber对应的dom节点\n  while (child !== null) {\n    // 上一次更新存在DOM节点，接下来判断是否可复用\n\n    // 首先比较key是否相同\n    if (child.key === key) {\n      // key相同，接下来比较type是否相同\n      switch (child.tag) {\n        // ...省略case\n\n        default: {\n          if (child.elementType === element.type) {\n            // type相同则表示可以复用\n            // 删除剩余的已经存在的children\n            // 对于单一节点的更新，已经找到了可以复用的fiber，其余的fiber就没用了\n            deleteRemainingChildren(returnFiber, child.sibling);\n            // useFiber：复用老的fiber（current fiber），生成新fiber（work in progress fiber）\n            const existing = useFiber(child, element.props);\n            existing.ref = coerceRef(returnFiber, child, element);\n            existing.return = returnFiber;\n            // 返回复用的fiber\n            return existing;\n          }\n          // type不同则跳出switch\n          break;\n        }\n      }\n      // 代码执行到这里代表：key相同但是type不同\n      // 将该fiber及其兄弟fiber标记为删除\n      // Remaining：其余的\n      deleteRemainingChildren(returnFiber, child);\n      break;\n    } else {\n      // key不同，将该fiber标记为删除\n      deleteChild(returnFiber, child);\n    }\n    // 存在更新前是多个节点，更新后是一个节点，就需要将之前的多个节点依次与新节点对比，直到找出可复用的节点\n    // 这里赋值后可再次进入循环\n    child = child.sibling;\n  }\n\n  // 创建新Fiber，并返回 ...省略\n}\n```\n\n\n从代码可以看出，`React`通过先判断`key`是否相同，如果`key`相同则判断`type`是否相同，只有都相同时一个`DOM`节点才能复用。 这里有个细节需要关注下：\n\n- 当`child !== null`且`key`相同且`type`不同时执行`deleteRemainingChildren`将`child`及其兄弟`fiber`都标记删除。\n- 当`child !== null且key`不同时仅将 child 标记删除。\n\n考虑如下例子： 当前页面有 3 个`li`，我们要全部删除，再插入一个`p`。\n\n\n```text\n// 当前页面显示的\nul > li * 3\n\n// 这次需要更新的\nul > p\n```\n\n\n由于本次更新时只有一个`p`，属于单一节点的`Diff`，会走上面介绍的代码逻辑。 在`reconcileSingleElement`中遍历之前的 3 个`fiber`（对应的`DOM`为 3 个`li`），寻找本次更新的`p`是否可以复用之前的 3 个`fiber`中某个的`DOM`。 当`key`相同且`type`不同时，代表我们已经找到本次更新的`p`对应的上次的`fiber`，但是`p`与`li` `type`不同，不能复用。既然唯一的可能性已经不能复用，则剩下的`fiber`都没有机会了，所以都需要标记删除。 当`key`不同时只代表遍历到的该`fiber`不能被`p`复用，后面还有兄弟`fiber`还没有遍历到。所以仅仅标记该 fiber 删除。\n\n\n## 练习题\n\n\n请判断如下`JSX`对象对应的`DOM`元素是否可以复用：\n\n\n```html\n// 习题1 更新前\n<div>ka song</div>\n// 更新后\n<p>ka song</p>\n\n// 习题2 更新前\n<div key=\"xxx\">ka song</div>\n// 更新后\n<div key=\"ooo\">ka song</div>\n\n// 习题3 更新前\n<div key=\"xxx\">ka song</div>\n// 更新后\n<p key=\"ooo\">ka song</p>\n\n// 习题4 更新前\n<div key=\"xxx\">ka song</div>\n// 更新后\n<div key=\"xxx\">xiao bei</div>\n```\n\n\n答案： 习题 1: 未设置`key prop`默认 `key = null`，所以更新前后`key`相同，都为`null`，但是更新前`type`为`div`，更新后为`p`，`type`改变则不能复用。 习题 2: 更新前后`key`改变，不需要再判断`type`，不能复用。 习题 3: 更新前后`key`改变，不需要再判断`type`，不能复用。 习题 4: 更新前后`key`与`type`都未改变，可以复用。`children`变化，`DOM`的子元素需要更新。\n\n\n# 多节点 Diff\n\n\n现在考虑我们有一个`FunctionComponent`：\n\n\n```html\nfunction List () {\n  return (\n    <ul>\n      <li key=\"0\">0</li>\n      <li key=\"1\">1</li>\n      <li key=\"2\">2</li>\n      <li key=\"3\">3</li>\n    </ul>\n  )\n}\n```\n\n\n他的返回值`JSX`对象的`children`属性不是单一节点，而是包含四个对象的数组\n\n\n```typescript\n{\n  $$typeof: Symbol(react.element),\n  key: null,\n  props: {\n    children: [\n      {$$typeof: Symbol(react.element), type: \"li\", key: \"0\", ref: null, props: {…}, …}\n      {$$typeof: Symbol(react.element), type: \"li\", key: \"1\", ref: null, props: {…}, …}\n      {$$typeof: Symbol(react.element), type: \"li\", key: \"2\", ref: null, props: {…}, …}\n      {$$typeof: Symbol(react.element), type: \"li\", key: \"3\", ref: null, props: {…}, …}\n    ]\n  },\n  ref: null,\n  type: \"ul\"\n}\n```\n\n\n这种情况下，`reconcileChildFibers`的`newChild`参数类型为`Array`，在`reconcileChildFibers`函数内部对应如下情况：\n\n\n> 你可以在[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L1352)看到这段源码逻辑\n\n\n```typescript\nif (isArray(newChild)) {\n  // 调用 reconcileChildrenArray 处理\n  // ...省略\n}\n```\n\n\n## 场景归纳\n\n\n### 场景 1：节点更新\n\n\n```typescript\n// 之前\n<ul>\n  <li key=\"0\" className=\"before\">0<li>\n  <li key=\"1\">1<li>\n</ul>\n\n// 之后 情况1 —— 节点属性变化\n<ul>\n  <li key=\"0\" className=\"after\">0<li>\n  <li key=\"1\">1<li>\n</ul>\n\n// 之后 情况2 —— 节点类型更新\n<ul>\n  <div key=\"0\">0</div>\n  <li key=\"1\">1<li>\n</ul>\n```\n\n\n### 场景 2：节点新增或减少\n\n\n```typescript\n// 之前\n<ul>\n  <li key=\"0\">0<li>\n  <li key=\"1\">1<li>\n</ul>\n\n// 之后 情况1 —— 新增节点\n<ul>\n  <li key=\"0\">0<li>\n  <li key=\"1\">1<li>\n  <li key=\"2\">2<li>\n</ul>\n\n// 之后 情况2 —— 删除节点\n<ul>\n  <li key=\"1\">1<li>\n</ul>\n```\n\n\n### 场景 3：节点位置变化\n\n\n```typescript\n// 之前\n<ul>\n  <li key=\"0\">0<li>\n  <li key=\"1\">1<li>\n</ul>\n\n// 之后\n<ul>\n  <li key=\"1\">1<li>\n  <li key=\"0\">0<li>\n</ul>\n```\n\n\n同级多个节点的`Diff`，一定属于以上三种情况中的一种或多种。\n\n\n## Diff 的思路\n\n\n该如何设计 Diff 算法呢？一般思路：\n\n1. 判断当前节点的更新属于哪种情况\n2. 如果是新增，执行新增逻辑\n3. 如果是删除，执行删除逻辑\n4. 如果是更新，执行更新逻辑\n\n按这个方案，其实有个隐含的前提——**不同操作的优先级是相同的** 但是`React`团队发现，在日常开发中，相较于新增和删除，更新组件发生的频率更高。所以`Diff`会优先判断当前节点是否属于更新。\n\n\n> 注意 在我们做数组相关的算法题时，经常使用双指针从数组头和尾同时遍历以提高效率，但是这里却不行。 虽然本次更新的JSX对象 newChildren为数组形式，但是和newChildren中每个组件进行比较的是current fiber，同级的Fiber节点是由sibling指针链接形成的单链表，即不支持双指针遍历。 即 newChildren[0]与fiber比较，newChildren[1]与fiber.sibling比较。 所以无法使用双指针优化。\n\n\n基于以上原因，`Diff`算法的整体逻辑会经历两轮遍历： 第一轮遍历：处理`更新`的节点。 第二轮遍历：处理剩下的`不属于更新`的节点。\n\n\n## 第一轮遍历\n\n\n第一轮遍历步骤如下：\n\n1. `let i = 0`，遍历`newChildren`，将`newChildren[i]`与`oldFiber`比较，判断`DOM`节点是否可复用。\n2. 如果可复用，`i++`，继续比较`newChildren[i]`与`oldFiber.sibling`，可以复用则继续遍历。\n3. 如果不可复用，分两种情况：\n- `key`不同导致不可复用，立即跳出整个遍历，第一轮遍历结束。第一轮遍历只处理节点更新，也就是 key 相同的情况\n- `key`相同 type`不同`导致不可复用，会将`oldFiber`标记为`DELETION`，并继续遍历\n1. 如果`newChildren`遍历完（即`i === newChildren.length - 1`）或者`oldFiber`遍历完（即`oldFiber.sibling === null`），跳出遍历，第一轮遍历结束\n\n> 你可以从[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L818)看到这轮遍历的源码\n\n\n当遍历结束后，会有两种结果：\n\n\n### 1.步骤 3 跳出的遍历\n\n\n此时`newChildren`没有遍历完，`oldFiber`也没有遍历完。 举个例子，考虑如下代码：\n\n\n```html\n// 之前\n<li key=\"0\">0</li>\n<li key=\"1\">1</li>\n<li key=\"2\">2</li>\n\n// 之后\n<li key=\"0\">0</li>\n<li key=\"2\">1</li>\n<li key=\"1\">2</li>\n```\n\n\n第一个节点可复用，遍历到`key === 2`的节点发现`key`改变，不可复用，跳出遍历，等待第二轮遍历处理。 此时`oldFiber`剩下`key === 1`、`key === 2`未遍历，`newChildren`剩下`key === 2`、`key === 1`未遍历。\n\n\n### 2.步骤 4 跳出的遍历\n\n\n可能`newChildren`遍历完，或`oldFiber`遍历完，或他们同时遍历完。 举个例子，考虑如下代码：\n\n\n```html\n// 之前\n<li key=\"0\" className=\"a\">0</li>\n<li key=\"1\" className=\"b\">1</li>\n            \n// 之后 情况1 —— newChildren与oldFiber都遍历完\n<li key=\"0\" className=\"aa\">0</li>\n<li key=\"1\" className=\"bb\">1</li>\n            \n// 之后 情况2 —— newChildren没遍历完，oldFiber遍历完\n// newChildren剩下 key===\"2\" 未遍历\n<li key=\"0\" className=\"aa\">0</li>\n<li key=\"1\" className=\"bb\">1</li>\n<li key=\"2\" className=\"cc\">2</li>\n            \n// 之后 情况3 —— newChildren遍历完，oldFiber没遍历完\n// oldFiber剩下 key===\"1\" 未遍历\n<li key=\"0\" className=\"aa\">0</li>\n```\n\n\n带着第一轮遍历的结果，我们开始第二轮遍历。\n\n\n## 第二轮遍历\n\n\n对于第一轮遍历的结果，我们分别讨论：\n\n\n### newChildren 与 oldFiber 同时遍历完\n\n\n那就是最理想的情况：只需在第一轮遍历进行组件[更新](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L825)。此时 Diff 结束。\n\n\n### newChildren 没遍历完，oldFiber 遍历完\n\n\n已有的`DOM`节点都复用了，这时还有新加入的节点，意味着本次更新有新节点插入，我们只需要遍历剩下的`newChildren`为生成的`workInProgress fiber`依次标记`Placement`。\n\n\n> 你可以在[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L869)看到这段源码逻辑\n\n\n### newChildren 遍历完，oldFiber 没遍历完\n\n\n意味着本次更新比之前的节点数量少，有节点被删除了。所以需要遍历剩下的`oldFiber`，依次标记`Deletion`。\n\n\n> 你可以在[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L863)看到这段源码逻辑\n\n\n### newChildren 与 oldFiber 遍历完\n\n\n这意味着有节点在这次更新中改变了位置。 这是`Diff`算法最精髓也是最难懂的部分。\n\n\n> 你可以在[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L893)看到这段源码逻辑\n\n\n## 处理移动的节点\n\n\n由于有节点改变了位置，所以不能再用位置索引 i 对比前后的节点，那么如何才能将同一个节点在两次更新中对应上呢？ 我们需要使用`key`。 为了快速的找到`key`对应的`oldFiber`，我们将所有还未处理的`oldFiber`存入以`key`为`key`，`oldFiber`为`value`的`Map`中。\n\n\n```typescript\nconst existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n```\n\n\n> 你可以在[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactChildFiber.new.js#L890)看到这段源码逻辑\n\n\n接下来遍历剩余的`newChildren`，通过`newChildren[i].key`就能在`existingChildren`中找到`key`相同的`oldFiber`。\n\n\n## 标记节点是否移动\n\n\n既然我们的目标是寻找移动的节点，那么我们需要明确：节点是否移动是以什么为参照物？ 我们的参照物是：最后一个可复用的节点在`oldFiber`中的位置索引（用变量`lastPlacedIndex`表示）。 由于本次更新中节点是按`newChildren`的顺序排列。在遍历`newChildren`过程中，每个遍历到的可复用节点一定是当前遍历到的所有可复用节点中最靠右的那个，即一定在`lastPlacedIndex`对应的可复用的节点在本次更新中位置的后面。 那么我们只需要比较遍历到的可复用节点在上次更新时是否也在`lastPlacedIndex`对应的`oldFiber`后面，就能知道两次更新中这两个节点的相对位置改变没有。 我们用变量`oldIndex`表示遍历到的可复用节点在`oldFiber`中的位置索引。如果`oldIndex < lastPlacedIndex`，代表本次更新该节点需要向右移动。 `lastPlacedIndex`初始为`0`，每遍历一个可复用的节点，如果`oldIndex >= lastPlacedIndex`，则`lastPlacedIndex = oldIndex`。 这里有两个 Demo，可以对照着理解。\n\n\n### Demo1\n\n\n在`Demo`中我们简化下书写，每个字母代表一个节点，字母的值代表节点的`key`\n\n\n```typescript\n\n// 之前\nabcd\n\n// 之后\nacdb\n\n===第一轮遍历开始===\na（之后）vs a（之前）\nkey不变，可复用\n此时 a 对应的oldFiber（之前的a）在之前的数组（abcd）中索引为0\n所以 lastPlacedIndex = 0;\n\n继续第一轮遍历...\n\nc（之后）vs b（之前）\nkey改变，不能复用，跳出第一轮遍历\n此时 lastPlacedIndex === 0;\n===第一轮遍历结束===\n\n===第二轮遍历开始===\nnewChildren === cdb，没用完，不需要执行删除旧节点\noldFiber === bcd，没用完，不需要执行插入新节点\n\n将剩余oldFiber（bcd）保存为map\n\n// 当前oldFiber：bcd\n// 当前newChildren：cdb\n\n继续遍历剩余newChildren\n\nkey === c 在 oldFiber中存在\nconst oldIndex = c（之前）.index;\n此时 oldIndex === 2;  // 之前节点为 abcd，所以c.index === 2\n比较 oldIndex 与 lastPlacedIndex;\n\n如果 oldIndex >= lastPlacedIndex 代表该可复用节点不需要移动\n并将 lastPlacedIndex = oldIndex;\n如果 oldIndex < lastplacedIndex 该可复用节点之前插入的位置索引小于这次更新需要插入的位置索引，代表该节点需要向右移动\n\n在例子中，oldIndex 2 > lastPlacedIndex 0，\n则 lastPlacedIndex = 2;\nc节点位置不变\n\n继续遍历剩余newChildren\n\n// 当前oldFiber：bd\n// 当前newChildren：db\n\nkey === d 在 oldFiber中存在\nconst oldIndex = d（之前）.index;\noldIndex 3 > lastPlacedIndex 2 // 之前节点为 abcd，所以d.index === 3\n则 lastPlacedIndex = 3;\nd节点位置不变\n\n继续遍历剩余newChildren\n\n// 当前oldFiber：b\n// 当前newChildren：b\n\nkey === b 在 oldFiber中存在\nconst oldIndex = b（之前）.index;\noldIndex 1 < lastPlacedIndex 3 // 之前节点为 abcd，所以b.index === 1\n则 b节点需要向右移动\n===第二轮遍历结束===\n\n最终acd 3个节点都没有移动，b节点被标记为移动\n```\n\n\n### Demo2\n\n\n```text\n// 之前\nabcd\n\n// 之后\ndabc\n\n===第一轮遍历开始===\nd（之后）vs a（之前）\nkey改变，不能复用，跳出遍历\n===第一轮遍历结束===\n\n===第二轮遍历开始===\nnewChildren === dabc，没用完，不需要执行删除旧节点\noldFiber === abcd，没用完，不需要执行插入新节点\n\n将剩余oldFiber（abcd）保存为map\n\n继续遍历剩余newChildren\n\n// 当前oldFiber：abcd\n// 当前newChildren dabc\n\nkey === d 在 oldFiber中存在\nconst oldIndex = d（之前）.index;\n此时 oldIndex === 3; // 之前节点为 abcd，所以d.index === 3\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 3 > lastPlacedIndex 0\n则 lastPlacedIndex = 3;\nd节点位置不变\n\n继续遍历剩余newChildren\n\n// 当前oldFiber：abc\n// 当前newChildren abc\n\nkey === a 在 oldFiber中存在\nconst oldIndex = a（之前）.index; // 之前节点为 abcd，所以a.index === 0\n此时 oldIndex === 0;\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 0 < lastPlacedIndex 3\n则 a节点需要向右移动\n\n继续遍历剩余newChildren\n\n// 当前oldFiber：bc\n// 当前newChildren bc\n\nkey === b 在 oldFiber中存在\nconst oldIndex = b（之前）.index; // 之前节点为 abcd，所以b.index === 1\n此时 oldIndex === 1;\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 1 < lastPlacedIndex 3\n则 b节点需要向右移动\n\n继续遍历剩余newChildren\n\n// 当前oldFiber：c\n// 当前newChildren c\n\nkey === c 在 oldFiber中存在\nconst oldIndex = c（之前）.index; // 之前节点为 abcd，所以c.index === 2\n此时 oldIndex === 2;\n比较 oldIndex 与 lastPlacedIndex;\noldIndex 2 < lastPlacedIndex 3\n则 c节点需要向右移动\n\n===第二轮遍历结束===\n```\n\n\n可以看到，我们以为从 `abcd` 变为 `dabc`，只需要将`d`移动到前面。 但实际上`React`保持`d`不变，将`abc`分别移动到了`d`的后面。 从这点可以看出，考虑性能，我们要尽量减少将节点从后面移动到前面的操作。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-03-28",
        "type": "Post",
        "slug": "react-diff",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第五章 Diff算法",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "8c1f610f-80e0-45a6-821f-ba595c26e48a",
        "updated": "2023-08-26 15:26:00"
      },
      "body": "",
      "realName": "第五章 Diff算法",
      "relativePath": "/第五章 Diff算法.md"
    },
    {
      "id": "dcac3fa7-a41d-42ed-837b-79311b3e6e3c",
      "doc_id": "dcac3fa7-a41d-42ed-837b-79311b3e6e3c",
      "title": "dcac3fa7-a41d-42ed-837b-79311b3e6e3c",
      "updated": 1693063560000,
      "body_original": "\n`commitRoot`方法是`commit`阶段工作的起点。`fiberRootNode`会作为传参。\n\n\n```typescript\ncommitRoot(root);\n```\n\n\n在`rootFiber.firstEffect`上保存了一条需要执行副作用的`Fiber节点`的单向链表`effectList`，这些`Fiber节点`的`updateQueue`中保存了变化的`props`。 这些副作用对应的`DOM`操作在`commit`阶段执行。 除此之外，一些生命周期钩子（比如`componentDidXXX`）、`hook`（比如`useEffect`）需要在`commit`阶段执行。 `commit`阶段的主要工作（即`Renderer`的工作流程）分为三部分：\n\n- `before mutation`阶段（执行`DOM操作前`）\n- `mutation`阶段（执行`DOM操作`）\n- `layout`阶段（执行`DOM操作后`）\n\n> 可以从[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2001)看到 commit 阶段的完整代码。\n\n\n在`before mutation`阶段之前和`layout`阶段之后还有一些额外工作，涉及到比如`useEffect`的触发、优先级相关的重置、`ref`的绑定/解绑。\n\n\n# 流程概述\n\n\n## before mutation 之前\n\n\n`commitRootImpl`方法中直到第一句`if (firstEffect !== null)`之前属于`before mutation`之前。\n\n\n```typescript\ndo {\n  // 触发useEffect回调与其他同步任务。由于这些任务可能触发新的渲染，\n  // 所以这里要一直遍历执行直到没有任务\n  flushPassiveEffects();\n} while (rootWithPendingPassiveEffects !== null);\n\n// root指 fiberRootNode\n// root.finishedWork指当前应用的rootFiber\nconst finishedWork = root.finishedWork;\n\n// 凡是变量名带lane的都是优先级相关\nconst lanes = root.finishedLanes;\nif (finishedWork === null) {\n  return null;\n}\nroot.finishedWork = null;\nroot.finishedLanes = NoLanes;\n\n// 重置Scheduler绑定的回调函数\nroot.callbackNode = null;\nroot.callbackId = NoLanes;\n\nlet remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n// 重置优先级相关变量\nmarkRootFinished(root, remainingLanes);\n\n// 清除已完成的discrete updates，例如：用户鼠标点击触发的更新。\nif (rootsWithPendingDiscreteUpdates !== null) {\n  if (\n    !hasDiscreteLanes(remainingLanes) &&\n    rootsWithPendingDiscreteUpdates.has(root)\n  ) {\n    rootsWithPendingDiscreteUpdates.delete(root);\n  }\n}\n\n// 重置全局变量\nif (root === workInProgressRoot) {\n  workInProgressRoot = null;\n  workInProgress = null;\n  workInProgressRootRenderLanes = NoLanes;\n} else {\n}\n\n// 将effectList赋值给firstEffect\n// 由于每个fiber的effectList只包含他的子孙节点\n// 所以根节点如果有effectTag则不会被包含进来\n// 所以这里将有effectTag的根节点插入到effectList尾部\n// 这样才能保证有effect的fiber都在effectList中\nlet firstEffect;\nif (finishedWork.effectTag > PerformedWork) {\n  if (finishedWork.lastEffect !== null) {\n    finishedWork.lastEffect.nextEffect = finishedWork;\n    firstEffect = finishedWork.firstEffect;\n  } else {\n    firstEffect = finishedWork;\n  }\n} else {\n  // 根节点没有effectTag\n  firstEffect = finishedWork.firstEffect;\n}\n```\n\n\n可以看到，`before mutation`之前主要做一些变量赋值，状态重置的工作。 这一长串代码我们只需要关注最后赋值的`firstEffect`，在`commit`的三个子阶段都会用到他。\n\n\n## layout 之后\n\n\n```typescript\nconst rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n// useEffect相关\nif (rootDoesHavePassiveEffects) {\n  rootDoesHavePassiveEffects = false;\n  rootWithPendingPassiveEffects = root;\n  pendingPassiveEffectsLanes = lanes;\n  pendingPassiveEffectsRenderPriority = renderPriorityLevel;\n} else {\n}\n\n// 性能优化相关\nif (remainingLanes !== NoLanes) {\n  if (enableSchedulerTracing) {\n    // ...\n  }\n} else {\n  // ...\n}\n\n// 性能优化相关\nif (enableSchedulerTracing) {\n  if (!rootDidHavePassiveEffects) {\n    // ...\n  }\n}\n\n// ...检测无限循环的同步任务\nif (remainingLanes === SyncLane) {\n  // ...\n}\n\n// 在离开commitRoot函数前调用，触发一次新的调度，确保任何附加的任务被调度\nensureRootIsScheduled(root, now());\n\n// ...处理未捕获错误及老版本遗留的边界问题\n\n// 执行同步任务，这样同步任务不需要等到下次事件循环再执行\n// 比如在 componentDidMount 中执行 setState 创建的更新会在这里被同步执行\n// 或useLayoutEffect\nflushSyncCallbackQueue();\n\nreturn null;\n```\n\n\n> 你可以在[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2195)看到这段代码\n\n\n主要包括三点内容：\n\n1. useEffect 相关的处理。\n2. 性能追踪相关。\n\n\t> 源码里有很多和interaction相关的变量。他们都和追踪React渲染时间、性能相关，[Profiler API](https://zh-hans.reactjs.org/docs/profiler.html)和[DevTools](https://github.com/facebook/react-devtools/pull/1069)中使用。可以在这里看到[interaction的定义](https://gist.github.com/bvaughn/8de925562903afd2e7a12554adcdda16#overview)\n\n3. 在 commit 阶段会触发一些生命周期钩子（如 componentDidXXX）和 hook（如 useLayoutEffect、useEffect）。\n\n在这些回调方法中可能触发新的更新，新的更新会开启新的 render-commit 流程。\n\n\n# before mutation 阶段\n\n\n`Renderer`工作的阶段被称为`commit`阶段。`commit`阶段可以分为三个子阶段：\n\n- before mutation 阶段（执行 DOM 操作前）\n- mutation 阶段（执行 DOM 操作）\n- layout 阶段（执行 DOM 操作后）\n\n`before mutation`阶段的代码很短，整个过程就是遍历`effectList`并调用`commitBeforeMutationEffects`函数处理。\n\n\n> 这部分[源码在这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2104-L2127)，为了增加可读性，示例代码中删除了不相关的逻辑。\n\n\n```typescript\n// 保存之前的优先级，以同步优先级执行，执行完毕后恢复之前优先级\nconst previousLanePriority = getCurrentUpdateLanePriority();\nsetCurrentUpdateLanePriority(SyncLanePriority);\n\n// 将当前上下文标记为CommitContext，作为commit阶段的标志\nconst prevExecutionContext = executionContext;\nexecutionContext |= CommitContext;\n\n// 处理focus状态\nfocusedInstanceHandle = prepareForCommit(root.containerInfo);\nshouldFireAfterActiveInstanceBlur = false;\n\n// beforeMutation阶段的主函数\ncommitBeforeMutationEffects(finishedWork);\n\nfocusedInstanceHandle = null;\n```\n\n\n## commitBeforeMutationEffects\n\n\n```typescript\nfunction commitBeforeMutationEffects() {\n  while (nextEffect !== null) {\n    const current = nextEffect.alternate;\n\n    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {\n      // ...focus blur相关\n    }\n\n    const effectTag = nextEffect.effectTag;\n\n    // 调用getSnapshotBeforeUpdate\n    if ((effectTag & Snapshot) !== NoEffect) {\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\n    }\n\n    // 调度useEffect\n    if ((effectTag & Passive) !== NoEffect) {\n      if (!rootDoesHavePassiveEffects) {\n        rootDoesHavePassiveEffects = true;\n        scheduleCallback(NormalSchedulerPriority, () => {\n          flushPassiveEffects();\n          return null;\n        });\n      }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n```\n\n\n整体可以分为三部分：\n\n- 处理`DOM`节点渲染/删除后的 `autoFocus`、`blur` 逻辑。\n- 调用`getSnapshotBeforeUpdate`生命周期钩子。\n- 调度`useEffect`。\n\n## 调用`getSnapshotBeforeUpdate`\n\n\n`commitBeforeMutationEffectOnFiber`是`commitBeforeMutationLifeCycles`的别名。 在该方法内会调用`getSnapshotBeforeUpdate`。\n\n\n> 你可以在[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberCommitWork.old.js#L222)看到这段逻辑\n\n\n从`React v16`开始，`componentWillXXX`钩子前增加了`UNSAFE_`前缀。 究其原因，是因为`Stack Reconciler`重构为`Fiber Reconciler`后，`render`阶段的任务可能中断/重新开始，对应的组件在`render`阶段的生命周期钩子（即`componentWillXXX`）可能触发多次。 这种行为和`React v15`不一致，所以标记为`UNSAFE_`。\n\n\n> 更详细的解释参照[这里](https://juejin.im/post/6847902224287285255#comment)\n\n\n为此，`React`提供了替代的生命周期钩子`getSnapshotBeforeUpdate`。 我们可以看见，`getSnapshotBeforeUpdate`是在`commit`阶段内的`before mutation`阶段调用的，由于`commit`阶段是同步的，所以不会遇到多次调用的问题。\n\n\n## 调度`useEffect`\n\n\n在这几行代码内，`scheduleCallback`方法由`Scheduler`模块提供，用于以某个优先级异步调度一个回调函数。\n\n\n```typescript\n// 调度useEffect\nif ((effectTag & Passive) !== NoEffect) {\n  if (!rootDoesHavePassiveEffects) {\n    rootDoesHavePassiveEffects = true;\n    scheduleCallback(NormalSchedulerPriority, () => {\n      // 触发useEffect\n      flushPassiveEffects();\n      return null;\n    });\n  }\n}\n```\n\n\n在此处，被异步调度的回调函数就是触发`useEffect`的方法`flushPassiveEffects`。 我们接下来讨论`useEffect`如何被异步调度，以及为什么要异步（而不是同步）调度。\n\n\n### 如何异步调度\n\n\n在`flushPassiveEffects`方法内部会从全局变量`rootWithPendingPassiveEffects`获取`effectList`。 关于`flushPassiveEffects`的具体讲解参照 useEffect 与 useLayoutEffect 一节 `effectList`中保存了需要执行副作用的`Fiber`节点。其中副作用包括：\n\n- 插入`DOM`节点（`Placement`）\n- 更新`DOM`节点（`Update`）\n- 删除`DOM`节点（`Deletion`）\n\n除此外，当一个`FunctionComponent`含有`useEffect`或`useLayoutEffect`，他对应的`Fiber`节点也会被赋值`effectTag`。\n\n\n> 你可以从[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactHookEffectTags.js)看到hook相关的`effectTag`\n\n\n在`flushPassiveEffects`方法内部会遍历`rootWithPendingPassiveEffects`（即`effectList`）执行`effect`回调函数。 如果在此时直接执行，`rootWithPendingPassiveEffects === null`。 `layout`之后的代码片段中会根据`rootDoesHavePassiveEffects === true?`决定是否赋值`rootWithPendingPassiveEffects`。\n\n\n```typescript\nconst rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\nif (rootDoesHavePassiveEffects) {\n  rootDoesHavePassiveEffects = false;\n  rootWithPendingPassiveEffects = root;\n  pendingPassiveEffectsLanes = lanes;\n  pendingPassiveEffectsRenderPriority = renderPriorityLevel;\n}\n```\n\n\n所以整个`useEffect`异步调用分为三步：\n\n1. `before mutation`阶段在`scheduleCallback`中调度`flushPassiveEffects`\n2. `layout`阶段之后将`effectList`赋值给`rootWithPendingPassiveEffects`\n3. `scheduleCallback`触发`flushPassiveEffects`，`flushPassiveEffects`内部遍历`rootWithPendingPassiveEffects`\n\n### 为什么需要异步调用\n\n\n摘录自`React`文档[effect 的执行时机](https://zh-hans.reactjs.org/docs/hooks-reference.html#timing-of-effects)：\n\n\n> 与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。\n\n\n可见，`useEffect`异步执行的原因主要是防止同步执行时阻塞浏览器渲染。\n\n\n# mutation 阶段\n\n\n类似`before mutation`阶段，`mutation`阶段也是遍历`effectList`，执行函数。这里执行的是`commitMutationEffects`。\n\n\n```typescript\nnextEffect = firstEffect;\ndo {\n  try {\n    commitMutationEffects(root, renderPriorityLevel);\n  } catch (error) {\n    invariant(nextEffect !== null, \"Should be working on an effect.\");\n    captureCommitPhaseError(nextEffect, error);\n    nextEffect = nextEffect.nextEffect;\n  }\n} while (nextEffect !== null);\n```\n\n\n## commitMutationEffects\n\n\n```typescript\nfunction commitMutationEffects(\n  root: FiberRoot,\n  renderPriorityLevel: ReactPriorityLevel\n) {\n  // 遍历effectList\n  while (nextEffect !== null) {\n    setCurrentDebugFiberInDEV(nextEffect);\n\n    const flags = nextEffect.flags;\n\n    // 是否需要重制文本节点\n    if (flags & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n    // 是否有ref的更新\n    if (flags & Ref) {\n      const current = nextEffect.alternate;\n      if (current !== null) {\n        commitDetachRef(current);\n      }\n      if (enableScopeAPI) {\n        // TODO: This is a temporary solution that allowed us to transition away\n        // from React Flare on www.\n        if (nextEffect.tag === ScopeComponent) {\n          commitAttachRef(nextEffect);\n        }\n      }\n    }\n\n    // Placement：插入dom\n    // Update：更新属性\n    // Deletion：删除dom\n    // Hydrating：SSR相关\n    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);\n    switch (primaryFlags) {\n      case Placement: {\n        commitPlacement(nextEffect);\n        nextEffect.flags &= ~Placement;\n        break;\n      }\n      case PlacementAndUpdate: {\n        // Placement\n        commitPlacement(nextEffect);\n        nextEffect.flags &= ~Placement;\n\n        // Update\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Hydrating: {\n        nextEffect.flags &= ~Hydrating;\n        break;\n      }\n      case HydratingAndUpdate: {\n        nextEffect.flags &= ~Hydrating;\n\n        // Update\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Update: {\n        const current = nextEffect.alternate;\n        commitWork(current, nextEffect);\n        break;\n      }\n      case Deletion: {\n        commitDeletion(root, nextEffect, renderPriorityLevel);\n        break;\n      }\n    }\n\n    resetCurrentDebugFiberInDEV();\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n```\n\n\n`commitMutationEffects`会遍历`effectList`，对每个`Fiber`节点执行如下三个操作：\n\n1. 根据`ContentReset effectTag`重置文字节点\n2. 更新`ref`\n3. 根据`effectTag`分别处理，其中`effectTag`包括(`Placement` | `Update` | `Deletion` | `Hydrating`)\n\n## Placement effect\n\n\n当`Fiber`节点含有`Placement effectTag`，意味着该`Fiber`节点对应的`DOM`节点需要插入到页面中。 调用的方法为`commitPlacement`。\n\n\n```typescript\nfunction commitPlacement(finishedWork: Fiber): void {\n  // 是否支持Mutation，dom环境是支持的\n  if (!supportsMutation) {\n    return;\n  }\n\n  const parentFiber = getHostParentFiber(finishedWork);\n\n  let parent;\n  let isContainer;\n  const parentStateNode = parentFiber.stateNode;\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentStateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    case FundamentalComponent:\n      if (enableFundamentalAPI) {\n        parent = parentStateNode.instance;\n        isContainer = false;\n      }\n    // eslint-disable-next-line-no-fallthrough\n    default:\n      invariant(\n        false,\n        \"Invalid host parent fiber. This error is likely caused by a bug \" +\n          \"in React. Please file an issue.\"\n      );\n  }\n  if (parentFiber.flags & ContentReset) {\n    resetTextContent(parent);\n    parentFiber.flags &= ~ContentReset;\n  }\n  // 找到Host类型的兄弟节点\n  // 插入有两种方式：1。找到兄弟节点，执行insertBefore插入节点\n  // 2.找到父节点，执行AppendChild插入节点\n  const before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need to recurse down its\n  // children to find all the terminal nodes.\n  if (isContainer) {\n    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n  } else {\n    insertOrAppendPlacementNode(finishedWork, before, parent);\n  }\n}\n```\n\n\n该方法所做的工作分为三步：\n\n1. 获取父级`DOM`节点。其中`finishedWork`为传入的`Fiber`节点。\n\n```typescript\nconst parentFiber = getHostParentFiber(finishedWork);\n// 父级DOM节点\nconst parentStateNode = parentFiber.stateNode;\n```\n\n1. 获取`Fiber`节点的`DOM`兄弟节点\n\n```typescript\nconst before = getHostSibling(finishedWork);\n```\n\n1. 根据`DOM`兄弟节点是否存在决定调用`parentNode.insertBefore`或`parentNode.appendChild`执行`DOM`插入操作。\n\n```typescript\n// parentStateNode是否是rootFiber\nif (isContainer) {\n  insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n} else {\n  insertOrAppendPlacementNode(finishedWork, before, parent);\n}\n```\n\n\n值得注意的是，`getHostSibling`（获取兄弟`DOM`节点）的执行很耗时，当在同一个父`Fiber`节点下依次执行多个插入操作，`getHostSibling`算法的复杂度为指数级。 这是由于`Fiber`节点不只包括`HostComponent`，所以`Fiber`树和渲染的`DOM`树节点并不是一一对应的。要从`Fiber`节点找到`DOM`节点很可能跨层级遍历。 考虑如下例子：\n\n\n```typescript\nfunction Item() {\n  return <li><li>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <Item/>\n    </div>\n  )\n}\n\nReactDOM.render(<App/>, document.getElementById('root'));\n```\n\n\n对应的`Fiber`树和`DOM`树结构为：\n\n\n```text\n// Fiber树\nchild      child      child       child\nrootFiber -----> App -----> div -----> Item -----> li\n\n// DOM树\n#root ---> div ---> li\n```\n\n\n当在`div`的子节点`Item`前插入一个新节点`p`，即`App`变为：\n\n\n```typescript\nfunction App() {\n  return (\n    <div>\n      <p></p>\n      <Item />\n    </div>\n  );\n}\n```\n\n\n对应的`Fiber`树和`DOM`树结构为：\n\n\n```text\n// Fiber树\n          child      child      child\nrootFiber -----> App -----> div -----> p\n                                       | sibling       child\n                                       | -------> Item -----> li\n// DOM树\n#root ---> div ---> p\n             |\n               ---> li\n```\n\n\n此时`DOM`节点 `p`的兄弟节点为`li`，而`Fiber`节点 `p`对应的兄弟`DOM`节点为：\n\n\n```text\nfiberP.sibling.child\n```\n\n\n即`fiber p`的兄弟`fiber Item`的子`fiber li`\n\n\n## Update effect\n\n\n当`Fiber`节点含有`Update effectTag`，意味着该`Fiber`节点需要更新。调用的方法为`commitWork`，他会根据`Fiber.tag`分别处理。\n\n\n```typescript\nfunction commitWork(current: Fiber | null, finishedWork: Fiber): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n    case Block: {\n      // 这些都是和functionComponent相关的\n      if (\n        enableProfilerTimer &&\n        enableProfilerCommitHooks &&\n        finishedWork.mode & ProfileMode\n      ) {\n        try {\n          startLayoutEffectTimer();\n          // useLayout的销毁函数\n          commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork);\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        commitHookEffectListUnmount(HookLayout | HookHasEffect, finishedWork);\n      }\n      return;\n    }\n    case ClassComponent: {\n      return;\n    }\n    // dom节点相关\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n      if (instance != null) {\n        // Commit the work prepared earlier.\n        const newProps = finishedWork.memoizedProps;\n        const oldProps = current !== null ? current.memoizedProps : newProps;\n        const type = finishedWork.type;\n        const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);\n        finishedWork.updateQueue = null;\n        if (updatePayload !== null) {\n          // 更新dom的属性\n          commitUpdate(\n            instance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            finishedWork,\n          );\n        }\n      }\n      return;\n    }\n    case HostText: {\n      const textInstance: TextInstance = finishedWork.stateNode;\n      const newText: string = finishedWork.memoizedProps;\n      const oldText: string =\n        current !== null ? current.memoizedProps : newText;\n      commitTextUpdate(textInstance, oldText, newText);\n      return;\n    }\n    case HostRoot: {\n      if (supportsHydration) {\n        const root: FiberRoot = finishedWork.stateNode;\n        if (root.hydrate) {\n          // We've just hydrated. No need to hydrate again.\n          root.hydrate = false;\n          commitHydratedContainer(root.containerInfo);\n        }\n      }\n      return;\n    }\n    // ...\n  }\n}\n```\n\n\n这里我们主要关注`FunctionComponent`和`HostComponent`。\n\n\n### FunctionComponent mutation\n\n\n当`fiber.tag`为`FunctionComponent`，会调用`commitHookEffectListUnmount`。该方法会遍历`effectList`，执行所有`useLayoutEffect hook`的销毁函数。\n\n\n```typescript\nfunction commitHookEffectListUnmount(tag: number, finishedWork: Fiber) {\n  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & tag) === tag) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n        if (destroy !== undefined) {\n          destroy();\n        }\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n```\n\n\n### HostComponent mutation\n\n\n当`fiber.tag`为`HostComponent`，会调用`commitUpdate`。\n\n\n```typescript\nexport function commitUpdate(\n  domElement: Instance,\n  updatePayload: Array<mixed>,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  internalInstanceHandle: Object\n): void {\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps);\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n}\n```\n\n\n最终会在`updateProperties`中的`updateDOMProperties`中将`render`阶段 `completeWork`中为`Fiber`节点赋值的`updateQueue`对应的内容渲染在页面上。\n\n\n```typescript\nfunction updateDOMProperties(\n  domElement: Element,\n  updatePayload: Array<any>,\n  wasCustomComponentTag: boolean,\n  isCustomComponentTag: boolean\n): void {\n  // TODO: Handle wasCustomComponentTag\n  for (let i = 0; i < updatePayload.length; i += 2) {\n    const propKey = updatePayload[i];\n    const propValue = updatePayload[i + 1];\n    // 处理 style\n    if (propKey === STYLE) {\n      setValueForStyles(domElement, propValue);\n      // 处理 DANGEROUSLY_SET_INNER_HTML\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      setInnerHTML(domElement, propValue);\n      // 处理 children\n    } else if (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n      // 处理剩余 props\n    } else {\n      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n    }\n  }\n}\n```\n\n\n## Deletion effect\n\n\n当`Fiber`节点含有`Deletion effectTag`，意味着该`Fiber`节点对应的`DOM`节点需要从页面中删除。调用的方法为`commitDeletion`。\n\n\n> 你可以在[这里](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1421)看到commitDeletion源码\n\n\n这里主要关注`unmountHostComponents`中的`commitNestedUnmounts`中的`commitUnmount`方法\n\n\n```typescript\nfunction commitUnmount(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  renderPriorityLevel: ReactPriorityLevel,\n): void {\n  onCommitUnmount(current);\n\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n    case Block: {\n      const updateQueue: FunctionComponentUpdateQueue | null = (current.updateQueue: any);\n      if (updateQueue !== null) {\n        const lastEffect = updateQueue.lastEffect;\n        if (lastEffect !== null) {\n          const firstEffect = lastEffect.next;\n\n          let effect = firstEffect;\n          do {\n            const {destroy, tag} = effect;\n            if (destroy !== undefined) {\n              if ((tag & HookPassive) !== NoHookEffect) {\n                // 当functionComponent被销毁时，useEffect的销毁函数也会被执行\n                enqueuePendingPassiveHookEffectUnmount(current, effect);\n              } else {\n                if (\n                  enableProfilerTimer &&\n                  enableProfilerCommitHooks &&\n                  current.mode & ProfileMode\n                ) {\n                  startLayoutEffectTimer();\n                  safelyCallDestroy(current, destroy);\n                  recordLayoutEffectDuration(current);\n                } else {\n                  safelyCallDestroy(current, destroy);\n                }\n              }\n            }\n            effect = effect.next;\n          } while (effect !== firstEffect);\n        }\n      }\n      return;\n    }\n    case ClassComponent: {\n      safelyDetachRef(current);\n      const instance = current.stateNode;\n      if (typeof instance.componentWillUnmount === 'function') {\n        // 会执行componentWillUnmount钩子函数\n        safelyCallComponentWillUnmount(current, instance);\n      }\n      return;\n    }\n    case HostComponent: {\n      // 解绑ref属性\n      safelyDetachRef(current);\n      return;\n    }\n    // ...\n  }\n}\n```\n\n\n该方法会执行如下操作：\n\n1. 递归调用`Fiber`节点及其子孙`Fiber`节点中`fiber.tag`为`ClassComponent`的`componentWillUnmount`生命周期钩子，从页面移除`Fiber`节点对应`DOM`节点\n2. 解绑`ref`\n3. 调度`useEffect`的销毁函数\n\n# layout 阶段\n\n\n该阶段之所以称为`layout`，因为该阶段的代码都是在`DOM`渲染完成（`mutation`阶段完成）后执行的。 该阶段触发的生命周期钩子和`hook`可以直接访问到已经改变后的`DOM`，即该阶段是可以参与`DOM layout`的阶段。 与前两个阶段类似，`layout`阶段会遍历`effectList`，依次执行`commitLayoutEffects`。该方法的主要工作为“根据`effectTag`调用不同的处理函数处理`Fiber`并更新`ref`。 具体执行的函数是`commitLayoutEffects`。\n\n\n```typescript\n// commit阶段完成后，currentFiber就会指向已经渲染好的fiber\nroot.current = finishedWork;\nnextEffect = firstEffect;\ndo {\n  try {\n    commitLayoutEffects(root, lanes);\n  } catch (error) {\n    invariant(nextEffect !== null, \"Should be working on an effect.\");\n    captureCommitPhaseError(nextEffect, error);\n    nextEffect = nextEffect.nextEffect;\n  }\n} while (nextEffect !== null);\n\nnextEffect = null;\n```\n\n\n## commitLayoutEffects\n\n\n```typescript\nfunction commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {\n  while (nextEffect !== null) {\n    const effectTag = nextEffect.effectTag;\n\n    // 调用生命周期钩子和hook\n    if (effectTag & (Update | Callback)) {\n      const current = nextEffect.alternate;\n      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);\n    }\n\n    // 赋值ref\n    if (effectTag & Ref) {\n      commitAttachRef(nextEffect);\n    }\n\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n```\n\n\n`commitLayoutEffects`一共做了两件事：\n\n1. `commitLayoutEffectOnFiber`（调用生命周期钩子和`hook`相关操作）\n2. `commitAttachRef`（赋值 `ref`）\n\n## commitLayoutEffectOnFiber\n\n\n`commitLayoutEffectOnFiber(commitLifeCycles)`方法会根据`fiber.tag`对不同类型的节点分别处理。\n\n\n```typescript\nfunction commitLifeCycles(\n  finishedRoot: FiberRoot,\n  current: Fiber | null,\n  finishedWork: Fiber,\n  committedLanes: Lanes,\n): void {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n    case Block: {\n      if (\n        enableProfilerTimer &&\n        enableProfilerCommitHooks &&\n        finishedWork.mode & ProfileMode\n      ) {\n        try {\n          startLayoutEffectTimer();\n          commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n      }\n\n      schedulePassiveEffects(finishedWork);\n      return;\n    }\n    case ClassComponent: {\n      const instance = finishedWork.stateNode;\n      if (finishedWork.flags & Update) {\n        if (current === null) {\n          if (\n            enableProfilerTimer &&\n            enableProfilerCommitHooks &&\n            finishedWork.mode & ProfileMode\n          ) {\n            try {\n              startLayoutEffectTimer();\n              instance.componentDidMount();\n            } finally {\n              recordLayoutEffectDuration(finishedWork);\n            }\n          } else {\n            instance.componentDidMount();\n          }\n        } else {\n          const prevProps =\n            finishedWork.elementType === finishedWork.type\n              ? current.memoizedProps\n              : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n          const prevState = current.memoizedState;\n          if (\n            enableProfilerTimer &&\n            enableProfilerCommitHooks &&\n            finishedWork.mode & ProfileMode\n          ) {\n            try {\n              startLayoutEffectTimer();\n              instance.componentDidUpdate(\n                prevProps,\n                prevState,\n                instance.__reactInternalSnapshotBeforeUpdate,\n              );\n            } finally {\n              recordLayoutEffectDuration(finishedWork);\n            }\n          } else {\n            instance.componentDidUpdate(\n              prevProps,\n              prevState,\n              instance.__reactInternalSnapshotBeforeUpdate,\n            );\n          }\n        }\n      }\n\n      const updateQueue: UpdateQueue<\n        *,\n      > | null = (finishedWork.updateQueue: any);\n      if (updateQueue !== null) {\n        commitUpdateQueue(finishedWork, updateQueue, instance);\n      }\n      return;\n    }\n    case HostRoot: {\n      // TODO: I think this is now always non-null by the time it reaches the\n      // commit phase. Consider removing the type check.\n      const updateQueue: UpdateQueue<\n        *,\n      > | null = (finishedWork.updateQueue: any);\n      if (updateQueue !== null) {\n        let instance = null;\n        if (finishedWork.child !== null) {\n          switch (finishedWork.child.tag) {\n            case HostComponent:\n              instance = getPublicInstance(finishedWork.child.stateNode);\n              break;\n            case ClassComponent:\n              instance = finishedWork.child.stateNode;\n              break;\n          }\n        }\n        commitUpdateQueue(finishedWork, updateQueue, instance);\n      }\n      return;\n    }\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n\n      if (current === null && finishedWork.flags & Update) {\n        const type = finishedWork.type;\n        const props = finishedWork.memoizedProps;\n        commitMount(instance, type, props, finishedWork);\n      }\n\n      return;\n    }\n    // ...\n  }\n}\n```\n\n- 对于`FunctionComponent`及相关类型，他会调用`useLayoutEffect hook`的回调函数，调度`useEffect`的销毁与回调函数 > 相关类型指特殊处理后的`FunctionComponent`，比如`ForwardRef`、`React.memo`包裹的`FunctionComponent`\n\n```typescript\nswitch (finishedWork.tag) {\n    // 以下都是FunctionComponent及相关类型\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n    case Block: {\n      // 执行useLayoutEffect的回调函数\n      commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n      // 调度useEffect的销毁函数与回调函数\n      schedulePassiveEffects(finishedWork);\n      return;\n    }\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FoDDpT2emLK3wR4FbtQ_6VWrT0HH.png)\n\n\n由于\n\n\n```text\nmutation\n```\n\n\n阶段会执行\n\n\n```text\nuseLayoutEffect hook\n```\n\n\n的销毁函数。 结合这里我们可以发现，\n\n\n```text\nuseLayoutEffect hook\n```\n\n\n从上一次更新的销毁函数调用到本次更新的回调函数调用是同步执行的。 而\n\n\n```text\nuseEffect\n```\n\n\n则需要先调度，在\n\n\n```text\nLayout\n```\n\n\n阶段完成后再异步执行。 这就是\n\n\n```text\nuseLayoutEffect\n```\n\n\n与\n\n\n```text\nuseEffect\n```\n\n\n的区别。\n\n- 对于`ClassComponent`，他会通过`current === null?`区分是`mount`还是`update`，调用[componentDidMount](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L538)或[componentDidUpdate](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L592)。\n\n触发状态更新的`this.setState`如果赋值了第二个参数回调函数，也会在此时调用。\n\n\n## commitAttachRef\n\n\n> commitLayoutEffects会做的第二件事是commitAttachRef，获取DOM实例，更新ref。\n\n\n```typescript\nfunction commitAttachRef(finishedWork: Fiber) {\n  const ref = finishedWork.ref;\n  if (ref !== null) {\n    // 获取DOM实例\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\n      instanceToUse = instance;\n    }\n    if (typeof ref === \"function\") {\n      // 如果ref是函数形式，调用回调函数\n      ref(instanceToUse);\n    } else {\n      // 如果ref是ref实例形式，赋值ref.current\n      ref.current = instanceToUse;\n    }\n  }\n}\n```\n\n\n## current Fiber 树切换\n\n\n至此，整个 layout 阶段就结束了。 前面也讲过，在 layout 阶段开始之前，有这么一段代码：\n\n\n```typescript\nroot.current = finishedWork;\n```\n\n\n由于在双缓存机制，`workInProgress Fiber`树在`commit`阶段完成渲染后会变为`current Fiber`树。这行代码的作用就是切换`fiberRootNode`指向的`current Fiber`树。 那么这行代码为什么在这里呢？（在`mutation`阶段结束后，`layout`阶段开始前。） 那是因为`componentWillUnmount`会在`mutation`阶段执行。此时`current Fiber`树还指向前一次更新的`Fiber`树，在生命周期钩子内获取的`DOM`还是更新前的。 而`componentDidMount`和`componentDidUpdate`会在 layout 阶段执行。此时`current Fiber`树需要指向更新后的`Fiber`树，在生命周期钩子内获取的`DOM`就是更新后的。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-02-19",
        "type": "Post",
        "slug": "react-commit",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第四章 React架构-commit阶段",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "dcac3fa7-a41d-42ed-837b-79311b3e6e3c",
        "updated": "2023-08-26 15:26:00"
      },
      "body": "",
      "realName": "第四章 React架构-commit阶段",
      "relativePath": "/第四章 React架构-commit阶段.md"
    },
    {
      "id": "0b7ef73a-c23e-4019-8139-a87b987968f3",
      "doc_id": "0b7ef73a-c23e-4019-8139-a87b987968f3",
      "title": "0b7ef73a-c23e-4019-8139-a87b987968f3",
      "updated": 1693064220000,
      "body_original": "\n1 - 「学习 / 感悟 🥕」\n\n\n`RxJs`用起来还挺爽，特别是用来处理流式过程堪比 `Loadsh`在`Js`中的使用体验。\n\n\n以我目前的使用场景，RxJs 非常适合用来解决类似队列的问题。\n\n\n<details>\n  <summary>场景一：批量任务分组处理</summary>\n\n\n由于第三方接口的限流和并发，导致一次性只能同时请求N个请求，等这一批请求结束再发起下一批请求才不太会报错。\n\n\n在以往的编程习惯中，我们需要对批量任务进行分组然后线性执行批量任务分组，代码示例如下：\n\n\n```typescript\n/**\n * 对批量任务进行分组\n *\n * @param {Array<() => Promise<any>>} jobs\n * @param {number} [concurrent_count]\n * @returns\n */\nexport const chunkJobs = (jobs: Array<() => Promise<any>>, concurrent_count?: number) => {\n  const concurrentCount = concurrent_count || 6;\n  return jobs.reduce(\n    (queues, c, i) => {\n      if (i % concurrentCount > 0) {\n        queues[queues.length - 1].push(c);\n        return queues;\n      }\n\n      queues.push([c]);\n      return queues;\n    },\n    [[]] as Array<Array<() => Promise<any>>>,\n  );\n};\n\n/**\n * 线性执行批量任务分组\n *\n * @param {Array<Array<() => Promise<any>>>} jobs\n * @param callbackFunc\n * @returns\n */\nexport const runSerialJobsQueue = async (\n  jobs: Array<Array<() => Promise<any>>>\n) => {\n  let p = 0;\n  const res: Array<any> = [];\n  while (p < jobs.length) {\n    const part_res = await Promise.all(jobs[p].map((fn) => fn().catch(() => false)));\n    res.push(...part_res);\n    ++p;\n  }\n  return res;\n};\n```\n\n\n以上代码有几个注意点 ⚠️\n\n- 由于需要批量执行分组任务，这里使用的是`Prmosie.all`。但是由于不能中断其他分组的任务，所以当其中的一个分组任务有报错，需要手动进行 `catch` 住。\n- 我们很难得到每一个任务的执行结果，并对其进行结果处理\n- chunkJobs 在使用上需要提前准备好 Promise 数组\n- 代码的易读性较差\n\n如果用RxJs就看起来简短并且易读性还不错，代码示例如下：\n\n\n```typescript\n// 批量执行\nasync function requestAll(reqs: any[], request: any, callback: (params: any, res: any) => void) {\n\tconst promises = reqs.map(param =>\n\t\trequest(param)\n\t\t\t.then((res: any) => {\n\t\t\t\tcallback(param, res)\n\t\t\t\treturn res\n\t\t\t})\n\t\t\t.catch((err: any) => {\n\t\t\t\tcallback(param, { error: err })\n\t\t\t}),\n\t)\n\treturn await Promise.all(promises)\n}\n\n// 分组\nexport const chunkJobs = (list: any[], request: any, callback: (params: any, res: any) => void, limit = 5) => {\n\treturn Rx.from(list).pipe(\n\t\tRxOp.bufferCount(limit), // 将 Observable 拆分为 指定数量的组\n\t\tRxOp.concatMap(reqs => Rx.from(requestAll(reqs, request, callback))), // 批量执行请求\n\t).toPromise()\n}\n```\n\n- `RxOp.bufferCount` 可以非常方便的将批量任务进行分组\n- `RxOp.concatMap` 可以将每组请求参数传递给 requestAll 函数进行批量执行\n- 我这里写了一个自定义的callback方法，主要是想在代码执行过程中对每一个请求的结果进行收集和处理\n- 当然为了不让批量任务报错影响其他分组的执行，这里进行了 `catch`\n- 用户只需要把请求参数数组和请求方法传入，就能很方便的执行分组任务\n\n当然上述代码还是有一定的优化空间，比如：\n\n- 错误收集和处理可以尝试用`RxOp.catchError` 操作符进行处理\n\n\n  </details>\n\n\n<details>\n  <summary>场景二：错误日志的收集</summary>\n\n\n在利用Node子线程的通信能力中，需要用一个子线程A去跑程序B，然后在子线程A中收集程序B中的所有输出。\n\n\n```typescript\nconst worker = childProcess.spawn(cli, args);\n// 监听控制台日志输出\nworker.stdout.on(\"data\", (message) => {\n  // 构造消息体\n  const logLine: ILogLine = {\n    date: new Date().getTime(),\n    level: LogLevel.INFO,\n    message: message.toString(),\n  };\n  /** 收集10条后上报日志 */\n});\n\n// 监听控制台错误日志输出\nworker.stderr.on(\"data\", (message) => {\n  // 构造消息体\n  const logLine: ILogLine = {\n    date: new Date().getTime(),\n    level: LogLevel.ERROR,\n    message: message.toString(),\n  };\n  /** 上报日志 */\n});\n\n// 构建结束\nworker.on(\"exit\", () => {\n  /** 收集所有日志 */\n});\n```\n\n- 子线程 `worker` 中会有3 个监听器，由于分布在不同的监听器，如果想收集所有日志的话，需要自己构建一个队列\n- 为了减少请求次数，日志会在收集指定条数后才会上报一次，但是由于是在不同的监听器收集，所以所有的单条日志都需要先 `push` 到队列中\n- 队列在满10条之后会取出进行日志的批量上报\n\n这种需求就很流式，非常适合用RxJs去进行流的处理。代码示例如下：\n\n\n```typescript\n// 构建运行进程\nconst worker = childProcess.spawn(cli, args);\n// 监听控制台日志输出\nworker.stdout.on(\"data\", (message) => {\n  console.log(message.toString());\n  // 构造消息体\n  const logLine: ILogLine = {\n    date: new Date().getTime(),\n    level: LogLevel.INFO,\n    message: message.toString(),\n  };\n  /** 收集/上报日志 */\n  this.logClient.pushLog(logLine);\n});\n\n// 监听控制台错误日志输出\nworker.stderr.on(\"data\", (message) => {\n  console.error(message.toString());\n  // 构造消息体\n  const logLine: ILogLine = {\n    date: new Date().getTime(),\n    level: LogLevel.ERROR,\n    message: message.toString(),\n  };\n  /** 收集/上报日志 */\n  this.logClient.pushLog(logLine);\n});\n\n// 构建结束\nworker.on(\"exit\", () => {\n  this.logClient.complete();\n});\n```\n\n\n```typescript\nimport { ILog, ILogLine, ILogReportConfig } from \"../type/log\";\nimport { apis } from \"../api\";\nimport * as rx from \"rxjs\";\nimport * as rxOp from \"rxjs/operators\";\nimport { LogLevel } from \"../const\";\n\n/**\n * 日志上报\n */\nexport class LogReportClient {\n  private readonly _config: ILogReportConfig;\n  private _queue: rx.Subject<ILogLine>;\n  private _fileBoxClient: FileBoxClient;\n  private _logs: ILogLine[] = [];\n\n  public constructor(config: ILogReportConfig) {\n    this._config = config;\n    this._queue = new rx.Subject<ILogLine>();\n    this._initSubscribe();\n  }\n\n  /**\n   * 初始化订阅器处理\n   * @private\n   */\n  private _initSubscribe(): void {\n    this._queue\n      .pipe(\n        rxOp.bufferCount(this._config.limit),\n        rxOp.tap(async (value) => {\n\t\t\t\t\tthis._logs.push(...value);\n          // 上报日志\n          await this._report(value);\n        }),\n      )\n      .subscribe({\n        complete: async () => {\n          // 保证最后一次上报是最后发的\n          setTimeout(() => {\n            // 发送isEnd日志\n            const endMessage: ILogLine = {\n              message: \"构建结束\",\n              date: new Date().getTime(),\n              level: LogLevel.INFO,\n            };\n            void this._report([endMessage], true);\n          }, 300);\n\n          // 上报到OSS\n          const buffer = new Buffer(JSON.stringify(this._logs));\n          await this.ossClient.uploadBuildLog(buffer);\n        },\n      });\n  }\n\n  /**\n   * 收集日志\n   * @param log\n   */\n  public pushLog(log: ILogLine): void {\n    this._queue.next(log);\n  }\n\n  /**\n   * 构建结束\n   */\n  public complete(): void {\n    this._queue.complete();\n  }\n\n  /**\n   * 日志上报\n   */\n  private async _report(logs: ILogLine[], isEnd?: boolean): Promise<void> {\n    const content: ILog = {\n      logs: logs,\n      isEnd: !!isEnd,\n    };\n    return apis.log\n      .report(content)\n      .catch((e) => {\n        console.error(\"日志推送失败\", e);\n      });\n  }\n}\n```\n\n- 用 `next` 方法 进行日志的 `push`\n- `rxOp.bufferCount` 用来堵塞流程，会在日志达到指定条数后才执行后续流程\n- 再次通过 `rxOp.tap` 拿到分组日志进行收集和上报\n- 日志收集结束后，发送结束日志并把收集到的所有日志上传到阿里云\n\n`Rxjs` 帮我们维护了个队列并进行了分组，核心代码逻辑非常清晰明了！\n\n\n\n  </details>\n\n\n总结：目前我对 `RxJs` 的使用还在初级阶段，一般有什么流式调用，我都会先问下 Notion AI 怎么写。目前还没了解完主要的 `RxJs` 方法，相信在熟悉了RxJs之后，我的代码风格和代码逻辑将会更上一层楼！\n\n\n2 - 「轻松一刻 🎮」\n\n\n今天下班和同事玩了一把【拉斯维加斯】桌游，赌狗上线爽翻天，赢不赢没关系，恶心队友才是正道的光哈哈哈哈。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-12T16:14:00.000Z",
        "date": "2023-04-12",
        "type": "Post",
        "slug": "day-3",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "RxJs 针不错～",
        "更新时间": "2023-08-26T15:37:00.000Z",
        "title": "Seven的成长笔记【第3篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "0b7ef73a-c23e-4019-8139-a87b987968f3",
        "updated": "2023-08-26 15:37:00"
      },
      "body": "",
      "realName": "Seven的成长笔记【第3篇】",
      "relativePath": "/Seven的成长笔记【第3篇】.md"
    },
    {
      "id": "d1b83320-1450-4412-a436-9f1e21689cf6",
      "doc_id": "d1b83320-1450-4412-a436-9f1e21689cf6",
      "title": "d1b83320-1450-4412-a436-9f1e21689cf6",
      "updated": 1693064280000,
      "body_original": "\n1 - 「学习/感悟 🥕」\n\n\n今天把`Elog v0.4.0`正式版本发布了，基本达到了我能拿出去推广的地步。下一步就是让更多的使用者参与进来，这样才能发现更多新的需求的`bugs`，也算是一个新的起点吧。\n\n\n同事推荐我去V2EX上推广我的开源项目，然而我今天注册后发现这个网站看起来挺平淡无奇的，没什么UI，基本上只具有论坛的基本属性，一时间没体验到有什么能留住我的地方。带着这个疑问我翻了翻知乎，褒贬不一吧。\n\n\n其中有一个点让我深思了一下，那就是V2EX足够简单足够粗暴。\n\n\n在各种互联网中文论坛百花齐放的今天，我已经习惯了论坛网站应该是好看且功能齐全的，例如CSDN、博客园、简书、思否、掘金等等。\n\n\n但我忽略了两个点，那就是\n\n- 林子大了什么鸟都有\n- 商业化道路的发展\n\n上面这些论坛的人数众多，反倒滋生了很多乱象\n\n- 大量的复制转载\n- 无意义的话题/引战/水军\n\n再加上商业化的道路上出现的一些\n\n- 推荐算法的热点化/商业化\n- 各种审核机制的介入\n- 各种收费会员\n\n如果我想发一篇文章让更多的人看到，我就得先过一遍审核制度，然后最好是能蹭一些热点或者花钱买热度，才能让我的文章具有更好的曝光。\n\n\n反观V2EX更多的是论坛的基本属性，有点早些年百度贴吧的感觉了。大家都相对比较和平的相处，也没有太多的约束制度，发完文章后大家都能第一时间看到。因为人相对比较少，所以感觉其实除了UI，其他都还OK\n\n\n不过这也是我第一天使用V2EX，具体更多的使用体验等我慢慢解锁吧。\n\n\n2 - 「感恩❤️」\n\n\nElog 群里为数不多的几个使用者，给了我很多反馈和建议，基本上都安排上了，感谢他们。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-15T10:21:00.000Z",
        "date": "2023-04-17",
        "type": "Post",
        "slug": "day-6",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:38:00.000Z",
        "title": "Seven的成长笔记【第6篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "d1b83320-1450-4412-a436-9f1e21689cf6",
        "updated": "2023-08-26 15:38:00"
      },
      "body": "",
      "realName": "Seven的成长笔记【第6篇】",
      "relativePath": "/Seven的成长笔记【第6篇】.md"
    },
    {
      "id": "5a79a465-3cd6-4cd0-be23-29de458313ce",
      "doc_id": "5a79a465-3cd6-4cd0-be23-29de458313ce",
      "title": "5a79a465-3cd6-4cd0-be23-29de458313ce",
      "updated": 1693063560000,
      "body_original": "\n# React 理念：快速响应\n\n\n两大制约\n\n- CPU 的瓶颈：JS 脚本执行和浏览器布局、绘制不能同时执行。\n- IO 的瓶颈：网络延迟客观存在\n\nReact 的解决办法\n\n- 对于 CPU 瓶颈，是需要实现时间切片，而时间切片的关键是：将同步的更新变为可中断的异步更新。\n- 对于 IO 瓶颈，将人机交互研究的结果整合到真实的 UI 中。React 内部实现了 Suspense 功能及配套的 hook——useDeferredValue，同样需要将同步的更新变为可中断的异步更新\n\n# 老的 React15 架构\n\n\nReact15 架构可以分为两层：\n\n- Reconciler（协调器）—— 负责找出变化的组件\n- Renderer（渲染器）—— 负责将变化的组件渲染到页面上\n\n## Reconciler（协调器）\n\n\n在 React 中可以通过 this.setState、this.forceUpdate、ReactDOM.render 等 API 触发更新。 每当有更新发生时，Reconciler 会做如下工作：\n\n1. 调用函数组件、或 class 组件的 render 方法，将返回的 JSX 转化为虚拟 DOM\n2. 将虚拟 DOM 和上次更新时的虚拟 DOM 对比\n3. 通过对比找出本次更新中变化的虚拟 DOM\n4. 通知 Renderer 将变化的虚拟 DOM 渲染到页面上\n\n## Renderer（渲染器）\n\n\n由于 React 支持跨平台，所以不同平台有不同的 Renderer。我们前端最熟悉的是负责在浏览器环境渲染的 Renderer —— ReactDOM。 除此之外，还有：\n\n- ReactNative (opens new window)渲染器，渲染 App 原生组件\n- ReactTest (opens new window)渲染器，渲染出纯 Js 对象用于测试\n- ReactArt (opens new window)渲染器，渲染到 Canvas, SVG 或 VML (IE8)\n\n在每次更新发生时，Renderer 接到 Reconciler 通知，将变化的组件渲染在当前宿主环境。\n\n\n## 缺点\n\n\n在 Reconciler 中，mount 的组件会调用 mountComponent，update 的组件会调用 updateComponent。这两个方法都会递归更新子组件。由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了 16ms，用户交互就会卡顿。基于以上原因，React 团队决定重写架构。\n\n\n# 新的 React16 架构\n\n\nReact16 架构可以分为三层：\n\n- Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入 Reconciler\n- Reconciler（协调器）—— 负责找出变化的组件\n- Renderer（渲染器）—— 负责将变化的组件渲染到页面上\n\n可以看到，相较于 React15，React16 中新增了 Scheduler（调度器）。\n\n\n## Scheduler（调度器）\n\n\n既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。 其实部分浏览器已经实现了这个 API，这就是 requestIdleCallback。但是由于以下因素，React 放弃使用：\n\n- 浏览器兼容性\n- 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换 tab 后，之前 tab 注册的 requestIdleCallback 触发的频率会变得很低\n\n基于以上原因，React 实现了功能更完备的 requestIdleCallbackpolyfill，这就是 Scheduler。除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。\n\n\n## Reconciler（协调器）\n\n\n在 React15 中 Reconciler 是递归处理虚拟 DOM 的。让我们看看 React16 的 Reconciler。\n\n\n```javascript\n/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n```\n\n\n我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用 shouldYield 判断当前是否有剩余时间。 那么 React16 是如何解决中断更新时 DOM 渲染不完全的问题呢？ 在 React16 中，Reconciler 与 Renderer 不再是交替工作。当 Scheduler 将任务交给 Reconciler 后，Reconciler 会为变化的虚拟 DOM 打上代表**增/删/更新**的标记。 整个 Scheduler 与 Reconciler 的工作都在内存中进行。只有当所有组件都完成 Reconciler 的工作，才会统一交给 Renderer。\n\n\n## Renderer（渲染器）\n\n\nRenderer 根据 Reconciler 为虚拟 DOM 打的标记，\n\n\n**同步**\n\n\n执行对应的 DOM 操作。 更新流程：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fhq3GdyJncpUkuH1-oekuXnLv6ip.png)\n\n\n# Fiber 架构\n\n\nFiber 包含三层含义：\n\n1. 作为架构来说，之前 React15 的 Reconciler 采用递归的方式执行，数据保存在递归调用栈中，所以被称为 stack Reconciler。React16 的 Reconciler 基于 Fiber 节点实现，被称为 Fiber Reconciler。\n2. 作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件…）、对应的 DOM 节点等信息。\n3. 作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新…）。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FqMQIsi5n6zJ52TFFdK-0X-e-tsX.png)\n\n\n## Fiber 结构\n\n\n```javascript\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // 作为静态数据结构的属性\n  this.tag = tag;\n  this.key = key;\n  // 在函数式组件被React.memo包裹时,elementType和type不同\n  // 对于函数式组件,type是函数本身,对于class组件,type是class\n  this.elementType = null;\n  this.type = null;\n  // 真实dom节点\n  this.stateNode = null;\n\n  // 用于连接其他Fiber节点形成Fiber树\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  // 作为动态的工作单元的属性\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  // 调度优先级相关\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n\n  // 指向该fiber在另一次更新时对应的fiber\n  this.alternate = null;\n}\n```\n\n\n## 双缓存\n\n\n当我们用 canvas 绘制动画，每一帧绘制前都会调用 ctx.clearRect 清除上一帧的画面。 如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。 为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。 这种在内存中构建并直接替换的技术叫做**双缓存**。\n\n\nReact 使用“双缓存”来完成 Fiber 树的构建与替换——对应着 DOM 树的创建与更新。\n\n\n## 双缓存 Fiber 树\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FiKZ0eyEtPEFixJB4w8bISFMMeed.png)\n\n\n在 React 中最多会同时存在两棵 Fiber 树。当前屏幕上显示内容对应的 Fiber 树称为 current Fiber 树，正在内存中构建的 Fiber 树称为 workInProgress Fiber 树。 current Fiber 树中的 Fiber 节点被称为 current fiber，workInProgress Fiber 树中的 Fiber 节点被称为 workInProgress fiber，他们通过 alternate 属性连接。\n\n\n```javascript\ncurrentFiber.alternate === workInProgressFiber;\nworkInProgressFiber.alternate === currentFiber;\n```\n\n\nReact 应用的根节点通过使 current 指针在不同 Fiber 树的 rootFiber 间切换来完成 current Fiber 树指向的切换。\n\n\n即当 workInProgress Fiber 树构建完成交给 Renderer 渲染在页面上后，应用根节点的 current 指针指向 workInProgress Fiber 树，此时 workInProgress Fiber 树就变为 current Fiber 树。\n\n\n每次状态更新都会产生新的 workInProgress Fiber 树，通过 current 与 workInProgress 的替换，完成 DOM 更新。\n\n\n## Mount 时\n\n\n```javascript\nfunction App() {\n  const [num, add] = useState(0);\n  return (\n    <p onClick={() => add(num + 1)}>{num}</p>\n  )\n}\n\nReactDOM.render(<App/>, document.getElementById('root'));\n```\n\n1. 首次执行 ReactDOM.render 会创建 fiberRootNode（源码中叫 fiberRoot）和 rootFiber。其中 fiberRootNode 是整个应用的根节点，rootFiber 是\n\n\t所在组件树的根节点。\n\n\n之所以要区分 fiberRootNode 与 rootFiber，是因为在应用中我们可以多次调用 ReactDOM.render 渲染不同的组件树，他们会拥有不同的 rootFiber。但是整个应用的根节点只有一个，那就是 fiberRootNode。\n\n\nfiberRootNode 的 current 会指向当前页面上已渲染内容对应 Fiber 树，即 current Fiber 树。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fo6z4lTvcsAJzL6EewXlzWt4EhZ8.png)\n\n\n```javascript\nfiberRootNode.current = rootFiber;\n```\n\n\n由于是首屏渲染，页面中还没有挂载任何 DOM，所以 fiberRootNode.current 指向的 rootFiber 没有任何子 Fiber 节点（即 current Fiber 树为空）。\n\n1. 接下来进入 render 阶段，根据组件返回的 JSX 在内存中依次创建 Fiber 节点并连接在一起构建 Fiber 树，被称为 workInProgress Fiber 树。（下图中右侧为内存中构建的树，左侧为页面显示的树）\n\n在构建 workInProgress Fiber 树时会尝试复用 current Fiber 树中已有的 Fiber 节点内的属性，在首屏渲染时只有 rootFiber 存在对应的 current fiber（即 rootFiber.alternate）。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fkkpy_jFMhTAlAUFDiScPn8qbA4X.png)\n\n1. 图中右侧已构建完的 workInProgress Fiber 树在 commit 阶段渲染到页面。\n\n此时 DOM 更新为右侧树对应的样子。fiberRootNode 的 current 指针指向 workInProgress Fiber 树使其变为 current Fiber 树。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FnfUByoa0rQqp2jhk1wWqMgtFuq1.png)\n\n\n## Update 时\n\n1. 接下来我们点击 p 节点触发状态改变，这会开启一次新的 render 阶段并构建一棵新的 workInProgress Fiber 树。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FlF0VfxFlK7fuFvkoc6IQXGxiXYH.png)\n\n\n和 mount 时一样，workInProgress fiber 的创建可以复用 current Fiber 树对应的节点数据。这个决定是否复用的过程就是 Diff 算法。\n\n1. workInProgress Fiber 树在 render 阶段完成构建后进入 commit 阶段渲染到页面上。渲染完毕后，workInProgress Fiber 树变为 current Fiber 树。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FruNGLRBbr39ui2nZXe96ZHcTnC0.png)\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-12-15",
        "type": "Post",
        "slug": "react",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第一章 React理念",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "5a79a465-3cd6-4cd0-be23-29de458313ce",
        "updated": "2023-08-26 15:26:00"
      },
      "body": "",
      "realName": "第一章 React理念",
      "relativePath": "/第一章 React理念.md"
    },
    {
      "id": "43bfb7df-683e-4e53-a9a9-dfe9ab6e67ba",
      "doc_id": "43bfb7df-683e-4e53-a9a9-dfe9ab6e67ba",
      "title": "43bfb7df-683e-4e53-a9a9-dfe9ab6e67ba",
      "updated": 1693063560000,
      "body_original": "\n# React 目录结构\n\n\n## 顶层目录\n\n\n除去配置文件和隐藏文件夹，根目录的文件夹包括三个：\n\n\n```typescript\n根目录\n├── fixtures        # 包含一些给贡献者准备的小型 React 测试项目\n├── packages        # 包含元数据（比如 package.json）和 React 仓库中所有 package 的源码（子目录 src）\n├── scripts         # 各种工具链的脚本，比如git、jest、eslint等\n```\n\n\n## packages 目录\n\n\n### react 文件夹\n\n\nReact 的核心，包含所有全局 React API，如：\n\n- React.createElement\n- React.Component\n- React.Children\n\n这些 API 是全平台通用的，它不包含 ReactDOM、ReactNative 等平台特定的代码。在 NPM 上作为单独的一个包发布。\n\n\n### scheduler 文件夹\n\n\nScheduler（调度器）的实现。\n\n\n### shared 文件夹\n\n\n源码中其他模块公用的方法和全局变量，比如在 shared/ReactSymbols.js 中保存 React 不同组件类型的定义。\n\n\n```typescript\n// ...\nexport let REACT_ELEMENT_TYPE = 0xeac7;\nexport let REACT_PORTAL_TYPE = 0xeaca;\nexport let REACT_FRAGMENT_TYPE = 0xeacb;\n// ...\n```\n\n\n### Renderer 相关的文件夹\n\n\n包含不同平台的渲染器的实现\n\n\n```typescript\n- react-art\n- react-dom                 # 注意这同时是DOM和SSR（服务端渲染）的入口\n- react-native-renderer\n- react-noop-renderer       # 用于debug fiber（后面会介绍fiber）\n- react-test-renderer\n```\n\n\n### 试验性包的文件夹\n\n\nReact 将自己流程中的一部分抽离出来，形成可以独立使用的包，由于他们是试验性质的，所以不被建议在生产环境使用。包括如下文件夹：\n\n\n```typescript\n- react-server        # 创建自定义SSR流\n- react-client        # 创建自定义的流\n- react-fetch         # 用于数据请求\n- react-interactions  # 用于测试交互相关的内部特性，比如React的事件模型\n- react-reconciler    # Reconciler的实现，你可以用他构建自己的Renderer\n```\n\n\n### 辅助包的文件夹\n\n\nReact 将一些辅助功能形成单独的包。包括如下文件夹：\n\n\n```typescript\n- react-is       # 用于测试组件是否是某类型\n- react-client   # 创建自定义的流\n- react-fetch    # 用于数据请求\n- react-refresh  # “热重载”的React官方实现\n```\n\n\n### react-reconciler 文件夹\n\n\n我们需要重点关注 react-reconciler，虽然他是一个实验性的包，内部的很多功能在正式版本中还未开放。但是他一边对接 Scheduler，一边对接不同平台的 Renderer，构成了整个 React16 的架构体系。\n\n\n# 深入理解 JSX\n\n\n## React.CreateElement\n\n\nJSX 在编译时会被 Babel 编译为 React.createElement 方法，查看源码：\n\n\n```javascript\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  if (config != null) {\n    // 赋值给props\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  // 处理 children，会被赋值给props.children\n  \n  // Resolve default props 处理默认值并赋值\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n```\n\n\n最后，React 会返回一个包含组件数据的 ReactElement 的对象，该对象有一个属性`$$typeof: REACT_ELEMENT_TYPE`来标记他是一个 ReactElement。\n\n\n```javascript\nconst ReactElement = function(type, key, ref, self, source, owner, props) {\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  return element;\n};\n```\n\n\n在 React 中有一个全局的方法`isValidElement`来校验合法的 ReactElement。\n\n\n```javascript\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n```\n\n\n可以发现`$$typeof === REACT_ELEMENT_TYPE`的非 null 对象就是一个合法的 ReactElement。换言之，在 React 中，所有 JSX 在运行时的返回结果（即 React.createElement()的返回值）都是 React Element。\n\n\n## React Component \n\n\n在 React 中，我们常使用 ClassComponent 与 FunctionComponent 构建组件。\n\n\n```javascript\nclass AppClass extends React.Component {\n  render() {\n    return <p>KaSong</p>\n  }\n}\nconsole.log('这是ClassComponent：', AppClass);\nconsole.log('这是Element：', <AppClass/>);\n\n\nfunction AppFunc() {\n  return <p>KaSong</p>;\n}\nconsole.log('这是FunctionComponent：', AppFunc);\nconsole.log('这是Element：', <AppFunc/>);\n```\n\n\nClassComponent 对应的 Element 的 type 字段为 AppClass 自身。FunctionComponent 对应的 Element 的 type 字段为 AppFunc 自身：\n\n\n```javascript\n{\n  $$typeof: Symbol(react.element),\n  key: null,\n  props: {},\n  ref: null,\n  type: ƒ AppFunc(),\n  _owner: null,\n  _store: {validated: false},\n  _self: null,\n  _source: null \n}\n```\n\n\n但是由于 class 组件和 function 组件本质上都是 function， 所以无法通过 instanceof 区分。\n\n\n```javascript\nAppClass instanceof Function === true;\nAppFunc instanceof Function === true;\n```\n\n\nReact 通过 ClassComponent 实例原型上的 isReactComponent 变量判断是否是 ClassComponent。\n\n\n```javascript\nClassComponent.prototype.isReactComponent = {};\n```\n\n\n## JSX 与 Fiber 节点\n\n\n从上面的内容我们可以发现，JSX 是一种描述当前组件内容的数据结构，他不包含组件 schedule、reconcile、render 所需的相关信息。 比如如下信息就不包括在 JSX 中：\n\n- 组件在更新中的优先级\n- 组件的 state\n- 组件被打上的用于 Renderer 的标记\n- 这些内容都包含在 Fiber 节点中。\n\n所以，在组件 mount 时，Reconciler 根据 JSX 描述的组件内容生成组件对应的 Fiber 节点。 在 update 时，Reconciler 将 JSX 与 Fiber 节点保存的数据对比，生成组件对应的 Fiber 节点，并根据对比结果为 Fiber 节点打上标记。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-12-16",
        "type": "Post",
        "slug": "react-jsx",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第二章 React架构-JSX",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "43bfb7df-683e-4e53-a9a9-dfe9ab6e67ba",
        "updated": "2023-08-26 15:26:00"
      },
      "body": "",
      "realName": "第二章 React架构-JSX",
      "relativePath": "/第二章 React架构-JSX.md"
    },
    {
      "id": "423e426b-161e-4b67-9c5c-8f82af9f8feb",
      "doc_id": "423e426b-161e-4b67-9c5c-8f82af9f8feb",
      "title": "423e426b-161e-4b67-9c5c-8f82af9f8feb",
      "updated": 1693063560000,
      "body_original": "\n`Fiber节点`是如何被创建并构建 Fiber 树？\n\n\n`render阶段`开始于`performSyncWorkOnRoot`或`performConcurrentWorkOnRoot`方法的调用。这取决于本次更新是同步更新还是异步更新。\n\n\n```typescript\n/ performSyncWorkOnRoot会调用该方法\nfunction workLoopSync() {\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n// performConcurrentWorkOnRoot会调用该方法\nfunction workLoopConcurrent() {\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n```\n\n\n可以看到，他们唯一的区别是是否调用`shouldYield`。如果当前浏览器帧没有剩余时间，`shouldYield`会中止循环，直到浏览器有空闲时间后再继续遍历。 `workInProgress`代表当前已创建的`workInProgress fiber`。 `performUnitOfWork`方法会创建下一个`Fiber节点`并赋值给`workInProgress`，并将`workInProgress`与已创建的`Fiber节点`连接起来构成`Fiber树`。 `Fiber Reconciler`是从`Stack Reconciler`重构而来，通过遍历的方式实现可中断的递归，所以`performUnitOfWork`的工作可以分为两部分：“递”和“归”。\n\n\n# “递”阶段\n\n\n首先从`rootFiber`开始向下深度优先遍历。为遍历到的每个`Fiber节点`调用[beginWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)方法。 该方法会根据传入的`Fiber节点`创建`子Fiber节点`，并将这两个`Fiber节点`连接起来。 当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。\n\n\n# “归”阶段\n\n\n在“归”阶段会调用[completeWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652)处理`Fiber节点`。 当某个`Fiber节点`执行完`completeWork`，如果其存在`兄弟Fiber节点`（即`fiber.sibling !== null`），会进入其`兄弟Fiber`的“递”阶段。 如果不存在`兄弟Fiber`，会进入`父级Fiber`的“归”阶段。 “递”和“归”阶段会交错执行直到“归”到 rootFiber。至此，render 阶段的工作就结束了。\n\n\n# 举个 🌰\n\n\n```javascript\nfunction App() {\n  return (\n    <div>\n      i am\n      <span>1874</span>\n    </div>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n```\n\n\n对应的`Fiber`树结构：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fr1PqG_iJcm7n6aZtHFfEHK4VuKT.png)\n\n\n```text\nrender阶段\n```\n\n\n会依次执行：\n\n\n```shell\n1. rootFiber beginWork2. App Fiber beginWork3. div Fiber beginWork4. \"i am\" Fiber beginWork5. \"i am\" Fiber completeWork6. span Fiber beginWork7. span Fiber completeWork8. div Fiber completeWork9. App Fiber completeWork10. rootFiber completeWork\n```\n\n\n> 注意 之所以没有 “1874” Fiber 的 beginWork/completeWork，是因为作为一种性能优化手段，针对只有单一文本子节点的Fiber，React会特殊处理。\n\n\n# beginWork\n\n\n## 流程概述\n\n\n可以从[源码这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3075)看到 beginWork 的定义。整个方法大概有 500 行代码。beginWork 的工作是传入当前 Fiber 节点，创建子 Fiber 节点。\n\n\n```typescript\n// 从传参看方法执行\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes\n): Fiber | null {\n  // ...省略函数体\n}\n```\n\n\n其中传参：\n\n- current：当前组件对应的`Fiber节点`在上一次更新时的`Fiber节点`，即`workInProgress.alternate`\n- workInProgress：当前组件对应的`Fiber节点`\n- renderLanes：优先级相关\n\n除`rootFiber`以外， 组件`mount`时，由于是首次渲染，是不存在当前组件对应的`Fiber节点`在上一次更新时的`Fiber节点`，即`mount`时`current === null`。 组件`update`时，由于之前已经`mount`过，所以`current !== null`。 所以我们可以通过`current === null ?`来区分组件是处于`mount`还是`update`。 基于此原因，`beginWork`的工作可以分为两部分：\n\n- `update`时：如果`current`存在，在满足一定条件时可以复用`current`节点，这样就能克隆`current.child`作为`workInProgress.child`，而不需要新建`workInProgress.child`。\n- `mount`时：除`fiberRootNode`以外，`current === null`。会根据`fiber.tag`不同，创建不同类型的`子Fiber节点`\n\n```typescript\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes\n): Fiber | null {\n  // update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）\n  if (current !== null) {\n    // ...省略\n\n    // 复用current\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  } else {\n    didReceiveUpdate = false;\n  }\n\n  // mount时：根据tag不同，创建不同的子Fiber节点\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    // ...省略\n    case LazyComponent:\n    // ...省略\n    case FunctionComponent:\n    // ...省略\n    case ClassComponent:\n    // ...省略\n    case HostRoot:\n    // ...省略\n    case HostComponent:\n    // ...省略\n    case HostText:\n    // ...省略\n    // ...省略其他类型\n  }\n}\n```\n\n\n## update 时\n\n\n可以看到，满足如下情况时`didReceiveUpdate === false`（即可以直接复用前一次更新的`子Fiber`，不需要新建`子Fiber`）\n\n- `oldProps === newProps && workInProgress.type === current.type`，即`props`与`fiber.type`不变\n- `!includesSomeLane(renderLanes, updateLanes)`，即当前`Fiber节点`优先级不够。\n\n## mount 时\n\n\n当不满足优化路径时，就会新建`子Fiber`。根据`fiber.tag`不同，进入不同类型`Fiber`的创建逻辑。\n\n\n> 可以从[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactWorkTags.js)看到tag对应的组件类型\n\n\n```typescript\n// mount时：根据tag不同，创建不同的Fiber节点\nswitch (workInProgress.tag) {\n  case IndeterminateComponent:\n  // ...省略\n  case LazyComponent:\n  // ...省略\n  case FunctionComponent:\n  // ...省略\n  case ClassComponent:\n  // ...省略\n  case HostRoot:\n  // ...省略\n  case HostComponent:\n  // ...省略\n  case HostText:\n  // ...省略\n  // ...省略其他类型\n}\n```\n\n\n对于我们常见的组件类型，如`FunctionComponent/ClassComponent/HostComponent`，最终会进入[reconcileChildren](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L233)方法。\n\n\n## reconcileChildren\n\n\n从该函数名就能看出这是`Reconciler`模块的核心部分。那么他究竟做了什么呢？\n\n- 对于`mount`的组件，他会创建新的`子Fiber节点`\n- 对于`update`的组件，他会将当前组件与该组件在上次更新时对应的`Fiber节点`比较（也就是俗称的`Diff算法`），将比较的结果生成`新Fiber节点`\n\n```typescript\nexport function reconcileChildren(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderLanes: Lanes\n) {\n  if (current === null) {\n    // 对于mount的组件\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes\n    );\n  } else {\n    // 对于update的组件\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderLanes\n    );\n  }\n}\n```\n\n\n从代码可以看出，和`beginWork`一样，他也是通过`current === null ?`区分`mount`与`update`。 不论走哪个逻辑，最终他会生成新的`子Fiber节点`并赋值给`workInProgress.child`，作为本次`beginWork`[返回值](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1158)，并作为下次`performUnitOfWork`执行时`workInProgress`的[传参](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1702)。\n\n\n> 注意 值得一提的是，mountChildFibers与reconcileChildFibers这两个方法的逻辑基本一致。唯一的区别是：reconcileChildFibers会为生成的Fiber节点带上effectTag属性，而mountChildFibers不会。\n\n\n## effectTag\n\n\n我们知道，`render`阶段的工作是在内存中进行，当工作结束后会通知`Renderer`需要执行的`DOM`操作。要执行`DOM`操作的具体类型就保存在`fiber.effectTag`中。\n\n\n> 你可以从[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js)看到`effectTag`对应的`DOM`操作\n\n\n比如：\n\n\n```typescript\n// 通过二进制表示effectTag，可以方便的使用位操作为fiber.effectTag赋值多个effect。\n\n// DOM需要插入到页面中\nexport const Placement = /*                */ 0b00000000000010;\n// DOM需要更新\nexport const Update = /*                   */ 0b00000000000100;\n// DOM需要插入到页面中并更新\nexport const PlacementAndUpdate = /*       */ 0b00000000000110;\n// DOM需要删除\nexport const Deletion = /*                 */ 0b00000000001000;\n```\n\n\n那么，如果要通知`Renderer`将`Fiber节点`对应的`DOM`节点插入页面中，需要满足两个条件：\n\n1. `fiber.stateNode`存在，即`Fiber节点`中保存了对应的`DOM`节点\n2. `(fiber.effectTag & Placement) !== 0`，即`Fiber节点`存在`Placement effectTag`\n\n我们知道，`mount`时，`fiber.stateNode === null`，且在`reconcileChildren`中调用的`mountChildFibers`不会为`Fiber节点`赋值`effectTag`。那么首屏渲染如何完成呢？ 针对第一个问题，`fiber.stateNode`会在`completeWork`中创建。第二个问题的答案十分巧妙：假设`mountChildFibers`也会赋值`effectTag`，那么可以预见`mount`时整棵 Fiber 树所有节点都会有`Placement effectTag`。那么`commit`阶段在执行`DOM`操作时每个节点都会执行一次插入操作，这样大量的`DOM`操作是极低效的。为了解决这个问题，在`mount`时只有`rootFiber`会赋值`Placement effectTag`，在`commit`阶段只会执行一次插入操作。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FuLcsbmdRwcZCodGOlPpjfxxuSdi.png)\n\n\n# completeWork\n\n\n类似`beginWork`，`completeWork`也是针对不同`fiber.tag`调用不同的处理逻辑。\n\n\n```typescript\nfunction completeWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  const newProps = workInProgress.pendingProps;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      return null;\n    case ClassComponent: {\n      // ...省略\n      return null;\n    }\n    case HostRoot: {\n      // ...省略\n      updateHostContainer(workInProgress);\n      return null;\n    }\n    case HostComponent: {\n      // ...省略\n      return null;\n    }\n  // ...省略\n```\n\n\n先重点关注页面渲染所必须的`HostComponent`（即原生`DOM`组件对应的`Fiber节点`）。\n\n\n## 处理 HostComponent\n\n\n和`beginWork`一样，是根据`current === null ?`判断是`mount`还是`update`。 同时针对`HostComponent`，判断`update`时我们还需要考虑`workInProgress.stateNode != null ?`（即该`Fiber节点`是否存在对应的`DOM`节点）。\n\n\n```typescript\ncase HostComponent: {\n  popHostContext(workInProgress);\n  const rootContainerInstance = getRootHostContainer();\n  const type = workInProgress.type;\n\n  if (current !== null && workInProgress.stateNode != null) {\n    // update的情况\n    // ...省略\n  } else {\n    // mount的情况\n    // ...省略\n  }\n  return null;\n}\n```\n\n\n## update 时\n\n\n当`update`时，`Fiber节点`已经存在对应`DOM`节点，所以不需要生成`DOM`节点。需要做的主要是处理`props`，比如：\n\n- `onClick`、`onChange`等回调函数的注册\n- 处理`style prop`\n- 处理`DANGEROUSLY_SET_INNER_HTML prop`\n- 处理`children prop`\n\n去掉一些当前不需要关注的功能（比如`ref`）。可以看到最主要的逻辑是调用`updateHostComponent`方法。\n\n\n```typescript\nif (current !== null && workInProgress.stateNode != null) {\n  // update的情况\n  updateHostComponent(\n    current,\n    workInProgress,\n    type,\n    newProps,\n    rootContainerInstance\n  );\n}\n```\n\n\n```typescript\nupdateHostComponent = function(\n    current: Fiber,\n    workInProgress: Fiber,\n    type: Type,\n    newProps: Props,\n    rootContainerInstance: Container,\n  ) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    const oldProps = current.memoizedProps;\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    }\n\n    // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n    const instance: Instance = workInProgress.stateNode;\n    const currentHostContext = getHostContext();\n    // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n    const updatePayload = prepareUpdate(\n      instance,\n      type,\n      oldProps,\n      newProps,\n      rootContainerInstance,\n      currentHostContext,\n    );\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = (updatePayload: any);\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n```\n\n\n在`updateHostComponent`内部，被处理完的`props`会被赋值给`workInProgress.updateQueue`，并最终会在`commit`阶段被渲染在页面上。\n\n\n```typescript\nworkInProgress.updateQueue = (updatePayload: any);\n```\n\n\n其中`updatePayload`为数组形式，他的偶数索引的值为变化的`prop key`，奇数索引的值为变化的`prop value`。\n\n\n## mount 时\n\n\n同样，我们省略了不相关的逻辑。可以看到，`mount`时的主要逻辑包括三个：\n\n- 为`Fiber节点`生成对应的`DOM`节点\n- 将`子孙DOM节点`插入刚生成的`DOM`节点中\n- 与`update`逻辑中的`updateHostComponent`类似的处理`props`的过程\n\n```typescript\n// mount的情况\n\n// ...省略服务端渲染相关逻辑\n\nconst currentHostContext = getHostContext();\n// 为fiber创建对应DOM节点\nconst instance = createInstance(\n  type,\n  newProps,\n  rootContainerInstance,\n  currentHostContext,\n  workInProgress\n);\n// 将子孙DOM节点插入刚生成的DOM节点中\nappendAllChildren(instance, workInProgress, false, false);\n// DOM节点赋值给fiber.stateNode\nworkInProgress.stateNode = instance;\n\n// 与update逻辑中的updateHostComponent类似的处理props的过程\nif (\n  finalizeInitialChildren(\n    instance,\n    type,\n    newProps,\n    rootContainerInstance,\n    currentHostContext\n  )\n) {\n  markUpdate(workInProgress);\n}\n```\n\n\n由于`mount`时只会在`rootFiber`存在`Placement effectTag`。那么`commit`阶段是如何通过一次插入`DOM`操作（对应一个`Placement effectTag`）将整棵`DOM`树插入页面的呢？ 原因就在于`completeWork`中的`appendAllChildren`方法。 由于`completeWork`属于“归”阶段调用的函数，每次调用`appendAllChildren`时都会将已生成的子孙`DOM`节点插入当前生成的`DOM`节点下。那么当“归”到`rootFiber`时，我们已经有一个构建好的离屏`DOM`树。\n\n\n## effectList\n\n\n至此`render`阶段的绝大部分工作就完成了。 还有一个问题：作为`DOM`操作的依据，`commit`阶段需要找到所有有`effectTag`的`Fiber`节点并依次执行`effectTag`对应操作。难道需要在`commit`阶段再遍历一次`Fiber树`寻找`effectTag !== null`的`Fiber`节点么？ 这显然是很低效的。 为了解决这个问题，在`completeWork`的上层函数`completeUnitOfWork`中，每个执行完`completeWork`且存在`effectTag`的`Fiber`节点会被保存在一条被称为`effectList`的单向链表中。 `effectList`中第一个`Fiber`节点保存在`fiber.firstEffect`，最后一个元素保存在`fiber.lastEffect`。 类似`appendAllChildren`，在“归”阶段，所有有`effectTag`的`Fiber`节点都会被追加在`effectList`中，最终形成一条以`rootFiber.firstEffect`为起点的单向链表。\n\n\n```typescript\n                       nextEffect         nextEffect\nrootFiber.firstEffect -----------> fiber -----------> fiber\n```\n\n\n这样，在`commit`阶段只需要遍历`effectList`就能执行所有 effect 了。\n\n\n> 你可以在[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1744)看到这段代码逻辑。\n\n\n## 流程结尾\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FqfSwmibF4takmueZ3r0RWASaKS3.png)\n\n\n至此，`render`阶段全部工作完成。在`performSyncWorkOnRoot`函数中`fiberRootNode`被传递给`commitRoot`方法，开启`commit`阶段工作流程。\n\n\n```text\ncommitRoot(root);\n```\n\n\n> 代码见这里。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-02-09",
        "type": "Post",
        "slug": "react-render",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第三章 React架构-render阶段",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "423e426b-161e-4b67-9c5c-8f82af9f8feb",
        "updated": "2023-08-26 15:26:00"
      },
      "body": "",
      "realName": "第三章 React架构-render阶段",
      "relativePath": "/第三章 React架构-render阶段.md"
    },
    {
      "id": "31d9494b-7c68-4d94-a407-7625e31421fb",
      "doc_id": "31d9494b-7c68-4d94-a407-7625e31421fb",
      "title": "31d9494b-7c68-4d94-a407-7625e31421fb",
      "updated": 1693063440000,
      "body_original": "\n# 引言\n\n\nSpring Security 是一个能够为基于 Spring 的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在 Spring 应用上下文中配置的 Bean，充分利用了 Spring IOC（Inversion of Control 控制反转），DI（Dependency Injection 依赖注入）和 AOP（Aspect Oriented Programming 面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。\n\n\n## pom.xml\n\n\n在 spring framework 常规依赖的基础上添加以下依赖：\n\n\n```xml\n<dependency>\n\t<groupId>org.springframework.security</groupId>\n\t<artifactId>spring-security-config</artifactId>\n\t<version>4.1.0.RELEASE</version>\n</dependency>\n<dependency>\n\t<groupId>javax.servlet</groupId>\n\t<artifactId>servlet-api</artifactId>\n\t<version>2.5</version>\n\t<scope>provided</scope>\n</dependency>\n```\n\n\n## web.xml\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns=\"http://java.sun.com/xml/ns/javaee\"\n\txsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee\n                        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n         version=\"2.5\">\n    <!-- security安全框架 -->\n\t<context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:spring-security.xml</param-value>\n\t</context-param>\n\t<listener>\n        <listener-class>\n            org.springframework.web.context.ContextLoaderListener\n        </listener-class>\n\t</listener>\t\n\t<filter>  \n        <filter-name>springSecurityFilterChain</filter-name>\n        <filter-class>\n            org.springframework.web.filter.DelegatingFilterProxy\n        </filter-class>\n\t</filter>  \n\t<filter-mapping>  \n        <filter-name>springSecurityFilterChain</filter-name>  \n        <url-pattern>/*</url-pattern>  \n\t</filter-mapping>\t\n</web-app>\n```\n\n\n## spring-security.xml(静态设置账号密码)\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans:beans xmlns=\"http://www.springframework.org/schema/security\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/security\n    http://www.springframework.org/schema/security/spring-security.xsd\">\n\n    <!-- 以下页面不被拦截 -->\n\t<http pattern=\"/login.html\" security=\"none\"></http>\n\t<!-- 页面拦截规则 -->\n\t<http use-expressions=\"false\">\n        <!-- intercept-url表示需要拦截的 -->\n        <!-- /**表示拦截所有,access中必须以\"ROLE_\"开头,后面的是自定的用户-->\n\t\t<intercept-url pattern=\"/**\" access=\"ROLE_TEST\" />\n        <!-- \n\t\t\tlogin-page：指定登录页面。\n\t\t\tauthentication-failure-url：指定了身份验证失败时跳转到的页面。\n\t\t\tdefault-target-url：指定了成功进行身份验证和授权后默认呈现给用户的页面。\n \t\t-->\n        <form-login login-page=\"/login.html\" default-target-url=\"/index.html\" authentication-failure-url=\"/error.html\"/>\n        <!-- 关闭CSRF,如果不加会出现错误 -->\n        <!-- CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。-->\n\t\t<csrf disabled=\"true\"/>\n        <!-- 如果你在系统中使用了框架页，需要设置框架页的策略为SAMEORIGIN -->\n        <headers>\n\t\t\t<frame-options policy=\"SAMEORIGIN\"/>\n\t\t</headers>\n\t</http>\n\n\t<!-- 认证管理器 -->\n\t<authentication-manager>\n\t\t<authentication-provider>\n\t\t\t<user-service>\n                <!-- 为方便测试,将账号密码固定了 -->\n\t\t\t\t<user name=\"admin\" password=\"123456\" authorities=\"ROLE_TEST\"/>\n\t\t\t</user-service>\t\t\n\t\t</authentication-provider>\t\n\t</authentication-manager>\n</beans:beans>\n```\n\n\n## 动态从数据库中获取账号密码\n\n\n### 创建 UserDetailsServiceImpl.java 并实现 UserDetailsService 接口\n\n\n```java\npackage cn.letttgaco.service;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\n\nimport cn.letttgaco.pojo.LoginUser;\n\npublic class UserDetailServiceImpl implements UserDetailsService {\n\n\tprivate SellerService sellerService;\n\n\tpublic void setSellerService(SellerService sellerService) {\n\t\tthis.sellerService = sellerService;\n\t}\n\n\tpublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\t\tSystem.out.println(\"通过UserDetailServiceImpl\");\n\t\t// 构建角色列表\n\t\tList<GrantedAuthority> grantAuths = new ArrayList<GrantedAuthority>();\n\t\t// 添加角色\n\t\tgrantAuths.add(new SimpleGrantedAuthority(\"ROLE_SELLER\"));\n\t\t//得到用户对象\t\t\n\t\tLoginUser user = userService.login(username);\n\t\tif (user != null) {\n\t\t\t// 返回具有一定角色对象的用户对象\n\t\t\treturn new User(username, user.getPassword(), grantAuths);\n\t\t\treturn null;\n\t\t}else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n```\n\n\n### spring-security.xml\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans:beans xmlns=\"http://www.springframework.org/schema/security\"\n\txmlns:beans=\"http://www.springframework.org/schema/beans\" \n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\thttp://www.springframework.org/schema/security \n\thttp://www.springframework.org/schema/security/spring-security.xsd\n\thttp://code.alibabatech.com/schema/dubbo \n\thttp://code.alibabatech.com/schema/dubbo/dubbo.xsd\">\n\n\n\t<!-- 设置不登录也可以访问的页面 -->\n\t<http pattern=\"/*.html\" security=\"none\"></http>\n\t<http pattern=\"/css/**\" security=\"none\"></http>\n\t<http pattern=\"/img/**\" security=\"none\"></http>\n\t<http pattern=\"/js/**\" security=\"none\"></http>\n\t<!-- 放开用户注册入口 -->\n\t<http pattern=\"/user/register.do\" security=\"none\"></http>\n\n\t<!-- 页面拦截规则 use-expressions:是否启用SPEL表达式,默认为true -->\n\t<http use-expressions=\"false\">\n\t\t<!-- 当前用户必须有ROLE_USER的角色才可访问根目录及所属子目录的资源 -->\n\t\t<intercept-url pattern=\"/**\" access=\"ROLE_SELLER\" />\n\t\t<!-- 开启表单登录功能 -->\n\t\t<form-login login-page=\"/login.html\"\n\t\t\tdefault-target-url=\"/index.html\" authentication-failure-url=\"/login.html\"\n\t\t\talways-use-default-target=\"true\" />\n\t\t<!-- 关闭csrf -->\n\t\t<csrf disabled=\"true\" />\n\t\t<!-- 配置策略,使用框架页面 -->\n\t\t<headers>\n\t\t\t<frame-options policy=\"SAMEORIGIN\" />\n\t\t</headers>\n\t\t<logout />\n\t</http>\n\n\t<!-- 添加认证类 -->\n\t<beans:bean id=\"userDetailService\" class=\"cn.letttgaco.service.UserDetailServiceImpl\">\n\t\t<beans:property name=\"userService\" ref=\"userService\"></beans:property>\n\t</beans:bean>\n\n\t<!-- 认证管理器 -->\n\t<authentication-manager>\n\t\t<!-- 认证的提供者 -->\n\t\t<authentication-provider user-service-ref=\"userDetailService\"/>\n\t</authentication-manager>\n</beans:beans>\n```\n\n\n通过以上配置，用户在登陆页输入用户名和密码与数据库一致即可登陆。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-02-17",
        "type": "Post",
        "slug": "fh1na3",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "Spring Security安全框架入门",
        "category": "学习笔记",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "31d9494b-7c68-4d94-a407-7625e31421fb",
        "updated": "2023-08-26 15:24:00"
      },
      "body": "",
      "realName": "Spring Security安全框架入门",
      "relativePath": "/Spring Security安全框架入门.md"
    },
    {
      "id": "0feb7c90-7c54-4806-9ade-d9ae5bab5946",
      "doc_id": "0feb7c90-7c54-4806-9ade-d9ae5bab5946",
      "title": "0feb7c90-7c54-4806-9ade-d9ae5bab5946",
      "updated": 1693063440000,
      "body_original": "\n# 引言\n\n\n之前在做项目时一直用的都是 dubbo 的 xml 配置，在调试时未防止连接超时，一般会在 xml 中设置超时时间，但是最近的项目试了下 dubbo 的注解配置，但是一时半会没找到利用注解配置来设置超时时间，于是找了找资料，整理出常用的 dubbo 的配置文件以及注解配置设置超时时间等属性。\n\n\n# 服务提供者\n\n\n## applicationContext-service.xml 配置文件\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:p=\"http://www.springframework.org/schema/p\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/mvc\n        http://www.springframework.org/schema/mvc/spring-mvc.xsd\n        http://code.alibabatech.com/schema/dubbo\n        http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context.xsd\">\n        \n\t<!--发布dubbo服务 -->\n\t<!--提供方应用信息,用于计算依赖关系-->\n\t<dubbo:application name=\"tiramisu-sellergoods-service\" />\n\t<!--注册中心的地址-->\n\t<dubbo:registry protocol=\"zookeeper\" address=\"xxx.xxx.xxx.xxx:2181\" />\n\t<!--用于dubbo协议在20881端口暴露服务-->\n\t<dubbo:protocol name=\"dubbo\" port=\"20881\"/>\n    <!--配置dubbo注解扫描包路径-->\n\t<dubbo:annotation package=\"cn.tiramisu.sellergoods.service.impl\"/>\n</beans>\n```\n\n\n## @Service 实现类\n\n\n```java\nimport com.alibaba.dubbo.config.annotation.Service;\n\n//注意不是springframework的service\n@Service\npublic class TiramisuServiceImpl implements TiramisuService {\n    \n}\n```\n\n\n# 服务消费者\n\n\n## springmvc.xml 配置文件\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:p=\"http://www.springframework.org/schema/p\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" \n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc.xsd\n        http://code.alibabatech.com/schema/dubbo \n        http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context.xsd\">\n\n\t<!-- 引用dubbo服务 -->\n\t<dubbo:application name=\"tiramisu-manager-web\" />\n    <!--注册中心的地址-->\n\t<dubbo:registry address=\"zookeeper://xxx.xxx.xxx.xxx:2181\"/>\n    <!--配置dubbo注解扫描包路径-->\n\t<dubbo:annotation package=\"cn.letttgaco.manager.controller\" />  \t\n</beans>\n```\n\n\n## @Reference 注解\n\n\n```java\nimport com.alibaba.dubbo.config.annotation.Reference;@RestController\n\n@Controller\npublic class BrandController {\n    //使用dubbo提供的reference注解，引用dubbo服务\n\t@Reference\n\tprivate TiramisuService tiramisuService; \n}\n```\n\n\n## @Service 和@Reference 的属性配置\n\n\n在平时测试过程中，由于 dubbo 默认的超时时间为 5000 毫秒，无法很方便的进行测试，容易报超时异常，而在以前的 xml 配置 dubbo 时，经常这样配置客户端的超时时间：\n\n\n```xml\n<!--设置超时时间为30秒-->\n<dubbo:service interface=\"cn.letttgaco.order.service.OrderService\" ref=\"orderServiceImpl\" timeout=\"300000\"/>\n```\n\n\n但是现在用的是 dubbo 的注解形式，设置注解形式的超时时间是直接在注解中声明的：\n\n\n```java\n//都要设置超时时间为30秒\n//服务提供方\n@Service(timeout=300000)\n//服务消费者\n@Reference(timeout=300000)\n```\n\n\n当然还有更多的属性都可以设置，如果有需要的可以研究下。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-02-09",
        "type": "Post",
        "slug": "oelsu8",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "注解式配置dubbo服务",
        "category": "学习笔记",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "0feb7c90-7c54-4806-9ade-d9ae5bab5946",
        "updated": "2023-08-26 15:24:00"
      },
      "body": "",
      "realName": "注解式配置dubbo服务",
      "relativePath": "/注解式配置dubbo服务.md"
    },
    {
      "id": "d9d157b7-9c7f-4375-8d60-d4b58d51882a",
      "doc_id": "d9d157b7-9c7f-4375-8d60-d4b58d51882a",
      "title": "d9d157b7-9c7f-4375-8d60-d4b58d51882a",
      "updated": 1693063440000,
      "body_original": "\n查看端口：netstat -ntulp\n\n\n# canal\n\n\n```text\n路径：/root/canal\n配置文件：vim /root/canal/conf/example/instance.properties\n启动：sh /root/canal/bin/startup.sh\n关闭：sh /root/canal/bin/stop.sh\nserver日志：tail -100f logs/canal/canal.log\nnstance日志：tail -100f logs/example/example.log\n删除日志：rm -rf logs/canal/canal.log logs/example/example.log\n端口：119.27.172.40:11111\n```\n\n\n# zookeeper\n\n\n```text\n路径：/usr/local/zookeeper\n配置文件：vim conf/zoo.cfg\n启动：bin/zkServer.sh start\n关闭：bin/zkServer.sh stop\n状态：zkServer.sh status\n验证：telnet 127.0.0.1 2181\n         stat\n关闭：./zkServer.sh stop\n端口：119.27.172.40:2181\n```\n\n\n# zkui\n\n\n```text\n路径：/root/zkui\n配置文件：vim config.cfg\n配置文件：vim target/config.cfg\n前台启动：java -jar target/zkui-2.0-SNAPSHOT-jar-with-dependencies.jar\n后台启动：nohup java -jar target/zkui-2.0-SNAPSHOT-jar-with-dependencies.jar &\n端口：119.27.172.40:9090\n```\n\n\n# kafka\n\n\n```text\n路径：/usr/local/kafka/kafka_2.11-1.1.1\n配置文件：vim config/server.properties\n启动server：bin/kafka-server-start.sh  -daemon  config/server.properties &\n关闭server：bin/kafka-server-stop.sh\n查看所有topic：bin/kafka-topics.sh --list --zookeeper 119.27.172.40:2181\n查看指定topic下面的数据：\nbin/kafka-console-consumer.sh --bootstrap-server 119.27.172.40:9092  --from-beginning --topic example_t\n端口：119.27.172.40:9092\n```\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2020-04-15",
        "type": "Post",
        "slug": "ymxk6u",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "阿里canal数据库命令总结",
        "category": "学习笔记",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "d9d157b7-9c7f-4375-8d60-d4b58d51882a",
        "updated": "2023-08-26 15:24:00"
      },
      "body": "",
      "realName": "阿里canal数据库命令总结",
      "relativePath": "/阿里canal数据库命令总结.md"
    },
    {
      "id": "51cd7a47-863b-49a3-8064-8797159d298e",
      "doc_id": "51cd7a47-863b-49a3-8064-8797159d298e",
      "title": "51cd7a47-863b-49a3-8064-8797159d298e",
      "updated": 1693063440000,
      "body_original": "\n记录学习一下每天都在使用的 Git 操作命令，以加快工作效率、应对意外情况的发生为目标。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FlWMWzIX9WE7PW-7eyeq8uaEJ_3p.png)\n\n\n```text\n  - Workspace：工作区\n  - Index / Stage：暂存区\n  - Repository：仓库区（或本地仓库）\n  - Remote：远程仓库\n```\n\n\n# git stash\n\n\n`git stash`的应用场景有以下几种情况，我都遇到过，以往我都是把代码复制出来再改 BUG，今天才发现这么做简直很蠢 QAQ。\n\n- 发现有一个类是多余的，想删掉它又担心以后需要查看它的代码，想保存它但又不想增加一个脏的提交。这时就可以考虑`git stash`。\n- 使用 git 的时候，我们往往使用分支（branch）解决任务切换问题，例如，我们往往会建一个自己的分支去修改和调试代码, 如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码`commit`提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 Bug，那么使用`git stash`就可以将你当前未提交到本地（和服务器）的代码推入到 Git 的栈中，这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 Bug，等到修完 Bug，提交到服务器上后，再使用`git stash apply`将以前一半的工作应用回来。\n- 经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是`git stash`命令。储藏(stash)可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。\n\n`git stash`会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。 比如下面的中间状态，通过 git stash 命令推送一个新的储藏，当前的工作目录就干净了。而且`git stash`是本地存储，并不会推送到服务器。\n\n\n```bash\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n$ git stash\nSaved working directory and index state WIP on master: e4f060f add readme\n\n$ git status\nOn branch master\nnothing to commit, working tree clean\n```\n\n\n## git stash save\n\n\n实际应用中推荐给每个 stash 加一个 message，用于记录版本，使用`git stash save`取代`git stash`命令。\n\n\n```bash\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n$ git stash save '改了index的标题'\nSaved working directory and index state On master: 改了index的标题\n\n$ git status\nOn branch master\nnothing to commit, working tree clean\n\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n```\n\n\n## git stash apply\n\n\ngit stash apply 用于将缓存堆栈中的 stash 恢复到工作目录中，但并不删除 stash 拷贝。也可以使用`git stash apply stash@{1}` 指定恢复某个`stash`，不加参数默认最近的一个 stash，即`git stash apply stash@{0}`\n\n\n```bash\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n\n$ git stash apply stash@{1}\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\n\n## git stash pop\n\n\n和`apply`作用类似，这个指令可以将缓存堆栈中的第一个`stash`删除，并将对应修改应用到当前的工作目录下。\n\n\n```bash\n$ git stash list\nstash@{0}: WIP on master: e4f060f add readme\nstash@{1}: On master: 改了index的标题\nstash@{2}: WIP on master: e4f060f add readme\nstash@{3}: WIP on master: e4f060f add readme\n\n$ git stash pop\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (91bfd4fd55e0e3f90a480dfc5bebe0394a393860)\n\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n```\n\n\n## git stash drop\n\n\n用于移除缓存堆栈中的第一个`stash`，也可以指定删除某一个`stash`\n\n\n```bash\n$ git stash list\nstash@{0}: WIP on master: e4f060f add readme\nstash@{1}: On master: 改了index的标题\nstash@{2}: WIP on master: e4f060f add readme\nstash@{3}: WIP on master: e4f060f add readme\n\n$ git stash drop\nDropped refs/stash@{0} (22b04ba90a37fb36d5f8e7228e7d8cee324a148b)\n\n$ git stash list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\nstash@{2}: WIP on master: e4f060f add readme\n\n$ git stash drop stash@{2}\nDropped stash@{2} (33d9570595f16bc5f4a07247551377e10a0a6ce1)\n\n$ git stash  list\nstash@{0}: On master: 改了index的标题\nstash@{1}: WIP on master: e4f060f add readme\n```\n\n\n## git stash show\n\n\n用于查看最近一个或者指定`stash`的 diff，貌似用到的不多，记录下。`git stash show -p`可以查看特定`stash`的全部`diff`以及更人性化一点，\n\n\n```text\n$ git stash  list\nstash@{0}: WIP on master: e4f060f add readme\nstash@{1}: On master: 改了index的标题\nstash@{2}: WIP on master: e4f060f add readme\n\n$ git stash show\n index.html | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n$ git stash show stash@{2}\n index.html | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n$ git stash show -p\ndiff --git a/index.html b/index.html\nindex 79c2914..47be827 100644\n--- a/index.html\n+++ b/index.html\n@@ -5,9 +5,9 @@\n......\n```\n\n\n## git stash branch\n\n\n这条命令会根据最近的 `stash` 创建一个新的分支，然后删除最近的 `stash`（和 `stash pop` 一样）。如果你需要某个 `stash`，你可以指明 `stash id`。\n\n\n```text\n# git_learning (master)\n$ git stash\nSaved working directory and index state WIP on master: e4f060f add readme\n\n# git_learning (master)\n$ git stash list\nstash@{0}: WIP on master: e4f060f add readme\n\n# git_learning (master)\n$ git stash branch testbranch\n# 或者指定id\n#$ git stash branch testbranch stash@{0}\nSwitched to a new branch 'testbranch'\nOn branch testbranch\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n        modified:   index.html\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nDropped refs/stash@{0} (e943a81398f2f01a2d64b227488af67a49b78e57)\n\n# git_learning (testbranch)\n$ git stash list\n# 无,被删除了\n```\n\n\n## 小结\n\n\n默认情况下，`git stash`会缓存下列文件：\n\n- 添加到暂存区的修改（`staged changes`）\n- Git 跟踪的但并未添加到暂存区的修改（`unstaged changes`），即`git add` 但未 `git commit`\n\n但不会缓存一下文件：\n\n- 在工作目录中新的文件（`untracked files`）\n- 被忽略的文件（`ignored files`）\n\n`git stash`命令提供了参数用于缓存上面两种类型的文件。使用`-u`或者`--include-untracked`可以缓存`stash untracked`文件。使用`-a`或者`--all`命令可以 stash 当前目录下的所有修改。\n\n\n# git checkout\n\n\n## 基础用法\n\n\n`checkout`最常用的用法莫过于对于工作分支的切换了： `git checkout branchName`只是将项目切换到任意分支，不创建分支。 除非再`git clone` 一个新的项目后，因为只会默认在本地创建一个`master`分支，这个时候想要切换到远程分支的话，一般是创建该分支的本地分支并切换到该分支。\n\n\n```text\n创建新分支：git branch branchName\n\n切换到新分支：git checkout branchName\n```\n\n\n但是大多数情况下都是创建分支的时候切换分支。所以以上语句可以合成一句话： `git checkout -b branchName`\n\n\n## 进阶\n\n\n要想更深入的了解`checkout`，我们需要了解`checkout`的作用机制。该命令的主要关联目标其实是`.git` 文件夹下的`HEAD`文件。 我们可以看到`HEAD`头文件是一个引用，指向的是当前的分支，如果变更分支，该`HEAD`会变更。\n\n\n```text\n# git_learning (master)\n$ cd .git/\n\n# git_learning/.git (GIT_DIR!)\n$ ls\nCOMMIT_EDITMSG  description  gitk.cache  hooks/  info/  objects/   refs/\nconfig          FETCH_HEAD   HEAD        index   logs/  ORIG_HEAD\n\n# git_learning/.git (GIT_DIR!)\n$ cat HEAD\nref: refs/heads/master\n\n# git_learning/.git (GIT_DIR!)\n$ cd refs/heads/\n\n# git_learning/.git/refs/heads (GIT_DIR!)\n$ ls\n111  master  new_branch  testbranch\n\n# git_learning/.git/refs/heads (GIT_DIR!)\n$  cat master\ne4f060f544371c8adab70af931ba008024bdc2e1\n\n# git_learning (master)\n$ git checkout 111\nSwitched to branch '111'\n\n# git_learning (111)\n$ cat .git/HEAD\nref: refs/heads/111\n```\n\n\n……持续记录中 QAQ\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2020-03-01",
        "type": "Post",
        "slug": "vkdsce",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "Git常用命令",
        "category": "学习笔记",
        "tags": [
          "Git"
        ],
        "status": "Archived",
        "urlname": "51cd7a47-863b-49a3-8064-8797159d298e",
        "updated": "2023-08-26 15:24:00"
      },
      "body": "",
      "realName": "Git常用命令",
      "relativePath": "/Git常用命令.md"
    },
    {
      "id": "6c0aa69b-7ec6-47ac-b2fd-4984e2f4e020",
      "doc_id": "6c0aa69b-7ec6-47ac-b2fd-4984e2f4e020",
      "title": "6c0aa69b-7ec6-47ac-b2fd-4984e2f4e020",
      "updated": 1693063440000,
      "body_original": "\n# 引言\n\n\n在 Notion 成为我的唯一生产力工具之后，我尝试把日常生活、工作中的点点滴滴都用Notion 记录下来。为此我专门建立了个人主页，把打造个人主页的过程用一个系列记录下来。\n\n\n本次分享的就是打造自己的TODO List（待办事项清单）\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/e18097a7-2412-467f-962a-30ea84b2ca92/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230927T015944Z&X-Amz-Expires=3600&X-Amz-Signature=79f61006b6d9c72dcab3c0115007d48a29f8f2312e420ddfc4a00c8d08c2b560&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n# 看板\n\n- 头脑风暴看板：将平时的灵感、暂定的待办事项都记录到这里\n- 今日任务：把今天要做的任务罗列在此，并按时调整任务状态\n- 明日任务：把明天要做的TODO罗列在此\n- 每周看板：回顾本周（周一到周日）的任务\n- 上周看板：回顾上周的任务\n- 汇总：查看所有任务的状态\n\n# 数据库属性\n\n- 任务状态（Status）\n\t- Todo：待办\n\t- Doing：正在做\n\t- Done：已完成\n- 类型\n\t- 个人\n\t- 工作\n- 未完成：今天以前状态未扭转到`Done`的任务\n- 本周一：根据当前时间获取本周一的00:00\n- 本周日：根据当前时间获取本周日的23:59\n- 上周一：根据当前时间获取上周一的00:00\n- 本周日：根据当前时间获取上周日的23:59\n\n## Notion 数据库函数实践\n\n\n## 本周看板（周一到周天）\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/7514f7ff-79d8-4baf-b8be-b6f9d25aced8/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230927T015944Z&X-Amz-Expires=3600&X-Amz-Signature=dd38e73c61337f2adb65a59268556381a6b6a761b5c306facf1ba9936a7966d9&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n```javascript\n// 1. 获取本周起始时间（相对于现在时间的周一的00:00）\n// 1.1 获取今天的00:00\n// 1.1.1 获取今天的xx:00\nconst time1 = dateSubtract(now(), minute(now()), \"minutes\")\n// 1.1.2 获取今天的00:00\nconst time2 = dateSubtract(time1, hour(now()), \"hours\")\n// 1.2 获取周一的00:00\n// 矫正星期\nif(equal(day(now()), 0), 7, day(now()))\nconst 本周一 = dateSubtract(time2, if(equal(day(now()), 0), 7, day(now())) - 1, \"days\")\n// 函数\ndateSubtract(dateSubtract(dateSubtract(now(), minute(now()), \"minutes\"), hour(now()), \"hours\"), if(equal(day(now()), 0), 7, day(now())), \"days\")\n\n// 2. 获取本周的结束时间（相对于现在时间的周日的23:59）\n// 2.1 获取今天的23:59\n// 2.1.1 获取今天的xx:59\nconst time1 = dateAdd(dateAdd(now(), 59 - minute(now()), \"minutes\")\n// 2.1.2 获取今天的23:59\nconst time2 = dateAdd(time1, 23 - hour(now()), \"hours\")\n// 2.2 获取周天的23:59\n// 矫正星期\nif(equal(day(now()), 0), 7, day(now()))\nconst 本周天 = dateAdd(time2, 7 - if(equal(day(now()), 0), 7, day(now())), \"days\")\n// 函数\ndateAdd(dateAdd(dateAdd(now(), 59 - minute(now()), \"minutes\"), 23 - hour(now()), \"hours\"), 7 - if(equal(day(now()), 0), 7, day(now())), \"days\")\n\n// 3. 判断是否是本周\nconst 是否是本周 = and(largerEq(prop(\"日期\"), prop(\"本周一\")), smallerEq(prop(\"日期\"), prop(\"本周天\")))\n```\n\n\n## 上周看板\n\n\n### 如何判断任务处于上周内\n\n\n```javascript\n// 1. 获取上周起始时间（相对于现在时间的上周一的00:00）\n// 1.1 获取本周一的时间\n// 矫正星期\nif(equal(day(now()), 0), 7, day(now()))\nconst time1 = dateSubtract(now(), if(equal(day(now()), 0), 7, day(now())) - 1, \"days\")\n// 1.2 获取上周一的时间\nconst time2 = dateSubtract(time1, 7, \"days\")\n// 1.3 获取上周一的xx:00\nconst time3 = dateSubtract(time2, minute(time2), \"minutes\")\n// 1.4 获取上周一的00:00\nconst 上周一 = dateSubtract(time3, hour(time2), \"hours\")\n// 函数\ndateSubtract(dateSubtract(dateSubtract(dateSubtract(now(), if(equal(day(now()), 0), 7, day(now())) - 1, \"days\"), 7, \"days\"), minute(dateSubtract(dateSubtract(now(), if(equal(day(now()), 0), 7, day(now())) - 1, \"days\"), 7, \"days\")), \"minutes\"), hour(dateSubtract(dateSubtract(now(), if(equal(day(now()), 0), 7, day(now())) - 1, \"days\"), 7, \"days\")), \"hours\")\n\n// 2. 获取上周的结束时间（相对于现在时间的上周日的23:59）\n// 2.1 获取本周日的时间\n// 矫正星期\nif(equal(day(now()), 0), 7, day(now()))\nconst time1 = dateAdd(now(), 7 - if(equal(day(now()), 0), 7, day(now())), \"days\")\n// 2.2 获取上周日的时间\nconst time2 = dateSubtract(time1, 7, \"days\")\n// 2.3 获取上周日的xx:59\nconst time3 = dateAdd(time2, 59 - minute(time2), \"minutes\")\n// 2.4 获取上周日的23:59\nconst 上周日 = dateAdd(time3, 23 - hour(time2), \"hours\")\n// 函数\ndateAdd(dateAdd(dateSubtract(dateAdd(now(), 7 - if(equal(day(now()), 0), 7, day(now())), \"days\"), 7, \"days\"), 59 - minute(dateSubtract(dateAdd(now(), 7 - if(equal(day(now()), 0), 7, day(now())), \"days\"), 7, \"days\")), \"minutes\"), 23 - hour(dateSubtract(dateAdd(now(), 7 - if(equal(day(now()), 0), 7, day(now())), \"days\"), 7, \"days\")), \"hours\")\n\n// 3. 判断是否是上周\nconst 是否是上周 = and(largerEq(prop(\"日期\"), prop(\"上周一\")), smallerEq(prop(\"日期\"), prop(\"上周日\")))\n```\n\n\n# 高级筛选\n\n\n## 自动调整指定属性值\n\n\n当存在过期任务（该任务在今天之前处于未完成（Todo/Doing）状态）时，需要在`今日任务`中展示出来。而且当我在今天将过期扭转到Done时，该任务的完成时间应该是今天，而非原本的过期时间，以便在`本周看板`中能看到这些任务。\n\n\n所以需要这些过期任务在扭转到Done状态时，时间自动调整为今天。\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/f4ae0953-19f7-43fe-b089-1bf553e57b87/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230927T015944Z&X-Amz-Expires=3600&X-Amz-Signature=79ec5379cddfe40cb91b90f5d920dc2af959a713ee3f90f84e62245f5dcd13e3&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n好在Notion相当智能，只需要将筛选条件变为高级筛选，并设置为以上条件。在把过期任务拖拽到Done状态时，Notion会将时间会自动调整为今天以符合当前的筛选条件。\n\n\n# Notion模版分享\n\n\n[bookmark](https://1874.notion.site/6fe9704466f3475b95ed03cd4f3250c1?v=36f35706926f4960af8b076c505cf16b)\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-14T18:04:00.000Z",
        "date": "2023-04-15",
        "type": "Post",
        "slug": "notion-weekly-board",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何在Notion中打造TODO List，包括看板和数据库属性的设置，以及高级筛选和函数的使用。此外，还分享了Notion模板。",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "玩转Notion系列——TODO List",
        "category": "技术分享",
        "tags": [
          "Notion"
        ],
        "status": "Archived",
        "urlname": "6c0aa69b-7ec6-47ac-b2fd-4984e2f4e020",
        "updated": "2023-08-26 15:24:00"
      },
      "body": "",
      "realName": "玩转Notion系列——TODO List",
      "relativePath": "/玩转Notion系列——TODO List.md"
    },
    {
      "id": "02209783-f54d-4d2e-9a4e-508c42e43ad9",
      "doc_id": "02209783-f54d-4d2e-9a4e-508c42e43ad9",
      "title": "02209783-f54d-4d2e-9a4e-508c42e43ad9",
      "updated": 1693063440000,
      "body_original": "\n# 引言\n\n\n在[语雀云端写作 Hexo+Github Actions+COS 持续集成](https://1874.cool/roeayv)中我需要一个 Node 项目来作为中转站替换原来的腾讯云函数，调用`Github Actions`的接口触发构建流程，这里记录下搭建过程。\n\n\n# 初始化 Midway\n\n\n> [Midway 官方文档](https://www.midwayjs.org/docs/intro)\n\n\n我基本都是按照官方文档来搭建的，初始化的过程也很简单，初始化之后把不需要用到的文件删除，基本不用配置就可以直接就可以写代码了。\n\n\n# 接口流程\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FgaQOwsx7NXJi2YH3J7Gb_k9mrUS.jpeg)\n\n\n# 代码编写\n\n\n## GithubController\n\n\n```typescript\nimport { Controller, Inject, Post } from \"@midwayjs/decorator\";\nimport { Context } from \"egg\";\nimport { GithubService } from \"../service/github\";\n\n@Controller(\"/github\")\nexport class GithubController {\n  @Inject()\n  ctx: Context;\n\n  @Inject()\n  githubService: GithubService;\n\n  @Post(\"/action/:repo/:event_type\")\n  async deploy() {\n    const { repo, event_type } = this.ctx.params;\n    return await this.githubService.action(repo, event_type);\n  }\n}\n```\n\n\n根据语雀的[webhooks 介绍](https://www.yuque.com/yuque/developer/doc-webhook#4da6e742)，语雀的回调函数是一个 Post 接口\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FiolJEozqoDDhLhUp3ebRyctkYD7.png)\n\n\n所以可以有以下两种处理方法传参数\n\n- 将需要的参数拼接在调用链接上，通过`@Query()`拿到参数\n- 利用动态路由传参数，通过`this.ctx.params`拿到参数\n\n## GithubService\n\n\n```typescript\nimport { Provide } from \"@midwayjs/decorator\";\nimport axios from \"axios\";\n\n@Provide()\nexport class GithubService {\n  /**\n   * 触发Github Actions\n   * @param repo\n   * @param event_type\n   */\n  async action(repo: string, event_type: string): Promise<any> {\n    try {\n      const res = await axios.post(\n        `https://api.github.com/repos/LetTTGACO/${repo}/dispatches`,\n        { event_type },\n        {\n          headers: {\n            Accept: \"*/*\",\n            Authorization: \"token Github访问Token\",\n          },\n        }\n      );\n      if (res.status === 204) {\n        return \"This is OK!\";\n      }\n    } catch (e) {\n      return e.message;\n    }\n  }\n}\n```\n\n\n# Done!\n\n\n大功告成，接下来就是构建和部署阶段了，详情请看\n\n\n[bookmark](https://1874.cool/ovugli)\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-07-16",
        "type": "Post",
        "slug": "zbbxv0",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文记录了在语雀云端写作 Hexo+Github Actions+COS 持续集成中，搭建 Node 项目作为中转站的过程。通过初始化 Midway，编写 GithubController 和 GithubService，实现了通过 Github Actions 的接口触发构建流程。详细内容请见文章。",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "Midway项目搭建记录",
        "category": "学习笔记",
        "tags": [
          "Node",
          "Midway"
        ],
        "status": "Archived",
        "urlname": "02209783-f54d-4d2e-9a4e-508c42e43ad9",
        "updated": "2023-08-26 15:24:00"
      },
      "body": "",
      "realName": "Midway项目搭建记录",
      "relativePath": "/Midway项目搭建记录.md"
    },
    {
      "id": "c28edc25-f869-45dd-875e-0e7396067ac4",
      "doc_id": "c28edc25-f869-45dd-875e-0e7396067ac4",
      "title": "c28edc25-f869-45dd-875e-0e7396067ac4",
      "updated": 1693063320000,
      "body_original": "\n# 引言\n\n\n前段时间写了 [yuque-hexo 插件语雀图片防盗链的解决方案](https://www.yuque.com/1874w/1874.cool/osar7h)。当时使用的是腾讯云图床，后来考虑到可以支持更多的图床选择。这次的改造新增了阿里云图床和七牛云图床。\n\n\n## 阿里云图床\n\n\n阿里云图床目前各大公司也都在用，技术成熟稳定，但也和腾讯云图床一样，是收费的。但是作为个人博客图床的话，腾讯云 COS 和阿里云 OSS 的费用都相当的便宜，一个月的费用大概都在几分钱到几毛钱的范围。\n\n\n## 七牛云图床\n\n\n七牛云图床为个人提供 10G 的免费存储空间和完全够用的免费读写流量，用来作为博客图床再合适不过了。缺点就是七牛云图床默认使用 CDN 域名进行外链访问，而且是 30 天的临时域名，所以建议绑定一个备案域名作为永久 CND 域名进行访问。\n\n\n# 改造思路\n\n\n由于各大图床的 API 使用方式不尽相同，所以需要抽离出一个适配层进行接口调用的统一，通过不同的配置获取不同的图床实例进行 API 操作。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fhhlf0McPMjB-ly-QqWXkn9W3tG-.jpeg)\n\n\n# 具体实现\n\n\n## 目录结构\n\n\n```typescript\n|--imageBeds\n|  |--index                 //接口统一适配层\n|  |--cos.js            //腾讯云图床API操作层\n|  |--oss.js            //阿里云图床API操作层\n|  |--qiniu.js          //七牛云图床API操作层\n\n```\n\n\n## 代码实现\n\n\n### 接口统一适配层\n\n\n```javascript\n// imageBeds/index.js\n// 接口统一适配层\n\n\"use strict\";\n// 引入图床实例\nconst CosClient = require(\"./cos\");\nconst OssClient = require(\"./oss\");\nconst QiniuClient = require(\"./qiniu\");\nconst out = require(\"../../lib/out\");\n\n// 目前已适配图床列表\nconst imageBedList = [\"qiniu\", \"cos\", \"oss\"];\n\nclass ImageBeds {\n  constructor(config) {\n    // 实例化时先赋值保存config配置\n    this.config = config;\n    // 获取图床实例\n    this.imageBedInstance = this.getImageBedInstance(config.imageBed);\n  }\n  // 单例模式\n  static getInstance(config) {\n    if (!this.instance) {\n      this.instance = new ImageBeds(config);\n    }\n    return this.instance;\n  }\n\n  /**\n   * 获取图床对象的实例\n   *\n   * @param {string} imageBed 图床类型: cos | oss\n   * @return {any} 图床实例\n   */\n  getImageBedInstance(imageBed) {\n    if (!imageBedList.includes(imageBed)) {\n      out.error(`imageBed配置错误，目前只支持${imageBedList.toString()}`);\n      process.exit(-1);\n    }\n    switch (imageBed) {\n      case \"cos\":\n        return CosClient.getInstance(this.config);\n      case \"oss\":\n        return OssClient.getInstance(this.config);\n      case \"qiniu\":\n        return QiniuClient.getInstance(this.config);\n      default:\n        return QiniuClient.getInstance(this.config);\n    }\n  }\n\n  /**\n   * 检查图床是否已经存在图片，存在则返回url\n   *\n   * @param {string} fileName 文件名\n   * @return {Promise<string>} 图片url\n   */\n  async hasImage(fileName) {\n    return await this.imageBedInstance.hasImage(fileName);\n  }\n\n  /**\n   * 上传图片到图床\n   *\n   * @param {Buffer} imgBuffer 文件buffer\n   * @param {string} fileName 文件名\n   * @return {Promise<string>} 图床的图片url\n   */\n  async uploadImg(imgBuffer, fileName) {\n    return await this.imageBedInstance.uploadImg(imgBuffer, fileName);\n  }\n}\n\nmodule.exports = ImageBeds;\n```\n\n\n### 腾讯云图床 API 操作层\n\n\n```javascript\n// imageBeds/cos.js\n// 腾讯云图床API操作层\n// 开发文档: https://cloud.tencent.com/document/product/436/8629\n\n\"use strict\";\n\n// 腾讯云图床\nconst COS = require(\"cos-nodejs-sdk-v5\");\nconst out = require(\"../../lib/out\");\n\nconst secretId = process.env.SECRET_ID;\nconst secretKey = process.env.SECRET_KEY;\n\nclass CosClient {\n  constructor(config) {\n    this.config = config;\n    // 实例化腾讯云COS\n    this.imageBedInstance = new COS({\n      SecretId: secretId, // 身份识别ID\n      SecretKey: secretKey, // 身份秘钥\n    });\n  }\n  // 单例模式\n  static getInstance(config) {\n    if (!this.instance) {\n      this.instance = new CosClient(config);\n    }\n    return this.instance;\n  }\n\n  /**\n   * 检查图床是否已经存在图片，存在则返回url,不存在返回空\n   *\n   * @param {string} fileName 文件名\n   * @return {Promise<string>} 图片url\n   */\n  async hasImage(fileName) {\n    try {\n      await this.imageBedInstance.headObject({\n        Bucket: this.config.bucket, // 存储桶名字（必须）\n        Region: this.config.region, // 存储桶所在地域，必须字段\n        Key: `${this.config.prefixKey}/${fileName}`, //  文件名  必须\n      });\n      return `https://${this.config.bucket}.cos.${this.config.region}.myqcloud.com/${this.config.prefixKey}/${fileName}`;\n    } catch (e) {\n      return \"\";\n    }\n  }\n\n  /**\n   * 上传图片到图床\n   *\n   * @param {Buffer} imgBuffer 文件buffer\n   * @param {string} fileName 文件名\n   * @return {Promise<string>} 图床的图片url\n   */\n  async uploadImg(imgBuffer, fileName) {\n    try {\n      const res = await this.imageBedInstance.putObject({\n        Bucket: this.config.bucket, // 存储桶名字（必须）\n        Region: this.config.region, // 存储桶所在地域，必须字段\n        Key: `${this.config.prefixKey}/${fileName}`, //  文件名  必须\n        StorageClass: \"STANDARD\", // 上传模式（标准模式）\n        Body: imgBuffer, // 上传文件对象\n      });\n      return `https://${res.Location}`;\n    } catch (e) {\n      out.error(`上传图片失败，请检查: ${e}`);\n      process.exit(-1);\n    }\n  }\n}\n\nmodule.exports = CosClient;\n```\n\n\n### 阿里云图床 API 操作层\n\n\n```javascript\n// imageBeds/oss.js\n// 阿里云图床API操作层\n// 开发文档: https://help.aliyun.com/document_detail/32067.html\n\n\"use strict\";\n\n// 阿里云图床\nconst OSS = require(\"ali-oss\");\nconst out = require(\"../../lib/out\");\n\nconst secretId = process.env.SECRET_ID;\nconst secretKey = process.env.SECRET_KEY;\n\nclass OssClient {\n  constructor(config) {\n    this.config = config;\n    this.imageBedInstance = new OSS({\n      bucket: config.bucket,\n      // yourRegion填写Bucket所在地域。以华东1（杭州）为例，Region填写为oss-cn-hangzhou。\n      region: config.region,\n      // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。\n      accessKeyId: secretId,\n      accessKeySecret: secretKey,\n    });\n  }\n  // 单例模式\n  static getInstance(config) {\n    if (!this.instance) {\n      this.instance = new OssClient(config);\n    }\n    return this.instance;\n  }\n\n  /**\n   * 检查图床是否已经存在图片，存在则返回url,不存在返回空\n   *\n   * @param {string} fileName 文件名\n   * @return {Promise<string>} 图片url\n   */\n  async hasImage(fileName) {\n    try {\n      await this.imageBedInstance.head(`${this.config.prefixKey}/${fileName}`);\n      return `https://${this.config.bucket}.${this.config.region}.aliyuncs.com/${this.config.prefixKey}/${fileName}`;\n    } catch (e) {\n      return \"\";\n    }\n  }\n\n  /**\n   * 上传图片到图床\n   *\n   * @param {Buffer} imgBuffer 文件buffer\n   * @param {string} fileName 文件名\n   * @return {Promise<string>} 图床的图片url\n   */\n  async uploadImg(imgBuffer, fileName) {\n    try {\n      const res = await this.imageBedInstance.put(\n        `${this.config.prefixKey}/${fileName}`,\n        imgBuffer\n      );\n      return res.url;\n    } catch (e) {\n      out.error(`上传图片失败，请检查: ${e}`);\n      process.exit(-1);\n    }\n  }\n}\n\nmodule.exports = OssClient;\n```\n\n\n### 七牛云图床 API 操作层\n\n\n```javascript\n// imageBeds/qiniu.js\n// 七牛云图床API操作层\n// 七牛云的上传程序相对比较复杂，详情请查看sdk文档https://developer.qiniu.com/kodo/1289/nodejs\n\n\"use strict\";\n\n// 七牛云图床\nconst qiniu = require(\"qiniu\");\nconst out = require(\"../../lib/out\");\n\nconst secretId = process.env.SECRET_ID;\nconst secretKey = process.env.SECRET_KEY;\n\nclass QiniuClient {\n  constructor(config) {\n    this.config = config;\n    this.init();\n  }\n\n  init() {\n    if (!this.config.host) {\n      out.error(\"使用七牛云时，需要在imgCdn中指定域名host\");\n      process.exit(-1);\n    }\n    const mac = new qiniu.auth.digest.Mac(secretId, secretKey);\n    // 配置\n    const putPolicy = new qiniu.rs.PutPolicy({ scope: this.config.bucket });\n    // 获取上传凭证\n    this.uploadToken = putPolicy.uploadToken(mac);\n    const config = new qiniu.conf.Config();\n    // 空间对应的机房\n    config.zone = qiniu.zone[this.config.region];\n    this.formUploader = new qiniu.form_up.FormUploader(config);\n    this.bucketManager = new qiniu.rs.BucketManager(mac, config);\n    this.putExtra = new qiniu.form_up.PutExtra();\n  }\n\n  static getInstance(config) {\n    if (!this.instance) {\n      this.instance = new QiniuClient(config);\n    }\n    return this.instance;\n  }\n\n  /**\n   * 检查图床是否已经存在图片，存在则返回url,不存在返回空\n   *\n   * @param {string} fileName 文件名\n   * @return {Promise<string>} 图片url\n   */\n  async hasImage(fileName) {\n    return await new Promise((resolve) => {\n      this.bucketManager.stat(\n        this.config.bucket,\n        `${this.config.prefixKey}/${fileName}`,\n        (err, respBody, respInfo) => {\n          if (err) {\n            out.error(`上传图片失败，请检查: ${err}`);\n            process.exit(-1);\n          } else {\n            if (respInfo.statusCode === 200) {\n              resolve(\n                `${this.config.host}/${this.config.prefixKey}/${fileName}`\n              );\n            } else {\n              resolve(\"\");\n            }\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * 上传图片到图床\n   *\n   * @param {Buffer} imgBuffer 文件buffer\n   * @param {string} fileName 文件名\n   * @return {Promise<string>} 图床的图片url\n   */\n  async uploadImg(imgBuffer, fileName) {\n    return await new Promise((resolve) => {\n      this.formUploader.put(\n        this.uploadToken,\n        `${this.config.prefixKey}/${fileName}`,\n        imgBuffer,\n        this.putExtra,\n        (respErr, respBody, respInfo) => {\n          if (respErr) {\n            out.error(`上传图片失败，请检查: ${respErr}`);\n            process.exit(-1);\n          }\n          if (respInfo.statusCode === 200) {\n            resolve(`${this.config.host}/${this.config.prefixKey}/${fileName}`);\n          } else {\n            out.error(`上传图片失败，请检查: ${respInfo}`);\n            process.exit(-1);\n          }\n        }\n      );\n    });\n  }\n}\n\nmodule.exports = QiniuClient;\n```\n\n\n# 大功告成！\n\n\n使用时，只需要在上层传入 config 配置，获取接口适配层实例，并替换原有的上传图片接口即可。\n\n\n更多源代码详情，请查看[yuqe-hexo-with-cdn](https://github.com/LetTTGACO/yuque-hexo-with-cdn)\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-02-12",
        "type": "Post",
        "slug": "nvikqw",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "这是一个支持多个图床的插件，用于在博客中上传图片。目前已适配的图床包括腾讯云、阿里云和七牛云。该插件提供了一个接口适配层，使得上层在使用时可以传入不同的配置参数选择不同的图床。更多详情请查看yuqe-hexo-with-cdn。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "yuqe-hexo-with-cdn插件支持多图床",
        "category": "技术分享",
        "tags": [
          "Hexo"
        ],
        "status": "Archived",
        "urlname": "c28edc25-f869-45dd-875e-0e7396067ac4",
        "updated": "2023-08-26 15:22:00"
      },
      "body": "",
      "realName": "yuqe-hexo-with-cdn插件支持多图床",
      "relativePath": "/yuqe-hexo-with-cdn插件支持多图床.md"
    },
    {
      "id": "8e09392b-f4ba-4969-8f3f-d47d779f6ff3",
      "doc_id": "8e09392b-f4ba-4969-8f3f-d47d779f6ff3",
      "title": "8e09392b-f4ba-4969-8f3f-d47d779f6ff3",
      "updated": 1693063320000,
      "body_original": "\n# 引言\n\n\n在我接触前端以来，用的都是脚手架或者是别人封装好的前端框架。对于`webpack`，我一直处于一知半解的状态，去年在搭建多页面构建的时候，一直搞定不了多页面构建的问题。考虑到后面还会来搭建`webpack`，所以最近学学`webpack`，结果一上来就出错，一脸懵逼。\n\n\n# 出现异常\n\n\n安装的都是最新版本的`webpack`及相关依赖。\n\n\n```text\n\"devDependencies\": {\n    \"@babel/core\": \"^7.12.10\",\n    \"@babel/preset-env\": \"^7.12.11\",\n    \"@babel/preset-react\": \"^7.12.10\",\n    \"babel-loader\": \"^8.2.2\",\n    \"css-loader\": \"^5.0.1\",\n    \"file-loader\": \"^6.2.0\",\n    \"html-webpack-plugin\": \"^4.5.1\",\n    \"less\": \"^4.0.0\",\n    \"less-loader\": \"^7.2.1\",\n    \"react\": \"^17.0.1\",\n    \"react-dom\": \"^17.0.1\",\n    \"style-loader\": \"^2.0.0\",\n    \"url-loader\": \"^4.1.1\",\n    \"webpack\": \"^5.11.1\",\n    \"webpack-cli\": \"^4.3.1\",\n    \"webpack-dev-server\": \"^3.11.1\"\n  }\n```\n\n\n在运行 `webpack-dev-server --open` 时，报错如下：\n\n\n```text\n> webpack-dev-server --open\n\ninternal/modules/cjs/loader.js:979\n  throw err;\n  ^\nError: Cannot find module 'webpack-cli/bin/config-yargs'\nRequire stack:\n- /Users/xxx/workSpace/webpack/node_modules/webpack-dev-server/bin/webpack-dev-server.js\n    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:976:15)\n    at Function.Module._load (internal/modules/cjs/loader.js:859:27)\n    at Module.require (internal/modules/cjs/loader.js:1036:19)\n    at require (internal/modules/cjs/helpers.js:72:18)\n    at Object.<anonymous> (/Users/fangpengfei/workSpace/webpack/node_modules/webpack-dev-server/bin/webpack-dev-server.js:65:1)\n    at Module._compile (internal/modules/cjs/loader.js:1147:30)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1167:10)\n    at Module.load (internal/modules/cjs/loader.js:996:32)\n    at Function.Module._load (internal/modules/cjs/loader.js:896:14)\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:71:12) {\n  code: 'MODULE_NOT_FOUND',\n  requireStack: [\n    '/Users/xxx/workSpace/webpack/node_modules/webpack-dev-server/bin/webpack-dev-server.js'\n  ]\n}\n```\n\n\n# 异常原因\n\n\n去`Google`后发现都是让重新安装低版本的`webpack-cli`，因为版本不兼容！想了想不对劲啊，既然版本不兼容，为什么不解决呢，看了下出现问题的时间都是去年甚至前年了，难道官方就不考虑解决吗？这个解决办法我不接受。按照国际惯例，我去`Github`上的[webpack-dev-server Issues](https://github.com/webpack/webpack-dev-server/issues/2759)去寻找答案，果然不出我所料：\n\n\n```text\nYes - webpack-dev-server does not work with webpack-cli v4\nCan you try ? webpack serve\n```\n\n\n在`webpack-cli v4` 中已经不支持用`webpack-dev-server`直接调用了！ 应该   用`webpack serve`来替换`webpack-dev-server`\n\n\n# 解决办法\n\n\n当然是使用新版本的启动方法啊！\n\n\n```text\n\"scripts\": {\n    \"build\": \"webpack\",\n    \"watch\": \"webpack --watch\",\n    \"dev\": \"webpack serve --open\", // 相当于旧版本的webpack-dev-server --open\n  },\n```\n\n\n> 注意：是webpack serve 而不是webpack server，不要多一个 r 顺带附上webpack-dev-server的新版本文档，文档里面也换成了新的启动方式。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-01-09",
        "type": "Post",
        "slug": "fqx1vy",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "webpack-dev-server启动找不到config-yargs",
        "category": "技术分享",
        "tags": [
          "Webpack"
        ],
        "status": "Archived",
        "urlname": "8e09392b-f4ba-4969-8f3f-d47d779f6ff3",
        "updated": "2023-08-26 15:22:00"
      },
      "body": "",
      "realName": "webpack-dev-server启动找不到config-yargs",
      "relativePath": "/webpack-dev-server启动找不到config-yargs.md"
    },
    {
      "id": "506adb06-6632-4133-be32-171a4ec0af21",
      "doc_id": "506adb06-6632-4133-be32-171a4ec0af21",
      "title": "506adb06-6632-4133-be32-171a4ec0af21",
      "updated": 1693063320000,
      "body_original": "\n## 引言\n\n\n前端代码规范已经折麽我无数次了，每次接别人的项目，一打开项目一片红，更要命的是用`eslint --fix` 也无济于事，不是和 Prettier 冲突，就是和 Editorconfig 冲突，格式化出来的代码依然报错。偏偏项目还使用了`lint-staged`，导致经常代码经常因为代码格式问题提交不上去！\n\n\n我自己一直以来都习惯用 WebStorm 来开发，其他大部分人都用的 VSCode ，因为开发工具的配置差异，导致别人的 VSCode 代码检查不报错，而到了我的手上就一片红。\n\n\n来来回回折腾了几个项目后，我决定统一团队的开发规范，并适配因为开发工具而导致代码检查差异！\n\n\n在踩坑了几个日夜后，终于搞出了一套代码规范，不仅能适配各个开发工具，也能在此基础上规范团队的代码规范。\n\n\n## 代码风格\n\n\n此次采用的方案是 Eslint + Prettier 的组合， Eslint 采用的是腾讯  AlloyTeam 创立的一套  ESLint   规则[eslint-config-alloy](https://github.com/AlloyTeam/eslint-config-alloy) ，自 2017 年 8 月发布第一个版本以来，不知不觉中已经收获到 `1.8k stars`，超过了 [eslint-config-google](https://github.com/google/eslint-config-google)，成为了世界上排名第三的  ESLint   规范。\n\n\n### \n\n\n### 设计理念\n\n- 样式相关的规则交给 [Prettier](https://prettier.io/) 管理\n- 传承 ESLint 的理念，帮助大家建立自己的规则\n\n### 样式相关的规则交给 [Prettier](https://prettier.io/) 管理\n\n\nPrettier 是一个代码格式化工具，相比于 ESLint 中的代码格式规则，它提供了更少的选项，但是却更加专业。\n\n\n如今 Prettier 已经成为前端项目中的必备工具，eslint-config-alloy 也没有必要再去维护 ESLint 中的代码格式相关的规则了，所以我们在 v3 版本中彻底去掉了所有 Prettier 相关的规则，用 ESLint 来检查它更擅长的逻辑错误。\n\n\n至于缩进要两个空格还是四个空格，末尾要不要分号，可以在项目的 `.prettierrc.js` 中去配置，当然也提供了一份推荐的 Prettier 配置供大家参考。\n\n\n### 传承 [ESLint 的理念](https://eslint.org/docs/about/#philosophy)，帮助大家建立自己的规则\n\n\n大家还记得 ESLint 是怎么打败 JSHint 成为最受欢迎的 js 代码检查工具吗？就是因为 ESLint 推崇的插件化、配置化，满足了不同团队不同技术栈的个性的需求。\n\n\n所以 eslint-config-alloy 也传承了 ESLint 的设计理念，不会强调必须要使用我们这套规则，而是通过文档、示例、测试、网站等方便大家参考 alloy 的规则，在此基础上做出自己的个性化。\n\n\n由于 React/Vue/TypeScript 插件的文档没有中文化（或中文的版本很滞后），所以 alloy 的文档很大程度上帮助了国内开发者理解和配置个性化的规则。\n\n\n实际上国内有很多团队或个人公开的 ESLint 配置，都参考了 alloy 的文档。\n\n\n### 为什么要重复造轮子\n\n\n其实我们团队最开始使用 airbnb 规则，但是由于它过于严格，部分规则还是需要个性化，导致后来越改越多，最后决定重新维护一套。经过两年多的打磨，现在 eslint-config-alloy 已经非常成熟与先进，也受到了公司内外很多团队的欢迎。\n\n\n### 为什么不用 standard\n\n\nstandard 规范认为大家不应该浪费时间在个性化的规范了，而应该整个社区统一一份规范。这种说法有一定道理，但是它是与 ESLint 的设计理念背道而驰的。\n\n\n### 相比于 airbnb 规则有什么优势\n\n- eslint-config-alloy 拥有官方维护的 vue、typescript、react+typescript 规则，相比之下 airbnb 的 vue 和 typescript 都是第三方维护的\n- 先进性，保证能够与时俱进，前面已经重点提到了\n- 方便个性化定制，包含中文讲解和网站示例\n\n### 你这个确实很好，我还是会选择 airbnb\n\n\n没关系，eslint-config-alloy 从设计理念上就相信不同团队不同项目可以有不同的配置，虽然你选择使用 airbnb，但是当你有个性化配置需求的时候，还是可以来我们[网站](https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN)上参考一下哦~\n\n\n## 开始配置\n\n\n### 安装相关依赖\n\n\n```shell\nnpm install --save-dev eslint@7.17.0 babel-eslint@10.1.0 vue-eslint-parser@7.3.0 eslint-config-alloy@3 eslint-config-prettier@7.1.0 eslint-plugin-prettier@3.3.1 eslint-plugin-vue@7.4.1 vue-eslint-parser@7.3.0\n```\n\n\n### 依赖版本\n\n\n```json\n{\n  \"eslint\": \"7.17.0\",\n  \"babel-eslint\": \"10.1.0\",\n  \"eslint-config-alloy\": \"^3.10.0\",\n  \"eslint-config-prettier\": \"^7.1.0\",\n  \"eslint-plugin-prettier\": \"^3.3.1\",\n  \"eslint-plugin-vue\": \"7.4.1\",\n  \"vue-eslint-parser\": \"^7.3.0\",\n}\n```\n\n\n> 注意：可以看到我使用的依赖基本都是最新的版本，原因是之前版本比较低，出现了很多找不到相关规则的 error。最后网上找了好久才发现 npm 默认安装的版本相对较低，导致出现了兼容性问题，直到升级到了高版本后才解决。\n\n\n### .eslintrc.js\n\n\n```javascript\nmodule.exports = {\n  root: true,\n  parserOptions: {\n    parser: 'babel-eslint',\n  },\n  env: {\n    browser: true,\n    es6: true,\n  },\n  extends: [\n    // https://github.com/AlloyTeam/eslint-config-alloy\n    'eslint-config-alloy/vue',\n    // https://github.com/vuejs/eslint-plugin-vue\n    'plugin:vue/essential',\n    // 结合.prettierrc.js中的规则来检查代码，这个一定要加！\n    'plugin:prettier/recommended',\n  ],\n  // required to lint *.vue files\n  plugins: ['vue'],\n  // add your custom rules here\n  rules: {\n    // 让prettier找出代码中的格式问题\n    'prettier/prettier': 'error',\n    // 这个顺序不知道为啥，明明不用配置时，.vue文件template标签在script前面默认应该也是可以的，但是我这边不行，所以自定义了一下\n    'vue/component-tags-order': [\n      'error',\n      {\n        order: [['template', 'script'], 'style'],\n      },\n    ],\n  },\n}\n```\n\n\n> 因为大部分规则都继承于eslint-config-alloy/vue，所以代码的语法错误已经不需要我自己去规定了，\n\n\n### .prettierrc.js\n\n\n```javascript\nmodule.exports = {\n  // 一行最多 120 字符\n  printWidth: 120,\n  // 使用 2 个空格缩进\n  tabWidth: 2,\n  // 不使用缩进符，而使用空格\n  useTabs: false,\n  // 行尾不需要有分号\n  semi: false,\n  // 使用单引号\n  singleQuote: true,\n  // 对象的 key 仅在必要时用引号\n  quoteProps: 'as-needed',\n  // jsx 不使用单引号，而使用双引号\n  jsxSingleQuote: false,\n  // 末尾需要有逗号\n  trailingComma: 'all',\n  // 大括号内的首尾需要空格\n  bracketSpacing: true,\n  // jsx 标签的反尖括号需要换行\n  jsxBracketSameLine: false,\n  // 箭头函数，只有一个参数的时候，也需要括号\n  arrowParens: 'always',\n  // 每个文件格式化的范围是文件的全部内容\n  rangeStart: 0,\n  rangeEnd: Infinity,\n  // 不需要写文件开头的 @prettier\n  requirePragma: false,\n  // 不需要自动在文件开头插入 @prettier\n  insertPragma: false,\n  // 使用默认的折行标准\n  proseWrap: 'preserve',\n  // 根据显示样式决定 html 要不要折行\n  htmlWhitespaceSensitivity: 'css',\n  // vue 文件中的 script 和 style 内不用缩进\n  vueIndentScriptAndStyle: false,\n  // 换行符使用 lf\n  endOfLine: 'lf',\n  // 格式化嵌入的内容\n  embeddedLanguageFormatting: 'auto',\n}\n```\n\n\n## 开发工具适配\n\n\n### WebStorm\n\n\n用 WebStorm 的前端 er 一定不会太差！！ 我个人一直非常推荐 WebStorm，用起来非常顺手！开箱即用，特别是 git 的使用，甩开 VSCode 几条街。 WebStorm 配合 ESLint 需要去设置中设置 Eslint 为自动装配，使其使用项目中的`.eslintrc.js`去检查代码。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FjT0UiCzAxSVIDI4wilba7UNQen0.png)\n\n\n### VSCode\n\n\n当然 VSCode 也是一款不错的开发工具，得力于丰富的插件市场，如果调教的够好，未来可能会比 WebStorm 更优秀。 VSCode 配合 ESLint 需要 ESLint 及 Prettier 等相关插件。\n\n\n### 在 VSCode 中使用\n\n\n在 VSCode 中，默认 ESLint 并不能识别 `.vue`、`.ts` 或 `.tsx` 文件，需要在「文件 => 首选项 => 设置」里做如下配置：\n\n\n```json\n{\n  \"eslint.validate\": [\n    \"javascript\",\n    \"javascriptreact\",\n    \"vue\",\n    \"typescript\",\n    \"typescriptreact\"\n  ]\n}\n```\n\n\n### 保存时自动修复 ESLint 错误\n\n\n如果想要开启「保存时自动修复」的功能，你需要配置 `.vscode/settings.json`：\n\n\n```json\n{\n  \"eslint.validate\": [\"javascript\", \"javascriptreact\", \"vue\", \"typescript\", \"typescriptreact\"],\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": true\n  },\n}\n```\n\n\n### VSCode 中的 autoFixOnSave 没有效果\n\n\n如果需要针对 `.vue`、`.ts` 和 `.tsx` 文件开启 ESLint 的 autoFix，则需要配置成：\n\n\n```json\n{\n  \"eslint.autoFixOnSave\": true,\n  \"eslint.validate\": [\n    \"javascript\",\n    \"javascriptreact\",\n    {\n      \"language\": \"vue\",\n      \"autoFix\": true\n    },\n    {\n      \"language\": \"typescript\",\n      \"autoFix\": true\n    },\n    {\n      \"language\": \"typescriptreact\",\n      \"autoFix\": true\n    }\n  ]\n}\n```\n\n\n## 结束\n\n\n至此，大部分的配置已经结束。\n\n\n结束也是开始，团队中开发规范的制定落地一定是慢慢打磨的结果。每个团队有每个团队自己的风格，未来更多的是需要针对各自团队搭配出一套适合自己的代码规范。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-01-15",
        "type": "Post",
        "slug": "ar658s",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了前端开发规范中使用的Eslint。作者介绍了自己和团队在使用Eslint过程中遇到的问题，最终选择了Eslint + Prettier的组合，并使用了腾讯AlloyTeam创立的一套Eslint规则。本文详细介绍了Eslint规则的设计理念和样式相关的规则交给Prettier来管理的思想，以及如何开始配置Eslint。同时，作者还介绍了如何适配WebStorm来使用Eslint进行代码检查。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "前端开发规范之Eslint",
        "category": "技术分享",
        "tags": [
          "Eslint",
          "代码规范"
        ],
        "status": "Archived",
        "urlname": "506adb06-6632-4133-be32-171a4ec0af21",
        "updated": "2023-08-26 15:22:00"
      },
      "body": "",
      "realName": "前端开发规范之Eslint",
      "relativePath": "/前端开发规范之Eslint.md"
    },
    {
      "id": "e7200c3e-ae64-4093-8ecc-4d249b091349",
      "doc_id": "e7200c3e-ae64-4093-8ecc-4d249b091349",
      "title": "e7200c3e-ae64-4093-8ecc-4d249b091349",
      "updated": 1693063320000,
      "body_original": "\n# 引言\n\n\n在 vue 中我们可以用`this.$router.go(-1)`返回上一个路由，但无法拿到上个路由的路由地址，这样就出现一个问题就是如果我上个路由是中转页面，作用就是跳到下个页面，这个时候的`this.$router.go(-1)`就不起作用，进入了死循环。 所以网上找了下一个比较好的办法就是利用路由守卫，维护自己的路由跳转记录。\n\n\n# 思路\n\n1. 实现一个`Vue`工具`history.js`，通过堆栈的方式维护页面跳转的历史记录，控制返回跳转。\n2. 扩展一个获取上个路由的方法。\n3. 在全局路由`router.js`中，实例化路由前，通过原型扩展`router`的`goBack()`方法\n4. 在`router`路由守卫`afterEach`的生命周期中存放历史记录。\n\n# 实现\n\n\n```javascript\n// src/utils/history.js\n\nconst History = {\n  _history: [], // 历史记录堆栈\n  install(Vue) {\n    // 提供Vue插件所需安装方法\n    Object.defineProperty(Vue.prototype, '$routerHistory', {\n      get() {\n        return History\n      },\n    })\n  },\n  push(path) {\n    // 入栈\n    this._history.push(path)\n  },\n  pop() {\n    this._history.pop()\n  },\n  canBack() {\n    return this._history.length > 1\n  },\n  lastHistory() {\n    return this._history.length > 1 ? this._history[this._history.length - 2] : '/'\n  },\n}\nexport default History\n```\n\n\n在路由实例化之前，扩展`back()`方法\n\n\n```javascript\n// src/router/index.js\n \nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport History from './utils/history';\n \nVue.use(Router);\nVue.use(History);\n \n// 实例化之前，扩展Router\nRouter.prototype.goBack = function () {\n this.isBack = true;\n this.back();\n}\n```\n\n\n在路由全局`afterEach`中记录跳转历史\n\n\n```javascript\n// src/router/index.js\n import History from './utils/history';\n// afterEach记录历史记录\nrouter.afterEach((to, from) => {\n   if (router.isBack) {\n     // 后退\n     History.pop();\n     router.isBack = false;\n     router.transitionName = 'route-back';\n   } else {\n     History.push(to.path);\n     router.transitionName = 'route-forward';\n   }\n})\n```\n\n\n在页面中使用\n\n\n```javascript\nif (this.$routerHistory.lastHistory().indexOf('/router') !== -1) {\n  this.$router.push({\n    path: '/',\n  })\n} else {\n  this.$router.goback()\n}\n```\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-02-01",
        "type": "Post",
        "slug": "hemk59",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何在Vue中维护路由跳转记录，以解决使用this.$router.go(-1)返回上一个路由时，无法拿到上个路由的路由地址的问题，并避免进入死循环。作者提出了通过路由守卫，利用堆栈的方式维护页面跳转的历史记录的思路，并给出了具体实现方法。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "在Vue中维护路由跳转记录",
        "category": "技术分享",
        "tags": [
          "Vue"
        ],
        "status": "Archived",
        "urlname": "e7200c3e-ae64-4093-8ecc-4d249b091349",
        "updated": "2023-08-26 15:22:00"
      },
      "body": "",
      "realName": "在Vue中维护路由跳转记录",
      "relativePath": "/在Vue中维护路由跳转记录.md"
    },
    {
      "id": "451fde56-fb4a-475d-a152-82ebe33d6a74",
      "doc_id": "451fde56-fb4a-475d-a152-82ebe33d6a74",
      "title": "451fde56-fb4a-475d-a152-82ebe33d6a74",
      "updated": 1693063320000,
      "body_original": "\n# 引言\n\n\n图片是大部分网页的重要组成部分，一般情况下，我们不会太关注这方面的问题，需要显示图片直接一个 `img` 标签搞定。但实际上，无论是对于提高加载速度，还是对于优化用户体验，优化图片都是一个重要的手段。 图片优化分成两个方面：\n\n1. 图片压缩。在保证视觉效果的情况下，减少图片的体积。这个很有效，1M 和 100K 的图片，肉眼看起来几乎差不多，但却省了 90% 的流量，大大提高了加载速度。\n2. 响应式图片。根据客户端的情况，选择最合适的图片返回给用户。用户是一个 500px 的设备，那么返回 1000px 的图给他就是浪费（假设物理像素和 CSS 像素是一比一）。\n\n# 图片压缩\n\n\n压缩的第一步是筛选出需要压缩的图片。如果图片本身就已经足够小了，那么再压缩的意义就不大。 而对于这些足够小的图片，我们就可以将其转换成雪碧图**（CssSprites）**或者`base64`编码来存储，而关于这两者的使用场景这里可以看一下这两篇文章（[不要滥用雪碧图 sprite](https://www.cnblogs.com/joyho/articles/3715275.html)和[玩转图片 Base64 编码](https://www.cnblogs.com/coco1s/p/4375774.html)）。\n\n\n## url-loader\n\n\n这里我采用的是 webpack 里的`url-loader`插件进行处理，对于小于 1kb 的图片，将其转换成`base64`编码进行存储。\n\n\n```javascript\n{\n  test: /\\.(png|jpe?g|gif|svg)$/,\n  use: [{\n      loader: \"url-loader\", // 它封装了file-loader，所以可以使用两个loader的全部配置属性\n      options: {\n        limit: 1024,\n        esModule: false,\n        outputPath: 'images' // 设置图片的输出路径\n      }\n    }\n  ]\n},\n```\n\n\n> 参数说明 > limit是转换成 Base64 的图片大小的零界点设置，单位为 Byte，小于该数值的将进行转换。 esModule是针对是否使用模块化框架的用户设定参数，默认为 true。如果项目中没有使用模块化框架，建议要将这个属性关闭，避免出现图片资源超过 limit，就变成[object Module]的问题。 outputPath图片输出路径，将优化后的图片统一输出到该路径。\n\n\n## image-webpack-loader\n\n\n接下来就是压缩大一点的图片了，使用[image-webpack-loader](https://github.com/tcoopman/image-webpack-loader)进行进一步处理。\n\n\n```javascript\n{\n  test: /\\.(png|jpe?g|gif|webp|svg)$/,\n  use: [{\n      loader: \"url-loader\",\n      options: {\n        limit: 1024,\n        esModule: false,\n        outputPath: 'images'\n      }\n    },\n    {\n      loader: 'image-webpack-loader',\n      options: {\n        mozjpeg: {\n          progressive: true,\n          quality: 70 // 数值越高，质量越好\n        },\n        optipng: {\n          // enabled: false,\n          OptimizationLevel: 4 // 默认是3\n        },\n        pngquant: {\n          enabled：false,\n          // quality: [0.75,0.95],\n          // speed: 4\n        },\n        gifsicle: {\n          interlaced: true, // 默认：false 隔行扫描gif进行渲染\n        },\n        // webp: {\n        //   quality: 75\n        // }\n      }\n    }\n  ]\n},\n```\n\n\n> 如文档所说，image-webpack-loader随附以下优化器，默认情况下会自动启用这些优化器：\n\n\t- [mozjpeg](https://github.com/imagemin/imagemin-mozjpeg) — 压缩 JPEG 图像\n\t- [optipng](https://github.com/kevva/imagemin-optipng) — 压缩 PNG 图像\n\t- [pngquant](https://github.com/imagemin/imagemin-pngquant) — 压缩 PNG 图像\n\t- [svgo](https://github.com/kevva/imagemin-svgo) — 压缩 SVG 图像\n\t- [gifsicle](https://github.com/kevva/imagemin-gifsicle) — 压缩 GIF 图像\n\n\t和可选的优化器：\n\n\t- [webp](https://github.com/imagemin/imagemin-webp) —将 JPG 和 PNG 图像压缩为 WEBP\n\n\t可以通过指定禁用默认优化器`optimizer.enabled: false`，并将其放在选项中即可启用可选优化器。\n\n\n### [imagemin-mozjpeg](https://github.com/imagemin/imagemin-mozjpeg)\n\n\nJPEG 根据显示方式的不同，分为两种：Progressive JPEG 和 Baseline JPEG。 Progressive JPEG 会先加载模糊的整张图片，然后变的越来越清晰。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fk_-bMzWW6DrevC_kqIB1zGKiRgZ.jpg)\n\n\n而 Baseline JPEG 会先清晰地加载图片的一部分，然后慢慢显示剩余的部分。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FjOjOygtOL0EeKqbIJJOrjot6rNB.jpg)\n\n\n从视觉效果来说，Progressive JPEG 自然更好一些。但它也有一些缺点，比如它的解码速度比 Baseline JPEG 要慢，占用的 CPU 时间更多。 如果是桌面浏览器，这点性能问题自然无所谓，但是如果是移动端，就不得不考虑。工程本来就是权衡的艺术。 默认情况下，MozJPEG 生成的是 Progressive JPEG，可以通过 [选项](https://github.com/imagemin/imagemin-mozjpeg#progressive) 调整。\n\n\n### [optipng](https://github.com/imagemin/imagemin-optipng)\n\n\n在研究文档的过程中发现一个有趣的问题，也可能是官网无意中的行为（真的吗？），官方文档为了说明其 API 中的禁用指定优化器功能`optimizer.enabled: false`，就在文档中写了这么一段代码：\n\n\n```javascript\n{\t\n// optipng.enabled: false will disable optipng\n\toptipng: {\n\t\tenabled: false,\n\t},\n  pngquant: {\n    quality: [0.65, 0.90],\n    speed: 4\n    }\n}\n```\n\n\n本来是一个举例说明，结果在我 google 的几乎所有用户的 webpack 配置中，大家都把`optipng`这个优秀的压缩工具给禁用了 QAQ。 实际上在压缩质量上来说，`optipng`是无损压缩，采用的是基于 LZ/Huffman 的 DEFLATE 算法，以减少图片 IDAT chunk 区域的数据来实现压缩图片，同样是无损压缩的工具还有[**pngcrush**](https://pngcrush.com/)**、**[**pngout**](https://www.oschina.net/translate/4-free-tools-to-optimize-and-compress-png-images-without-loosing-quality?print=)**、advpng**。 而[pngquant](https://github.com/kornelski/pngquant)和[**tinypng**](https://tinify.cn/)**、**[**ImageAlpha**](https://github.com/kornelski/ImageAlpha)**、**[**pngnq**](https://github.com/stuart/pngnq)等都是有损压缩，采用的是 quantization 算法，将 24 位的 PNG 图片转换为 8 位的 PNG 图片，减少图片的颜色数来实现图片压缩； 具体可以参考[Laya 图片压缩](https://www.jianshu.com/p/83d00a7e2a4b)对于各个压缩工具的对比情况。 但是呢，一般有损压缩的压缩率会大大高于无损压缩。就如 png 和 jpg 两者来说，png 格式可以进行无损压缩，质量好、支持透明但是体积大，jpg 的质量相对差一点但是体积很小，两者体积相差几乎在 70%以上。所以具体的权衡取舍还是看个人实际应用场景。\n\n\n### [pngquant](https://github.com/imagemin/imagemin-pngquant)\n\n\n正如上面所说，它是一个有损压缩，我这里为了演示，暂时禁用了它。\n\n\n> 参数说明(引用自Laya 图片压缩)： 1.quality参数的作用是保证图片经过优化处理后，图片质量的取值范围（0~1）。取值越小，表示压缩比率越大，同时的图片的质量也就越差。在测试过程中发现，当设置最低取值为 0.60 或 0.65 时，部分图片的质量会严重下降，因此最终选择了 0.70 作为最低值。 2.speed参数的设置决定了图片优化的执行速度，取值范围为 1~10，默认值为 4。其中 10 的执行速度最快，对应的压缩比率最小；而 1 的执行速度最慢，对应的压缩比率最大。在测试过程中发现，无论我设置哪一个值它们的执行时间都差不多，不过压缩比率确实 1 的最大，10 的最小。 实测效果： 在设置 quality 的取值范围为 0.70~0.95，以及 speed 为 4 的情况下，可以在尽可能不影响图片质量的前提下去缩减文件的大小。 在测试过程中，我们以 PNG-8 品质为 256 的图片为例，最终的图片输出可以降低 70%左右的大小（从 3.78KB 缩减到 1.13KB）。\n\n\n### [gifsicle](https://github.com/imagemin/imagemin-gifsicle)\n\n\ngifsicle 一共有 4 个参数配置，我一般常用的就 interlaced，即隔行扫描进行渲染，图片会自上而下渐进式加载。 在上文中提到的 Progressive 和 Baseline 的区别中，progressive 等同于`interlaced`，baseline 等同于 `not interlaced`，所以取舍自己决定。\n\n\n> 参数说明 optimizationLevel是优化级别，默认值为 1，取值范围在 1-3。优化级别的高低决定图片的质量，较高的级别需要更长的时间，但可能会有更好的效果。 文档中给出了 3 种取值所做的事： 1：仅存储每个图像的更改部分 2：还使用透明度进一步缩小文件。 3：尝试几种优化方法（通常速度较慢，有时效果更好）。 colors是颜色减少的高低设置，是将每个输出 GIF 中的不同颜色数量减少到指定数值或者更少，取值范围在 2-256 之间。 buffer是利用缓冲进行优化。\n\n\n### [webp](https://github.com/imagemin/imagemin-webp)\n\n\n最后来看一下该插件的可选优化器 Webp。\n\n\n> 参数说明 > quality质量参数，将品质因数设置在0和之间100。是最常用，大多数场景下也只需要调整这一个参数即可。 其他参数可以参考官方文档 > 注意，在实际的使用中，发现这里存在一个容易被忽视的坑。 > image-webpack-loader 里的 webp 优化器只是针对已有的 webp 文件进行质量上的优化（或者说就不起作用，如果有研究出来的大佬麻烦评论告知哈），并不能把前面的 png/jpg 转成 webp。官方文档有点误导到大家，导致许多图片优化的教程都把这个当成 webp 转换器，然而我实际试了下，并不能=.=。\n\n\n至于 webp 的优化过程，我将在下文`优雅地使用WebP图片`中详细介绍。\n\n\n# 响应式图片\n\n\n所谓响应式图片，关键就一点：**根据客户端的情况返回最适合客户端的图片**。\n\n\n那么，在准备部署响应式图片的时候，会存在哪些情况呢？\n\n- 是否希望根据客户端情况返回不同的图片 **内容**?\n- 是否希望根据客户端情况返回不同的图片 **格式**？\n- 是否希望根据客户端情况返回不同的图片 **尺寸** ？\n- 是否希望优化高 **分辨率** 设备的体验？\n\n在 `picture` 标签出来之前，这些只能通过 JS 来实现，不仅代码而且丑陋能力也不全。但是现在，针对这些问题，我们有了一个完整的优雅的解决方案。\n\n\n## picture 标签\n\n\n`picture` 是 HTML5 新引入的标签，基本用法如下。\n\n\n```html\n<picture>\n  <source srcset=\"a.jpg\">\n  <source srcset=\"b.jpg\">\n  <img src=\"c.jpg\" >\n</picture>\n```\n\n\n我们可以这样理解，`picture` 标签会从 `source` 中选择最合适的一个，然后将它的 URL 赋值给 `img`。对于不认识 `picture` 的旧浏览器，他们会忽略 `picture`，只渲染 `img`，一切都不会有问题。 注意：`**picture**`** 标签最后一定要包含一个 **`**img**`** 标签，否则，什么都不会显示。** 现在我们逐一来看 `picture` 是怎样解决上面的四个问题。\n\n\n## 动态内容\n\n\n根据客户端的情况，我们来返回完全不同的两张图。这个很简单，使用 `source` 标签的 `media` 属性即可。 如下代码会在小于 1024px 的时候显示 `img-center.jpg`，而在大于等于 1024px 的时候显示 `img-full.jpg`。\n\n\n```html\n<picture>\n  <source\n    media=\"(min-width: 1024px)\"\n    srcset=\"img-full.jpg\"\n  >\n  <img\n    src=\"img-center.jpg\" \n  >\n</picture>\n```\n\n\n## 动态尺寸\n\n\n如果希望浏览器能根据情况去请求不同尺寸的图片，我们需要提供两个信息：\n\n- 有哪些尺寸的图片\n- 图片显示的时候是什么尺寸\n\n下面的代码中，我们首先使用 `srcset` 属性指定有哪些图片，分别是图片名和图片的尺寸，这里注意单位不用 `px` 而是 `w`，用于表示图片的固有宽度。 `sizes` 属性告诉浏览器，这个图片在不同的条件下会是什么样的宽度。这个属性用于给到浏览器提示，并不会真正的指定 `img` 的宽度，我们还是需要另外使用 CSS 来指定。 这样，给定一个视口宽度，浏览器可以得知图片需要的宽度，然后根据 DPI 情况，在所有可选图片中选择最合适的一个。\n\n\n```html\n<img\n  src=\"img-400.jpg\"\n  sizes=\"(min-width: 640px) 60vw, 100vw\"\n  srcset=\"img-200.jpg 200w,\n      img-400.jpg 400w, \n      img-800.jpg 800w,\n      img-1200.jpg 1200w\"\n>\n```\n\n\n## 动态分辨率\n\n\n动态分辨率其实是动态尺寸的一种简化情况。 根据显示器的 DPI 返回同一张图片的不同分辨率版本可以直接利用 `img` 标签的 `srcset` 属性。 使用了如下的代码，浏览器会自动根据显示器的 DPI 来决定下载图片的哪个版本。 在低 DPI 设备上，例如桌面显示器，浏览器会使用 img-200.jpg，而在高 DPI 设备上，例如手机，浏览器会使用 img-400.jpg。\n\n\n```html\n<img\n  srcset=\"img-200.jpg, \n          img-300.jpg 1.5x,\n          img-400.jpg 2x\"\n  src=\"img-400.jpg\" \n>\n\n<style type=\"text/css\">\n  img {\n    width: 200px;\n  }\n</style>\n```\n\n\n当然，我们也可以组合这几个选项。\n\n- 视口 >= 1280px 时\n\t- 根据视口的具体宽度，返回不同尺寸的 _img-full_ 图片\n\t- 如果客户端支持 WebP，返回 WebP 格式\n- 视口 < 1280px 时\n\t- 根据视口的具体宽度，返回不同尺寸的 _img_ 图片\n- 如果客户端支持 WebP，返回 WebP 格式\n\n```html\n<picture>\n  <source\n    media=\"(min-width: 1280px)\"\n    sizes=\"50vw\"\n    srcset=\"img-full-200.webp 200w,\n        img-full-400.webp 400w,\n        img-full-800.webp 800w,\n        img-full-1200.webp 1200w,\n        img-full-1600.webp 1600w,\n        img-full-2000.webp 2000w\"\n    type=\"image/webp\"\n  >\n  <source\n    media=\"(min-width: 1280px)\"\n    sizes=\"50vw\"\n    srcset=\"img-full-200.jpg 200w,\n        img-full-400.jpg 400w,\n        img-full-800.jpg 800w,\n        img-full-1200.jpg 1200w,\n        img-full-1600.jpg 1800w,\n        img-full-2000.jpg 2000w\"\n  >\n\n  <source\n    sizes=\"(min-width: 640px) 60vw, 100vw\"\n    srcset=\"img-200.webp 200w,\n        img-400.webp 400w,\n        img-800.webp 800w,\n        img-1200.webp 1200w,\n        img-1600.webp 1600w,\n        img-2000.webp 2000w\"\n    type=\"image/webp\"\n  >\n  <img\n    src=\"img-400.jpg\"\n    sizes=\"(min-width: 640px) 60vw, 100vw\"\n    srcset=\"img-200.jpg 200w,\n        img-400.jpg 400w,\n        img-800.jpg 800w,\n        img-1200.jpg 1200w,\n        img-1600.jpg 1600w,\n        img-2000.jpg 2000w\"\n  >\n</picture>\n```\n\n\n这里强烈建议自己动手，结合 [placeholder.com](https://placeholder.com/) 网站，生成一些图片来测试。毕竟，纸上得来终觉浅。\n\n\n# 优雅地使用 WebP 图片\n\n\n在使用 webp 图片之前，我们先来了解下 webp 格式的图片到底是怎样的。 参考[将之前的项目图片进行了压缩](https://blog.liuguofeng.com/tag/%E5%9B%BE%E7%89%87)这篇文章的说明：\n\n\n[WebP](https://developers.google.com/speed/webp/)是 Google 推出的一种相对较新的格式，旨在通过编码[无损](https://en.wikipedia.org/wiki/Lossless_compression)和[有损](https://en.wikipedia.org/wiki/Lossy_compression)格式的图像来提供较小的文件大小，使其成为 JPEG 和 PNG 的绝佳替代品。 WebP 图像的视觉质量通常与 JPEG 和 PNG 相当，但通常文件大小要小得多。例如，当我将屏幕截图从上面转换为 WebP 时，我得到了一个 88 KB 的文件，其质量与 913 KB 的原始图像相当。**减少 90％！** 看一看下面三张图，你能分辨的出来吗？\n\n- [原始图片](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200419232154.png)\n- [优化后的图片](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200419232255.png)\n- [webp 图片](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/20200419232329.webp)\n\n就个人而言，视觉质量具有可比性，您所获得的节省很难被忽视。现在我们已经确定了尽可能使用 WebP 格式的价值，但是要注意是它不能完全取代 JPEG 和 PNG。根据\n\n\n[caniuse.com](https://caniuse.com/#search=WebP)\n\n\n提供的数据显示，虽然浏览器中的 WebP 支持已经很普遍了，但是需要足够高的版本号才可支持。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FiPJ5-pU_jPgEpBXUujF9z2nNzgs.png)\n\n\n截止撰稿日(2020-04-20)，只有 Safari 还在试验中，也算是即将支持 webp 图片了。至于 IE 浏览器嘛，emmmm….一言难尽\n\n\n数据显示，全球有 77.63%的用户使用支持 WebP 的浏览器。这意味着，通过提供 WebP 图像，您可以为 77.63%的客户提高网页速度。 所以，在客户端支持的情况下，我们应该尽可能地使用 WebP 格式。\n\n\n## picture 标签兼容优化\n\n\n### 优化流程\n\n\n在开始讲针对 webp 图片的优化前，我想先梳理下开发流程。 这里需要分两种情况：\n\n1. 全新网站的兼容优化\n2. 针对已有网站的兼容优化。\n\n如果是全新网站，而且设计师把各种图片都给到你了，那就完全不用担心图片转换问题，可以直接运用`picture`标签书写兼容格式，我这里就不再赘述。 而本文主要讲的就是在图片格式不全的情况下，甚至是对已有目录的静态网站进行优化时该怎样的开发流程。 第一个是顺序，在上面我尝试了在构建的同时利用 image-webpack-loader 可选的 webp 转换器，直接对现有 jpg/png 图片转换失败后，就暂时无法在缺失 webp 图片的情况下直接进行改造。 所以现在的思路是：\n\n1. 将现有的图片全部转换成 webp 格式。\n2. 将已有的 img 标签全部替换成 picture 标签。\n3. 利用 webpack 的 html-loader 识别出所有图片格式的路径后并将其 hash 重命名后打包到同一文件夹下。\n\n下面将具体展开谈一下针对单入口的页面和多入口的页面的处理。\n\n\n### 单入口页面\n\n\n对于单入口单页面的话，网站所用的图片原则上都只在一个文件夹。假设一个单页面网站的目录结构是这样的：\n\n\n```c#\n|--dist  \t\t\t\t\t\t\t\t//打包后的路径\n|--src  \t\t\t\t\t\t\t\t//项目源代码目录\n|  |--css  \t\t\t\t\t\t\t//存放css样式表\n|  |--images  \t\t\t\t\t//存放网页所需的所有图片\n|  |--js  \t\t\t\t\t\t\t//存放javaScript代码\n|  |--index.html  \t\t\t//网页入口\n|--webpack.config.js  \t//webpack的配置文件\n|--package.json  \t\t\t\t//项目元数据，依赖包等信息\n|--package-loack.json   //依赖包具体版本信息\n|--webp.js   \t\t\t\t\t\t//下文中提到的转换图片的js\n```\n\n\n我们可以使用`imagemin-webp`官方文档所提供的方法：使用了`imagemin`和`imagemin-webp`来转换 jpg/png。 在根目录中新建`webp.js`文件\n\n\n```javascript\nconst imageminWebp = require('imagemin-webp')\nconst imagemin = require('imagemin');\n\nimagemin(['src/images/*.{jpg,png}'], {\n  destination: \"src/images\",\n  plugins: [\n    imageminWebp({\n      quality: 80\n    }),\n  ],\n})\n```\n\n\n这样就可以在根目录运行`node webp.js`，把项目中的所有 jpg/png 转成 webp 格式图片并存放到原图片目录下，然后就可以对原有 img 标签进行改造，加上 webp 格式的图片。\n\n\n### 多入口页面\n\n\n对于让人头疼的多入口页面来说，配置起来就复杂的多。首先我们先约定一下多入口页面的目录结构。\n\n\n### 目录结构\n\n\n多入口也就意味着多出口，不但 html 网页可能分布在不同的文件夹下，不同网页所需的图片/css/js 也被存放到对应网页的不同文件夹下。假设一个多入口页面的目录结构如下：\n\n\n```c#\nwebpack\n|--dist  \t\t\t\t\t\t\t\t//打包后的路径\n|--src  \t\t\t\t\t\t\t\t//项目源代码目录\n|  |--common\t\t\t\t\t\t//存放各个页面都有可能用到的组件库（基本不变更）\n|  |  |--jquery.min.js  \n|  |  |--swiper.min.js  \n|  |--css  \t\t\t\t\t\t\t//存放css样式表\n|  |  |--index.scss  \t\t//index页面所需的样式表\n|  |  |--about.scss  \t\t//about页面所需的样式表\n|  |  |--common.scss  \t//通用样式表\n|  |--images  \t\t\t\t\t//存放网页所需的所有图片\n|  |  |--index  \t\t\t\t//index页面所需的图片\n|  |  |  |--header1.png  \n|  |  |  |--banner1.png  \n|  |  |  |--a1.jpg  \t  \n|  |  |  |--...\n|  |  |--about  \t\t\t\t//about页面所需的图片\n|  |  |  |--header1.png  \n|  |  |  |--banner1.png  \n|  |  |  |--a1.jpg  \t  \n|  |  |  |--...\n|  |  |--common  \t\t\t\t//可复用的图片\n|  |  |  |--logo.png  \n|  |  |  |--footer.png  \n|  |  |  |--wechat.svg  \t  \n|  |  |  |--...  \n|  |--js  \t\t\t\t\t\t\t//存放javaScript代码\n|  |  |--index.js  \t\t\t//index页面的js文件\n|  |  |--about.js  \t\t\t//index页面的js文件\n|  |  |--common.js  \t\t//可复用的js\n|  |--index.html  \t\t\t//网站首页html\n|  |--about.html  \t\t\t//关于网站html\n|--webpack.config.js  \t//webpack的配置文件\n|--package.json  \t\t\t\t//项目元数据，依赖包等信息\n|--package-loack.json   //依赖包具体版本信息\n```\n\n\n可以看出，较为复杂的就是图片了。由于多个页面所需的图片数量非常多，在开发的过程中很难保证图片起名的不重复，所以最理想的就是放在不同文件夹下了。 但是新的问题出现了：webpack 常用于将不同文件都打包至同一目录下，如果打包后命名重复导致文件被覆盖了怎么办？ 当然，webpack 也给出了几乎完美的解决方案：将文件进行 hash 重命名后输出，这样就几乎不会导致重名覆盖问题的发生。 可是，又一个棘手的问题发生了： 上文我们也说了，我们是要在打包前就将图片转换成 webp 格式。这样改造过程中，静态资源的文件名也不会变，路径也是各自的路径，开发过程才能方便起来。 那么，既然用到的图片会重名，所以将图片整体拿出来手动转换后再丢回到各自文件夹的方法也不可取。最理想的就是各自转换各自的目录，所以第一个办法就是：\n\n- 用单页面转换的方式，每次改一下输入输出路径，对每个存放图片的文件夹单独转换。\n\n怎么说呢，可以是可以的，但是既然都用了 webpack 自动化打包了，我们应该减少手动操作文件的次数。而且后期维护起来，那是相当的麻烦。当你有更多的页面，每次需求方更新图片的时候，我们都得手动操作一次，费力又费时间。\n\n\n### gulp\n\n\n于是乎我投向了 gulp 的怀抱，gulp 在操作文件的过程中，借鉴了 linux 的管道思想，可以将上个的输出作为下一个的输入。于是，基于 gulp 的自动化转换程序诞生了： 首先在根目录建立 gulpfile.js 文件，并安装好所需的依赖。\n\n\n> 注意，gulp 需要安装两次\n\n\n```javascript\nnpm i gulp -D //保证依赖被安装到node_modules下\nnpm i gulp -g //保证直接在命令行使用gulp命令时不会报错\n```\n\n\n```javascript\nconst gulp = require('gulp');\nconst fs = require('fs');\nconst merge = require('merge-stream');\nconst path = require('path');\nconst webp = require('gulp-webp');\n// 获取文件夹\nfunction getFolders(dir) {\n    return fs.readdirSync(dir)\n        .filter(function (file) {\n            return fs.statSync(path.join(dir, file)).isDirectory();\n        });\n}\n\n// 需要转换的文件路径，我这里设置为根目录下的src目录\nconst scriptsPath = path.resolve(__dirname, 'src')\n\nfunction imagesToWebp() {\n    const folders = getFolders(scriptsPath);\n    const tasks = folders.map(function (folder) {\n        console.log(folder)\n      \t//依次输出：\n      \t//common\n\t\t\t\t//css\n\t\t\t\t//images\n\t\t\t\t//js\n      \t// /**/*.{jpg,png}是找到src下所有层级的jpg/png图片\n        return gulp.src(path.join(scriptsPath, folder, '/**/*.{jpg,png}'))\n            .pipe(webp()) //使用webp插件进行转换（默认会保留原图片）\n            .pipe(gulp.dest(scriptsPath + folder)); //输出到各自的文件夹下\n    })\n    return merge(tasks); //合并gulp流\n}\n\nexports.webp = gulp.series(\n    imagesToWebp\n)\n```\n\n\n大功告成！这样我们就可以在命令行使用`gulp webp`命令进行图片转换了。 在拿到了所有 webp 文件后，就可以使用 picture 标签进行改造了。\n\n\n```html\n<picture>\n  <source srcset=\"./images/index/a1.webp\" type=\"image/webp\">\n  <img src=\"./images/index/a1.png\">\n</picture>\n\n<picture>\n  <source srcset=\"./images/about/a1.webp\" type=\"image/webp\">\n  <img src=\"./images/about/a1.png\">\n</picture>\n```\n\n\n> 注意： 记得在 webpack.config.js 中使用 html-loader 时，将 source 标签下的 srcset 属性加入 attrs，否则 html-loader 将无法识别 source 标签中的图片路径。\n\n\n```json\n{\n  test: /\\.(html)$/,\n  use: {\n    loader: 'html-loader',\n    options: {\n      root: path.resolve(__dirname, 'src'),\n      attrs: ['img:src', 'img:data-src', 'source:srcset']\n    }\n  }\n}\n```\n\n\n对于 webpack 中关于多页面的其他配置，我将在其他文章中详细介绍并分享我的代码，请持续关注，谢谢～\n\n\n## 利用 cdn 服务自动判断\n\n\n目前，有些图片 cdn 服务可以开启自动兼容 webp 的模式，即支持 webp 的浏览器则将原图转换为 webp 图片并返回，否则直接返回原图。实现这个功能的原理是，根据浏览器发起的请求头中的 Accept 属性中是否包含 webp 格式来判断：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fv3x2-3h24vcrUFFv5rxfxcMkRKo.png)\n\n\n有则说明浏览器支持 webp 格式，这对开发者来说可能是最简单的兼容方案，但是依赖于后端服务。\n\n\n# 参考\n\n1. [将之前的项目图片进行了压缩](https://blog.liuguofeng.com/tag/%E5%9B%BE%E7%89%87)\n2. [谈谈 Web 应用中的图片优化技巧及反思](https://juejin.im/post/5d4979cc5188255b3e4126ae#heading-10)\n3. [Laya 图片压缩](https://www.jianshu.com/p/83d00a7e2a4b)\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2020-04-20",
        "type": "Post",
        "slug": "ulvcm5",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何使用webpack的url-loader和image-webpack-loader插件来优化图片。其中，url-loader可以将小于1kb的图片转换成base64编码进行存储，而image-webpack-loader可以对大一点的图片进行压缩。还介绍了各个优化器的作用，如mozjpeg、optipng、pngquant等，并提供了相应的配置参数说明。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "Webpack配置-图片优化",
        "category": "技术分享",
        "tags": [
          "Webpack"
        ],
        "status": "Archived",
        "urlname": "451fde56-fb4a-475d-a152-82ebe33d6a74",
        "updated": "2023-08-26 15:22:00"
      },
      "body": "",
      "realName": "Webpack配置-图片优化",
      "relativePath": "/Webpack配置-图片优化.md"
    },
    {
      "id": "701f9876-9f7a-4f28-b225-7077e45cfeab",
      "doc_id": "701f9876-9f7a-4f28-b225-7077e45cfeab",
      "title": "701f9876-9f7a-4f28-b225-7077e45cfeab",
      "updated": 1693063320000,
      "body_original": "\n# 前言\n\n\n其实之前就有疑惑过,npm 依赖之间是怎么处理的,怎么才能相互依赖而又不重复，怎么处理不同版本依赖的问题等等，乱成一锅粥。出现错误要怎么解决? 哪些警告要额外注意一下?今天就来研究下。\n\n\n# npm 安装机制\n\n\n## A 和 B 同时依赖 C，这个包会被安装在哪里呢？\n\n\n假如有 A 和 B 两个包，两个包都依赖 C 这个包，npm 2 会依次递归安装 A 和 B 两个包及其子依赖包到 node_modules 中。执行完毕后，我们会看到 `./node_modules` 这层目录只含有这两个子目录：\n\n\n```text\nnode_modules/\n├─┬ A\n│ ├── C\n├─┬ B\n│ └── C\n```\n\n\n如果使用 npm 3 来进行安装的话，`./node_modules` 下的目录将会包含三个子目录：\n\n\n```text\nnode_modules/\n├─┬ A\n├─┬ B\n├─┬ C\n```\n\n\n为什么会出现这样的区别呢？这就要从 npm 的工作方式说起了：\n\n\n## npm 2 和 npm 3 模块安装机制的差异\n\n\n虽然目前最新的 npm 版本是 npm 7，但 npm 2 到 npm 3 的版本变更中实现了目录打平，与其他版本相比差别较大。因此，让我们具体看下这两个版本的差异。\n\n\nnpm 2 在安装依赖包时，采用简单的递归安装方法。执行\n\n\n```text\nnpm install\n```\n\n\n后，npm 根据 dependencies 和 devDependencies 属性中指定的包来确定第一层依赖，npm 2 会根据第一层依赖的子依赖，递归安装各个包到子依赖的 node_modules 中，直到子依赖不再依赖其他模块。执行完毕后，我们会看到\n\n\n```text\n./node_modules\n```\n\n\n这层目录中包含有我们 package.json 文件中所有的依赖包，而这些依赖包的子依赖包都安装在了自己的 node_modules 中 ，形成类似于下面的依赖树：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FppqBFUwkpGrtMkNTny7Uyg-k99C.png)\n\n\n这样的目录有较为明显的好处： 1）层级结构非常明显，可以清楚的在第一层的 node_modules 中看到我们安装的所有包的子目录； 2）在已知自己所需包的名字以及版本号时，可以复制粘贴相应的文件到 node_modules 中，然后手动更改 package.json 中的配置； 3）如果想要删除某个包，只需要简单的删除 package.json 文件中相应的某一行，然后删除 node_modules 中该包的目录； 但是这样的层级结构也有较为明显的缺陷，当我的 A，B，C 三个包中有相同的依赖 D 时，执行\n\n\n```text\nnpm install\n```\n\n\n后，D 会被重复下载三次，而随着我们的项目越来越复杂，node_modules 中的依赖树也会越来越复杂，像 D 这样的包也会越来越多，造成了大量的冗余；在 windows 系统中，甚至会因为目录的层级太深导致文件的路径过长，触发文件路径不能超过 280 个字符的错误；\n\n\n为了解决以上问题，npm 3 的 node_modules 目录改成了更为扁平状的层级结构，尽量把依赖以及依赖的依赖平铺在 node_modules 文件夹下共享使用。\n\n\n## npm 3 对于同一依赖的不同版本会怎么处理呢？\n\n\nnpm 3 会遍历所有的节点，逐个将模块放在 node_modules 的第一层，当发现有重复模块时，则丢弃， 如果遇到某些依赖版本不兼容的问题，则继续采用 npm 2 的处理方式，前面的放在 node_modules 目录中，后面的放在依赖树中。举个例子： A，B，依赖 D(v 0.0.1)，C 依赖 D(v 0.0.2):\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FvZO2pj5R9JpsDppNn2DYZf1FUJL.png)\n\n\n但是 npm 3 会带来一个新的问题：由于在执行 npm install 的时候，按照 package.json 里依赖的顺序依次解析，上图如果 C 的顺序在 A，B 的前边，node_modules 树则会改变，会出现下边的情况：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FrLv9LO5MkYZIBkL3Im9UhLVBupA.png)\n\n\n由此可见，npm 3 并未完全解决冗余的问题，甚至还会带来新的问题。\n\n\n# 为什么会出现 package-lock.json 呢？\n\n\n## package.json 的不足之处\n\n\nnpm install 执行后，会生成一个 node_modules 树，在理想情况下， 希望对于同一个 package.json 总是生成完全相同 node_modules 树。在某些情况下，确实如此。但在多数情况下，npm 无法做到这一点。有以下两个原因： 1）某些依赖项自上次安装以来，可能已发布了新版本 。比如：A 包在团队中第一个人安装的时候是 1.0.5 版本，package.json 中的配置项为 `A: '^1.0.5'` ；团队中第二个人把代码拉下来的时候，A 包的版本已经升级成了 1.0.8，根据 package.json 中的[semver-range version](http://semver.org/) 规范，此时第二个人 npm install 后 A 的版本为 1.0.8； 可能会造成因为依赖版本不同而导致的 bug； 2）针对 1）中的问题，可能有的小伙伴会想，把 A 的版本号固定为 `A: '1.0.5'` 不就可以了吗？但是这样的做法其实并没有解决问题， 比如 A 的某个依赖在第一个人下载的时候是 2.1.3 版本，但是第二个人下载的时候已经升级到了 2.2.5 版本，此时生成的 node_modules 树依旧不完全相同 ，固定版本只是固定来自身的版本，依赖的版本无法固定。\n\n\n## 针对 package.json 不足的解决方法\n\n\n为了解决上述问题以及 npm 3 的问题，在 npm 5.0 版本后，npm install 后都会自动生成一个 package-lock.json 文件 ，当包中有 package-lock.json 文件时，npm install 执行时，如果 package.json 和 package-lock.json 中的版本兼容，会根据 package-lock.json 中的版本下载；如果不兼容，将会根据 package.json 的版本，更新 package-lock.json 中的版本，已保证 package-lock.json 中的版本兼容 package.json。\n\n\n## package-lock.json 文件的结构\n\n\npackage-lock.json 文件中的 name、version 与 package.json 中的 name、version 一样，描述了当前包的名字和版本，dependencies 是一个对象，该对象和 node_modules 中的包结构一一对应，对象的 key 为包的名称，值为包的一些描述信息， 根据 [package-lock-json 官方文档](https://docs.npmjs.com/configuring-npm/package-lock-json.html#requires)，主要的结构如下：\n\n- `version` ：包版本，即这个包当前安装在 `node_modules` 中的版本\n- `resolved` ：包具体的安装来源\n- `integrity` ：包 `hash` 值，验证已安装的软件包是否被改动过、是否已失效\n- `requires` ：对应子依赖的依赖，与子依赖的 `package.json` 中 `dependencies` 的依赖项相同\n- `dependencies` ：结构和外层的 `dependencies` 结构相同，存储安装在子依赖 `node_modules` 中的依赖包\n\n需要注意的是，并不是所有的子依赖都有 `dependencies` 属性。只有当子依赖的依赖和当前已安装在根目录的 `node_modules` 中的依赖冲突之后，才会有这个属性。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FjshiUK2y-rCBSHN8bC4cWnmNrve.png)\n\n\n## package-lock.json 文件的作用\n\n- 在团队开发中，确保每个团队成员安装的依赖版本是一致的，确定一棵唯一的 node_modules 树；\n- node_modules 目录本身是不会被提交到代码库的，但是 package-lock.json 可以提交到代码库，如果开发人员想要回溯到某一天的目录状态，只需要把 package.json 和 package-lock.json 这两个文件回退到那一天即可 。\n- 由于 package-lock.json 和 node_modules 中的依赖嵌套完全一致，可以更加清楚的了解树的结构及其变化。\n- 在安装时，npm 会比较 node_modules 已有的包，和 package-lock.json 进行比较，如果重复的话，就跳过安装 ，从而优化了安装的过程。\n\n# 依赖的区别与使用场景\n\n\nnpm 目前支持以下几类依赖包管理包括\n\n- dependencies\n- devDependencies 开发环境依赖包\n- optionalDependencies 可选择的依赖包\n- peerDependencies 同等依赖\n- bundledDependencies 捆绑依赖包\n\n### dependencies\n\n\n无论在开发环境还是在生产环境都必须使用的依赖，是最常用的依赖包管理对象，例如 React，typescript，Axios 等，通过 `npm install XXX` 下载的包都会默认安装在 dependencies 对象中，也可以使用 `npm install XXX -S` 下载 dependencies 中的包； 插件下 dependencies 中的依赖会在安装插件时全部安装\n\n\n### devDependencies\n\n\n指可以在开发环境使用的依赖，例如 eslint，@types 类型定义文件等，通过 `npm install XXX -D` 下载的包都会在 devDependencies 对象中； dependencies 和 devDependencies 最大的区别是在打包运行时，执行  `npm install`  时默认会把所有依赖全部安装，但是如果使用  `npm install --production`  时就只会安装 dependencies 中的依赖，如果是 node 服务项目，就可以采用这样的方式用于服务运行时安装和打包，减少包大小。\n\n\n### optionalDependencies\n\n\n指的是可以选择的依赖，当你希望某些依赖即使下载失败或者没有找到时，项目依然可以正常运行或者 npm 继续运行的时，就可以把这些依赖放在 optionalDependencies 对象中. 但是 optionalDependencies 会覆盖 dependencies 中的同名依赖包，所以不要把一个包同时写进两个对象中。\n\n\noptionalDependencies 就像是我们的代码的一种保护机制一样，如果包存在的话就走存在的逻辑，不存在的就走不存在的逻辑。 eg: 图片压缩插件在 windows 和 mac 上的问题\n\n\n### peerDependencies\n\n\n用于指定你当前的插件兼容的宿主必须要安装的包的版本，这个是什么意思呢？举个例子 🌰：我们常用的 react 组件库 [ant-design@4.x](https://ant.design/index-cn) 的 package.json 中的配置如下：\n\n\n```json\n{\n  \"peerDependencies\": {\n    \"react\": \">=16.9.0\",\n    \"react-dom\": \">=16.9.0\"\n  }\n}\n```\n\n\n假设我们创建了一个名为 project 的项目，在此项目中我们要使用 [ant-design@4.x](https://ant.design/index-cn) 这个 UI 库，此时我们的项目就必须先安装 React >= 16.9.0 和 React-dom >= 16.9.0 的版本。\n\n\n> 注意: 在 npm 2 中，当我们下载\n\n\n\t[ant-design@4.x](https://ant.design/index-cn)\n\n\n\t[ant-design@4.x](https://ant.design/index-cn)\n\n\n\t![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FtJGli5eh8Ec5L4Y71ZKCyXD4CB4.png)\n\n\n### 适用场景\n\n\n通常是在插件开发的场景下，你的插件需要某些依赖的支持，但是你又没必要去安装，因为插件的宿主会去安装这些依赖，你就可以用 peerDependencies 去声明一下需要依赖的插件和版本，如果出问题 npm 就会有警告来提醒使用者去解决版本冲突问题。\n\n\n### bundledDependencies\n\n\n捆绑依赖。这个依赖项与其他几种依赖项不同，他不是一个键值对的对象，而是一个数组，数组里是包名的字符串，例如：\n\n\n```json\n{ \n  \"name\": \"project\", \n  \"version\": \"1.0.0\", \n  \"bundleDependencies\": [ \n    \"axios\",  \n    \"lodash\" \n  ] \n}\n```\n\n\n当使用 npm install 时,这两个依赖和所需要的依赖都会安装. 当使用 npm pack 的方式来打包时，上述的例子会生成一个 project-1.0.0.tgz 的文件，在使用了 bundledDependencies 后，打包时会把 Axios 和 Lodash 这两个依赖一起放入包中，之后有人使用 `npm install project-1.0.0.tgz` 下载包时，Axios 和 Lodash 这两个依赖也会被安装。\n\n\n需要注意的是安装之后 Axios 和 Lodash 这两个包的信息在 dependencies 中，并且不包括版本信息。\n\n\n```text\n\"bundleDependencies\": [\n    \"axios\",\n    \"lodash\"\n  ],\n\"dependencies\": {\n  \"axios\": \"*\",\n  \"lodash\": \"*\"\n}\n\n```\n\n\n### 适用场景\n\n\n依赖包通常是从 npm 仓库中安装的。而 bundledDependencies 这是用在以下几个场景:\n\n- 复用不是来自 npm 仓库或已修改的第三方库\n- 将自己的项目作为模块复用\n- 与模块一起发布一些文件\n\n这样就不必创建和维护自己的 npm 插件，但可以获得与 npm 包相同的结果。\n\n\n### 不适用场景\n\n\n如果是处理软件版本锁定问题, package-lock.json 是更好的选择.\n\n\n# 实际应用\n\n\n## 问题出现\n\n\n最近有个项目在初始化的过程中，加入了公司统一的 Eslint 管理，需要用到两个依赖包。\n\n\n```text\n\"devDependencies\": {\n  \"@yunke/eslint-config-react-ts\": \"^1.0.0\",\n  \"@yunke/yunke-setting-plugin\": \"^1.1.0\"\n}\n```\n\n\n但是在 Windows 电脑上，会报 `import/order` 的 Eslint 顺序错误。在 Mac 电脑上则没有出现这种情况。在研究依赖包的时候发现，`eslint-plugin-import` 的版本出了点问题。在 `@yunke/eslint-config-react-ts` 的配置中，需要的版本是 `>=2.22.1`。而实际在项目中被安装的版本确是 `2.20.1`。导致版本安装不对的原因则是因为项目中使用的 `react-scripts` 插件指定需要 `2.20.1` 的版本。但是疑惑点来了，为什么两个插件需要的插件版本不一样却只安装一个呢。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FjJR8rxYO7ZQRtx_seEzGDzhqD_C.png)\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FjF-sSjh9dvabFPWjnO7QPEvH3SI.png)\n\n\n## 探究\n\n\n随后仔细研究了`@yunke/eslint-config-react-ts`和`react-scripts`的`package.json`，发现一个重要的问题，也是上面提到过的，`@yunke/eslint-config-react-ts`所依赖的`eslint-plugin-import`插件是放在 peerDependencies 中定义的，而在 npm3 以上的版本中，不会自动下载这里面的依赖，而是会以 warning 的方式提示出来，需要宿主插件手动在`package.json`中定义并安装，而`react-scripts`所依赖的`eslint-plugin-import`插件是放在 dependencies 中的，所以会被下载下来，不需要定义。\n\n\n### @yunke/eslint-config-react-ts 的依赖\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FtlEPncJ3tAO00_vP9VfGTVAjdg1.png)\n\n\n### react-scripts 的依赖\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FiROfU6ox--W3IX0HgXHo4GQtDY4.png)\n\n\n值得注意的是，npm 在分析依赖的时候，会把依赖拍平，但是像这同一依赖的不同版本的处理会像上面分析的一样，react-scripts 会讲自己所依赖的版本放在自己的 node_modules 中，而@yunke/eslint-config-react-ts 说要求的在宿主上安装这个依赖后，则会直接放到宿主的 node_modules 中去。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FvZO2pj5R9JpsDppNn2DYZf1FUJL.png)\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fm7ernHzfWVFRckdzn5Tjt3WBKL9.png)\n\n\n## 解决办法\n\n\n在宿主插件，也就是项目中的`package.json`中重新引入`eslint-plugin-import`插件并定义版本号为`>=2.22.1`即可，重新`yarn install`后就会安装符合`@yunke/eslint-config-react-ts`所需要的版本，至此错误消失。\n\n\n## 新的疑问\n\n\n其实在`yarn install`时，不单单是提示`eslint-plugin-import`的版本不对，还有一些其他的插件的版本也不符合要求，例如 typescript 的版本过低等问题。这里就引申出一个问题，到底哪些依赖需要放到 peerDependencies 中，哪些依赖需要放到 dependencies 中，这也是一个值得思考的问题。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FtJGli5eh8Ec5L4Y71ZKCyXD4CB4.png)\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-05-08",
        "type": "Post",
        "slug": "zqsrm2",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文主要介绍了 npm 依赖管理的机制，包括 npm 安装机制、npm 2 和 npm 3 模块安装机制的差异、npm 3 对于同一依赖的不同版本的处理、package-lock.json 文件的结构和作用等内容。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "探究npm 依赖管理",
        "category": "技术分享",
        "tags": [
          "Npm"
        ],
        "status": "Archived",
        "urlname": "701f9876-9f7a-4f28-b225-7077e45cfeab",
        "updated": "2023-08-26 15:22:00"
      },
      "body": "",
      "realName": "探究npm 依赖管理",
      "relativePath": "/探究npm 依赖管理.md"
    },
    {
      "id": "530f1e97-1df5-45a3-a1e4-4b0fa0ef957d",
      "doc_id": "530f1e97-1df5-45a3-a1e4-4b0fa0ef957d",
      "title": "530f1e97-1df5-45a3-a1e4-4b0fa0ef957d",
      "updated": 1693063320000,
      "body_original": "\n[原文链接](http://www.dein.fr/2015-02-18-maslows-pyramid-of-code-review.html)\n\n\n马斯洛金字塔是美国心理学家马斯洛提出的一个心理学模型，认为人类的心理需求从下往上分为 5 个层次，一旦实现了下层的需求，就会追求上一层的需求。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fsf3MQRcEQsb-ZJ2yZl4r64rucYf.jpeg)\n\n\n这五个层次依次是：生理需求、安全需求、社交需求、尊严需求、自我实现。 代码质量也可以用金字塔模型表示，从下往上有五个层次。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FkmB_FgFNpCt2MD6Gls4vx0lhrNH.jpeg)\n\n\n**第一层：正确**\n\n\n（Correct） 代码是否执行预期的工作？是否考虑了边缘情况？是否经过充分测试？是否有可维护性？是否有可接受的性能？\n\n\n**第二层：安全**\n\n\n（Secure） 代码是否存在漏洞？数据是否安全存储？个人识别信息（PII）是否得到正确处理？是否对用户的输入进行了全面的验证？\n\n\n**第三层：可读**\n\n\n（Readable） 代码是否易于阅读和理解？测试足够简洁吗？变量、函数、类的名称是否适当？使用领域模型是否可以清晰地映射现实世界，以减少认知负担？是否使用一致的编码风格约定？\n\n\n**第四层：优雅**\n\n\n（Elegant） 代码是否利用了众所周知的编程模式？能否更简单简洁地实现所需的功能？你会为编写这些代码感到兴奋吗？你为这些代码感到骄傲吗？\n\n\n**第五层：利他主义**\n\n\n（Altruist） 别人能否从这些代码学到东西？这些代码是否会激励其他工程师进行改进？它是否会让世界变成一个更好的地方？\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-05-16",
        "type": "Post",
        "slug": "xelwzw",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "代码的马斯洛金字塔",
        "category": "技术分享",
        "tags": [
          "代码规范"
        ],
        "status": "Archived",
        "urlname": "530f1e97-1df5-45a3-a1e4-4b0fa0ef957d",
        "updated": "2023-08-26 15:22:00"
      },
      "body": "",
      "realName": "代码的马斯洛金字塔",
      "relativePath": "/代码的马斯洛金字塔.md"
    },
    {
      "id": "cbd49264-58c3-4052-b267-0ec9109cb24d",
      "doc_id": "cbd49264-58c3-4052-b267-0ec9109cb24d",
      "title": "cbd49264-58c3-4052-b267-0ec9109cb24d",
      "updated": 1693063260000,
      "body_original": "\n# 引言\n\n\n在`docker`容器化越来越流行的今天，安装各种环境和软件都越来越方便。然而我的腾讯云服务器却依旧使用的是较为原始的`yum`等安装方式，后来换成了宝塔一键式安装后，网站也稳定运行着，也没有再去管了。然而今天发现云服务的内存占用都快满了，然而我还想安装一些其他环境。所以为了进一步榨干云服务的性能，我选择重装系统，全部利用`docker`的方式去安装各种环境。不过今天只记录下安装`nginx`及其一些配置时爬过的坑。\n\n\n我的博客`blog.letttgaco.cn`，是部署在`GitHub Pages`上的，但是域名备案时是备案的`www.letttgaco.cn`，所以我是想利用`nginx`的重定向功能，将`www.letttgaco.cn`重定向到我的博客去。\n\n\n# 思路\n\n\n在 dns 解析中，`blog.letttgaco.cn`已经指向的是`github`（GitHub Pages 已设置强制 HTTPS 访问），现在需要将`www.letttgaco.cn`的`dns`解析指向云服务器上，然后由云服务器上部署的 Nginx 去监听 80 端口和 443 端口，将其重定向/转发至`https://blog.letttgaco.cn`。\n\n\n# 安装前准备\n\n\n我的云服务器为腾讯云服务器，系统为 CentOS7.6(64 位)，自带 50G 系统盘。 在`dns`解析中将`www.letttgaco.cn`指向云服务器的对外 IP 地址。\n\n\n# 安装并配置 Nginx\n\n\n## 目录结构\n\n\n```text\n|--root                   // root（家）目录\n|  |--app                 // 各个程序所在目录\n|  |  |--nginx            // 各个程序所在目录\n|  |  |  |--conf  \t\t\t\t\t\t\t\n|  |  |  |  |--nginx.conf // nginx自定义配置文件\n|  |  |  |--html          // 网页根目录\n|  |  |  |--logs          // 日志文件\n|  |  |  |--ssl           // 各个域名的证书存放地址nginx.conf\n|  |--nginx_run.sh        // sh自动化命令\n```\n\n\n按照以上目录结构创建相应的文件夹和文件\n\n\n```text\nmkdir /root/app/nginx/conf -p\ntouch /root/app/nginx/conf/nginx.conf\nmkdir /root/app/nginx/html -p\nmkdir /root/app/nginx/logs -p\nmkdir /root/app/nginx/ssl -p\ntouch /root/nginx_run.sh\n```\n\n\n## 配置文件\n\n\n### 不需要 SSL\n\n\n如果只需要将`http://www.letttgaco.cn`重定向到`https://blog.letttgaco.cn`，那就只需要配置 80 端口。\n\n\n```text\nvim /root/app/nginx/conf/nginx.conf\n```\n\n\n```text\nserver {\n    listen       80;\n\n    server_name  www.letttgaco.cn;\n    rewrite /.* https://blog.letttgaco.cn$uri permanent;\n}\n```\n\n\n重定向的`url`是会发生变更，如果是需要隐式转发，则可以进行如下配置：\n\n\n```text\nserver {\n    listen 80;\n    server_name www.letttgaco.cn;\n    large_client_header_buffers 4 128k;\n\n    location / {\n\n        #开启对http1.1支持\n        proxy_http_version 1.1;\n\n        #设置Connection为空串,以禁止传递头部到后端\n        #http1.0中默认值Connection: close\n        proxy_set_header Connection \"\";\n\n        proxy_pass https://blog.letttgaco.cn;\n    }\n}\n```\n\n\n### 需要 SSL\n\n\n如果也需要将`https://www.letttgaco.cn`也进行重定向，那么就需要进行额外的证书配置\n\n\n### 申请 SSL 证书\n\n\n首先先去腾讯云去申请`www.letttgaco.cn`的 SSL 证书，主要有两个文件：\n\n- `1_www.letttgaco.cn_bundle.crt`\n- `2_www.letttgaco.cn.key`\n\n将证书下载下来并上传到`/root/app/nginx/ssl`中，\n\n\n> 备注：腾讯云 SSL 部署文档\n\n\n### 配置 conf 文件\n\n\n```text\nserver {\n    listen 80;\n    #SSL 访问端口号为 443\n    listen 443 ssl;\n    #填写绑定证书的域名\n    server_name www.letttgaco;\n    #证书文件名称\n    ssl_certificate /ssl/1_www.letttgaco.cn_bundle.crt;\n    #私钥文件名称\n    ssl_certificate_key /ssl/2_www.letttgaco.cn.key;\n    ssl_session_timeout 5m;\n    #请按照以下协议配置\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;\n    ssl_prefer_server_ciphers on;\n        # 重定向\n    rewrite /.* https://blog.letttgaco.cn$uri permanent;\n}\n```\n\n\n## 启动 Nginx\n\n\n### 不需要 SSL\n\n\n```text\ndocker run -p 80:80 --name nginx -v /root/app/nginx/html/:/usr/share/nginx/html -v /root/app/nginx/nginx.conf:/etc/nginx/conf.d/nginx.conf -v /root/app/nginx/logs/:/var/log/nginx/  --privileged=true -d nginx:1.19.3\n```\n\n\n### 需要 SSL\n\n\n```text\ndocker run -p 80:80 -p 443:443 --name nginx -v /root/app/nginx/html/:/usr/share/nginx/html -v /root/app/nginx/nginx.conf:/etc/nginx/conf.d/nginx.conf -v /root/app/nginx/logs/:/var/log/nginx/ -v /root/app/nginx/ssl/:/ssl/ --privileged=true -d nginx:1.19.3\n```\n\n\n> -p 80:80 将 80 端口映射到主机 80 端口\n\n\t- `-name nginx` 别名，可以使用别名操作 nginx 容器\n\t- `v /root/app/nginx/nginx.conf:/etc/nginx/conf.d/nginx.conf` 将主机的配置文件挂载到容器中，使 nginx 容器使用主机中的自定义配置文件\n\t- `-privileged=true` 获取宿主机 root 权限\n\n\t`nginx:1.19.3` 指定 nginx 的版本，防止后续有坑\n\n\n# 自动化启动 Nginx\n\n\n为了启动`Nginx`方便，我在这里写了一个简单的`nginx_run.sh`的脚本：\n\n\n```text\ndocker stop nginxdocker rm nginxdocker run -p 80:80 -p 443:443 --name nginx -v /root/app/nginx/html/:/usr/share/nginx/html -v /root/app/nginx/nginx.conf:/etc/nginx/conf.d/nginx.conf -v /root/app/nginx/logs/:/var/log/nginx/ -v /root/app/nginx/ssl/:/ssl/ --privileged=true -d nginx:1.19.3\n```\n\n\n# 结束\n\n\n至此，我的网站终于可以实现`http`和`https`的重定向了。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2020-10-16",
        "type": "Post",
        "slug": "hryfur",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文主要介绍了如何使用 Nginx 配置重定向和 HTTPS，包括如何将 HTTP 请求重定向到 HTTPS，以及如何申请和配置 SSL 证书。此外，本文还提供了一个简单的脚本，用于自动化启动 Nginx。",
        "更新时间": "2023-08-26T15:21:00.000Z",
        "title": "Nginx配置重定向和Https的实践",
        "category": "技术分享",
        "tags": [
          "Nginx",
          "SSL"
        ],
        "status": "Archived",
        "urlname": "cbd49264-58c3-4052-b267-0ec9109cb24d",
        "updated": "2023-08-26 15:21:00"
      },
      "body": "",
      "realName": "Nginx配置重定向和Https的实践",
      "relativePath": "/Nginx配置重定向和Https的实践.md"
    },
    {
      "id": "b043b306-f082-4e6d-bd82-f4be2262de22",
      "doc_id": "b043b306-f082-4e6d-bd82-f4be2262de22",
      "title": "b043b306-f082-4e6d-bd82-f4be2262de22",
      "updated": 1693063200000,
      "body_original": "\n# 引言\n\n\n最近在搭建 Hadoop+zookeeper+HBase 集群过程中，HBase 老是出现各种问题，经过不断查看日志文件，找各种解决办法……此时此时，我终于是搭建成功了吼吼吼~值得庆祝一下。以下是我在搭建 HBase 集群过程中出现的问题记录，改天抽空写一下 Hadoop+zookeeper+HBase 的集群搭建。\n\n\n# hbase-site.xml\n\n\n先放一下最后搞定成功的配置文件\n\n\n```xml\n<!-- 设置HRegionServers共享目录。因为我搭建的是高可用集群，\n\t所以这里的hbase.rootdir值来自hadoop中的hdfs.default的值 -->\n<property>\n\t<name>hbase.rootdir</name>\n\t<value>hdfs://mycluster/hbase</value>\n</property>\n<!-- 启用分布式模式 -->\n<property>\n\t<name>hbase.cluster.distributed</name>\n\t<value>true</value>\n</property>\n<!-- master主机的端口号 -->\n<property>\n\t<name>hbase.master</name>\n\t<value>mycluster:60000</value>\n</property>\n<!-- 指定Zookeeper集群位置 -->\n<property>\n\t<name>hbase.zookeeper.quorum</name>\n\t<value>s201:2181,s202:2181,s203:2181</value>\n</property>\n <!-- 指定独立Zookeeper安装路径 -->\n<property>\n\t<name>hbase.zookeeper.property.dataDir</name>\n\t<value>/home/letttgaco/zookeeper</value>\n</property>\n<!-- 指定ZooKeeper集群端口 -->\n<property>\n\t<name>hbase.zookeeper.property.clientPort</name>\n\t<value>2181</value>\n</property>\n```\n\n\n# Bug 汇总\n\n\n**java.net.UnknownHostException: MyCluster**\n\n\n> 这是因为，HBase 没有识别 MyCluster 这个集群，解决这个问题的方法是把 Hadoop 的 2 个配置文件（core-site.xml和hdfs-site.xml），放到每个 HBase 的 conf 目录下，让 HBase 能找到 Hadoop 的配置。\n\n\n**zookeeper.MetaTableLocator: Failed verification of hbase:meta,,1 at address xxx**\n\n\n> 如果你也是集群搭建过程中出现这个问题，请清除 hbase 安装目录下 logs 文件夹以 hbase 开头的所有日志文件，进入 zkCli.sh 客户端，并用rmr /hbase删除所有关于 hbase 的表信息，并用hdfs dfs -rmr /hbase删除所有关于 hbase 的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n\n**ERROR: org.apache.hadoop.hbase.ipc.ServerNotRunningYetException: Server is not running yet**\n\n\n> 如果你也是集群搭建过程中出现这个问题，请清除 hbase 安装目录下 logs 文件夹以 hbase 开头的所有日志文件，进入 zkCli.sh 客户端，并用rmr /hbase删除所有关于 hbase 的表信息，并用hdfs dfs -rmr /hbase删除所有关于 hbase 的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n\n**org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.ipc.StandbyException): Operation category READ is not supported in state standby**\n\n\n> 这是由于启动 hbase 时，namenode 所在节点的主机的 hadoop 状态为 standby（备用）态，hbase master 进程会在启动后自动停掉。我出现这个的原因是：我虽然准备搭建 hbase 集群，但是在hbase-site.xml配置文件中的hbase.rootdir属性中配置的依然是单一某个主机节点的共享目录，导致在 standby 态的主机启动 hbase 坏掉。所以解决方案是参照我的配置文件进行修改，清除 hbase 安装目录下 logs 文件夹以 hbase 开头的所有日志文件，进入 zkCli.sh 客户端，并用rmr /hbase删除所有关于 hbase 的表信息，并用hdfs dfs -rmr /hbase删除所有关于 hbase 的文件，然后重新启动start-hbase.sh。\n\n\n**exception=org.apache.hadoop.hbase.NotServingRegionException: Region hbase:meta,,1 is not online on xxx**\n\n\n> 即使我已经搭建好的集群，我每次启动还是会报这个错误，但是并不影响正常运行。。。 如果你是集群搭建过程中出现这个问题，请清除 hbase 安装目录下 logs 文件夹以 hbase 开头的所有日志文件，进入 zkCli.sh 客户端，并用rmr /hbase删除所有关于 hbase 的表信息，并用hdfs dfs -rmr /hbase删除所有关于 hbase 的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n\n**org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.fs. PathIsNotEmptyDirectoryException): `/hbase/WALs/xxx-splitting is non empty’: Directory is not empty**\n\n\n> 我出现的原因是配置文件配错，在 hbase-site.xml 配置文件中的hbase.rootdir属性中配置的依然是单一某个主机节点的共享目录，所以 hbase 只会访问单一节点的 hdfs 的 /hbase/WALs/ 目录，导致冲突。解决方案是：请清除 hbase 安装目录下 logs 文件夹以 hbase 开头的所有日志文件，进入 zkCli.sh 客户端，并用rmr /hbase删除所有关于 hbase 的表信息，并用hdfs dfs -rmr /hbase删除所有关于 hbase 的文件，然后参照我的配置文件进行修改，然后集群就好了。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-05-14",
        "type": "Post",
        "slug": "qfvyux",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:20:00.000Z",
        "title": "HBase集群搭建过程中容易出现的Bug汇总及解决方案",
        "category": "技术分享",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "b043b306-f082-4e6d-bd82-f4be2262de22",
        "updated": "2023-08-26 15:20:00"
      },
      "body": "",
      "realName": "HBase集群搭建过程中容易出现的Bug汇总及解决方案",
      "relativePath": "/HBase集群搭建过程中容易出现的Bug汇总及解决方案.md"
    },
    {
      "id": "5608118c-f262-4b39-999d-d67a5424cd82",
      "doc_id": "5608118c-f262-4b39-999d-d67a5424cd82",
      "title": "5608118c-f262-4b39-999d-d67a5424cd82",
      "updated": 1693061280000,
      "body_original": "\n# 引言\n\n\nFastDFS 是一个由 C 语言实现的开源轻量级分布式文件系统，作者余庆[@YuQing](https://github.com/happyfish100) ，支持 Linux、FreeBSD、AID 等 Unix 系统，解决了大数据存储和读写负载均衡等问题，适合存储 4KB~500MB 之间的小文件，如图片网站、短视频网站、文档、app 下载站等，UC、京东、支付宝、迅雷、酷狗等都有使用。\n\n\n# 安装前准备\n\n\n我的云服务器为腾讯云服务器，系统为 CentOS7.2(64 位)，自带 50G 系统盘。\n\n\n# 安装 FastDFS\n\n\n## 上传安装包\n\n\n此次用到的安装包如图所示，我们首先用 FTP 工具把 FastDFS(\n\n\n[点击下载安装包](https://files.letttgaco.cn/%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81/FastDFS/)\n\n\n)的相关安装包上传至服务器的\n\n\n```text\n/usr/local/fastDFS\n```\n\n\n目录中（也可以自行选择目录，后面在涉及到修改配置文件时会进一步提示说明）。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FkE5rj279Cvl3LbMB_DJYk2RngXz.png)\n\n\n## 安装基本环境\n\n\n```shell\nyum -y install libevent\n```\n\n\n## 安装 libfastcommonV1.0.7 工具包\n\n\n```text\ntar -zxvf libfastcommonV1.0.7.tar.gz\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FsdzrHlXifm-5OLROOVcI9lD5LFr.png)\n\n\n进入解压后的目录，看到有\n\n\n```text\nmake.sh\n```\n\n\n，依次执行命令进行编译。\n\n\n```text\n./make.sh\n./make.sh install\n```\n\n\n## 安装 Tracker 服务\n\n\n```text\ntar -zxvf FastDFS_v5.05.tar.gz\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FmOIOgqOQC9FHt5BgyHmbWx-U0V4.png)\n\n\n进入文件夹后依次执行命令进行编译:\n\n\n```text\n./make.sh\n./make.sh install\n```\n\n\n安装后文件会默认安装在 `/usr/bin` 中:\n\n\n```text\nll fdfs*\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FkK9aFMO6c-ObfXU-ycwXGHjYdpZ.png)\n\n\n配置文件在\n\n\n```text\n/etc/fdfs\n```\n\n\n目录中：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FhrI3hIFJ8foQNPx8ABpsubI6czd.png)\n\n\n进入\n\n\n```text\n/usr/locla/fastDFS/FastDFS/conf/\n```\n\n\n目录下:\n\n\n```text\ncd /usr/locla/fastDFS/FastDFS/conf/\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Ft_6D_Sum6zcqguKCsgqyZkGR55u.png)\n\n\n将其所有文件拷贝至\n\n\n```text\n/etc/fdfs\n```\n\n\n目录下:\n\n\n```text\ncp * /etc/fdfs/\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fpp-KKucvQ0k4StdihuBMBiNy5tS.png)\n\n\n配置 tracker 服务,进入\n\n\n```text\n/etc/fdfs/\n```\n\n\n目录下，修改\n\n\n```text\ntracker.conf\n```\n\n\n文件\n\n\n```text\ncd /etc/fdfs/\nvim tracker.conf\n```\n\n\n修改`base_path`为自定义存放 tracker 日志的目录，这里以`/usr/local/fastDFS/trackerLog`为例，如果没有创建此目录，可以先修改再创建。\n\n\n```text\nmkdir -p /usr/local/fastDFS/trackerLog\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FgFsdQi4cLCu3T8GNtc9ocaV2Lsa.png)\n\n\n> 这里我们也可以挂载的一个云硬盘，使用云硬盘的目录来存放文件。因为系统盘不支持扩容，以后系统盘满了之后就很麻烦，所以最好就挂载一个硬盘，同时也可以把图片文件都和系统盘给区分开来。我暂时没有云硬盘，这里以系统盘为例。\n\n\n启动 tracker 服务并查看进程是否已启动\n\n\n```text\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf\nps aux|grep trackerd\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FvsnkbcyAZDXpPAK80qHJMg4KmbV.png)\n\n\n## 安装 storage 服务\n\n\n进入`/etc/fdfs/`目录，修改`storage.conf`文件\n\n\n```text\nvim /etc/fdfs/storage.conf\n```\n\n\n修改日志的存储路径，如果没有相关文件夹，可以先配置再创建：\n\n\n```text\nmkdir -p /usr/local/fastDFS/storageLog/\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FgMRz4vFcRLt6Yuzjbz7j-waqKpr.png)\n\n\n修改文件的存储路径：\n\n\n```text\nmkdir -p /usr/local/fastDFS/storage/\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FlHxWq8zj_6HMJ9oGtHSvVJRiNTH.png)\n\n\n修改\n\n\n```text\ntracker_server\n```\n\n\n的值为云服务器的公网 IP 地址。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FqdDOPng1Knm-yUIQ7xk7TTYYkzp.png)\n\n\n启动 storage 服务并且查看进程：\n\n\n```text\n/usr/bin/fdfs_storaged /etc/fdfs/storage.conf\nps aux|grep storage\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FuUOP7TYURf1b0SGA0I8lw2-aWP5.png)\n\n\n至此，FastDFS 安装完毕，但是我们需要通过 http 来进行上传文件并访问，所以需要使用 nginx 一起来搞事情！\n\n\n## 安装 nginx\n\n\n进入`/usr/local/fastDFS`目录，解压缩 fastdfs-nginx-module_v1.16.tar.gz\n\n\n```text\ntar -zxvf fastdfs-nginx-module_v1.16.tar.gz\n```\n\n\n修改`/fastdfs-nginx-module/src/config`文件，把其中的`local`去掉:\n\n\n```text\ncd fastdfs-nginx-module/src/\nvim config\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fpn_4GFMu67gkrkbjguR3D_Wv8wk.png)\n\n\n创建默认的 nginx 的安装目录：\n\n\n```text\nmkdir /usr/local/nginx/\n```\n\n\n进入 nginx 根目录进行配置：\n\n\n```text\ncd /usr/local/fastDFS/nginx-1.14.2/\n```\n\n\n直接输入以下命令对 nginx 进行配置:\n\n\n> 注意：最后一行**--add-module=/usr/local/fastDFS/nginx/fastdfs-nginx-module/src**的目录为你所指定的**fastdfs-nginx-module**的安装目录\n\n\n```text\n./configure \\\n--prefix=/usr/local/nginx \\\n--pid-path=/var/run/nginx/nginx.pid \\\n--lock-path=/var/lock/nginx.lock \\\n--error-log-path=/var/log/nginx/error.log \\\n--http-log-path=/var/log/nginx/access.log \\\n--with-http_gzip_static_module \\\n--http-client-body-temp-path=/var/temp/nginx/client \\\n--http-proxy-temp-path=/var/temp/nginx/proxy \\\n--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\\n--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\\n--http-scgi-temp-path=/var/temp/nginx/scgi \\\n--add-module=/usr/local/fastDFS/nginx/fastdfs-nginx-module/src\n```\n\n\n依次执行以下命令进行编译：\n\n\n```text\nmake\nmake install\n```\n\n\n把`/fastdfs-nginx-module/src/mod_fastdfs.conf`文件复制到`/etc/fdfs`目录下：\n\n\n```text\ncd /usr/local/fastDFS/nginx/fastdfs-nginx-module/src/\ncp mod_fastdfs.conf /etc/fdfs\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FjpdNBhF1UuvL220TgU3QmOAl0om.png)\n\n\n进入\n\n\n```text\n/etc/fdfs/\n```\n\n\n，打开\n\n\n```text\nmod_fastdfs.conf\n```\n\n\n并且修改日志存放路径：\n\n\n```text\nmkdir -p /usr/local/fastDFS/tmp/\ncd /etc/fdfs/\nvim mod_fastdfs.conf\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FsN-jzgb1YirBjLLzIRynMvHejQr.png)\n\n\n修改\n\n\n```text\ntracker_server\n```\n\n\n的值为云服务器的公网 IP 地址。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FuDEiHiYTUwJ36U_ew5JSBSuhKy8.png)\n\n\n修改\n\n\n```text\nstorage_path0\n```\n\n\n的存放路径：\n\n\n```text\nmkdir -p /usr/local/fastDFS/storage/\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fv9UGEgECG4OHnCNMcDO-kg1SQq9.png)\n\n\n进入 ngxin 的配置文件目录并且修改\n\n\n```text\nnginx.conf\n```\n\n\n文件：\n\n\n```text\ncd /usr/local/nginx/conf/\nvim nginx.conf\n```\n\n\n修改原 server 中的配置为以下：\n\n\n```text\nserver {\n  listen       80;\n  server_name  你的公网IP地址;\n\n  location /group1/M00 {\n  ngx_fastdfs_module;\n  }\n}\n```\n\n\n启动 nginx\n\n\n```text\n/usr/local/nginx/sbin/nginx\n```\n\n\n## 安装完成\n\n\n至此，FastDFS 已全部安装完成，下面将介绍如何利用 java 开发工具来测试 FastDFS 的上传文件功能。\n\n\n# 上传测试\n\n\n需求：将本地图片上传至图片服务器，再控制台打印 url。\n\n\n## 创建 Maven 工程 FastDFSTest\n\n\n由于 FastDFS 客户端 jar 包并没有在中央仓库中，所以需要使用下列命令手动安装 jar 包到 Maven 本地仓库。 源码地址：[fastdfs-client-java](https://github.com/happyfish100/fastdfs-client-java)，解压后导入 Eclipse 的 Maven 工程，右键项目选择`Run As — Maven Install`进行本地仓库的安装。 在你的`FastDFSTest`工程的`pom.xml`中添加依赖：\n\n\n```xml\n<dependency>    <groupId>org.csource</groupId>    <artifactId>fastdfs-client-java</artifactId>    <version>1.27-SNAPSHOT</version></dependency>\n```\n\n\n## 在 resources 文件夹中创建`fdfs_client.conf`文件\n\n\n```text\n# 连接超时时间\n# 默认30s\nconnect_timeout=30\n\n# 网络超时时间\n# 默认30秒30s\nnetwork_timeout=60\n\n# 工作文件夹，日志存在此（目录自定）\nbase_path=/home/yuqing/fastdfs\n\n# tracer server服务器地址列表，多个tracer server的话，分行列出\ntracker_server=你的公网IP:22122\n\n#日志级别\n### emerg for emergency\n### alert\n### crit for critical\n### error\n### warn for warning\n### notice\n### info\n### debu\nlog_level=info\n\n# 是否使用连接池\nuse_connection_pool = false\n\n# 连接闲置超时时间，连接如果闲置的时间超过本配置，则关闭次连接，单位秒\nconnection_pool_max_idle_time = 3600\n\n# 是否从tracer server读取fastdfs的参数，默认为false\nload_fdfs_parameters_from_tracker=false\n\n# 是否使用storage id 替换 ip，默认为false\n# 和tracker.conf该参数含义一样\n# 本配置只有在load_fdfs_parameters_from_tracker＝false时生效\n# 本配置默认为false\nuse_storage_id = false\n\n# 指定storage id的文件名，允许使用绝对路径\n# 和tracker.conf该参数含义一样\n# 本配置只有在load_fdfs_parameters_from_tracker＝false时生效\nstorage_ids_filename = storage_ids.conf\n\n#HTTP settings\nhttp.tracker_server_port=8080\n\n#引入HTTP相关配置\n##include http.conf\n```\n\n\n## 创建测试 java 类\n\n\n```java\npackage cn.letttgaco.fastdfs;import org.csource.fastdfs.ClientGlobal;import org.csource.fastdfs.StorageClient;import org.csource.fastdfs.StorageServer;import org.csource.fastdfs.TrackerClient;import org.csource.fastdfs.TrackerServer;public class TestDemo {    public static void main(String[] args) throws Exception {        // 1、加载配置文件（绝对路径），配置文件中的内容就是 tracker 服务的地址。        ClientGlobal.init(\"D:/Codes/Eclipse/Tiramisu/spring-security-demo/src/main/resources/fdfs_client.conf\");        // 2、创建一个 TrackerClient 对象。直接 new 一个。        TrackerClient trackerClient = new TrackerClient();        // 3、使用 TrackerClient 对象创建连接，获得一个 TrackerServer 对象。        TrackerServer trackerServer = trackerClient.getConnection();        // 4、创建一个 StorageServer 的引用，值为 null        StorageServer storageServer = null;        // 5、创建一个 StorageClient 对象，需要两个参数 TrackerServer 对象、StorageServer 的引用        StorageClient storageClient = new StorageClient(trackerServer, storageServer);        // 6、使用 StorageClient 对象上传图片（绝对路径）。        // 扩展名不带“.”        String[] strings = storageClient.upload_file(\"D:/Codes/TestCodes/c.JPG\", \"jpg\", null);        // 7、返回数组。包含组名和图片的路径。        for (String string : strings) {            System.out.println(string);        }    }}\n```\n\n\n控制台输出如下结果：\n\n\n```java\ngroup1M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg\n```\n\n\n## 打开浏览器查看已上传的图片\n\n\n```text\nhttp://你的公网IP/group1/M00/00/00/wKgZhVkMP4KAZEy-AAA-tCf93Fo973.jpg\n```\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-02-21",
        "type": "Post",
        "slug": "di6uo5",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:48:00.000Z",
        "title": "在腾讯云服务器上安装FastDFS",
        "category": "学习笔记",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "5608118c-f262-4b39-999d-d67a5424cd82",
        "updated": "2023-08-26 14:48:00"
      },
      "body": "",
      "realName": "在腾讯云服务器上安装FastDFS",
      "relativePath": "/在腾讯云服务器上安装FastDFS.md"
    },
    {
      "id": "b3c87db0-ebc5-4eb3-9529-2ea17e5d4bc8",
      "doc_id": "b3c87db0-ebc5-4eb3-9529-2ea17e5d4bc8",
      "title": "b3c87db0-ebc5-4eb3-9529-2ea17e5d4bc8",
      "updated": 1693061280000,
      "body_original": "\n# 引言\n\n\n最近有需求需要用到富文本编辑器，而且需要将上传/粘贴的图片上传到阿里云 OSS 上。在简单体验了几个富文本编辑器之后，决定选用 Tinymce。 Tinymce-Vue 里面的坑还是挺多的，花了两天时间终于把一些简单的坑填上了，基本上算是满足了需求。这里来简单讲一下在项目中使用 `Tinymce-Vue` 的经过。\n\n\n# Tinymce-Vue 插件安装\n\n\n```text\nnpm install @tinymce/tinymce-vue -D\nnpm install tinymce -D\n```\n\n\n安装成功之后，在`node_modules`目录中，找到`tinymce`中的`skins`目录，将其拷贝到`static`或者`public`目录下。为了结构清晰，我外层包了`tinymce`目录。\n\n\n> 踩坑 ①：用不同版本的vue-cli创建出来的项目，默认静态公共资源的目录是不一样的。vue-cli2的默认静态公共资源目录为static，但是vue-cli3默认为public。拷贝的时候根据自己项目的配置注意下\n\n\n由于`tinymce`默认是英文界面，如果需要下载[中文的语言包](https://www.tiny.cloud/get-tiny/language-packages/)，可以去官网下载。下载之后将其放在`public/tinymce/`下。同样的，为了结构清晰，我将其放在了`langs`目录下。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FpED8KkqnzMbNRqZOs9ZVhyaxrnB.png)\n\n\n# 起步\n\n\n在组件中初始化`Tinymce.vue`组件，并引入需要用到的依赖。\n\n\n```javascript\n// 引入基本文件\nimport tinymce from 'tinymce/tinymce'\nimport Editor from '@tinymce/tinymce-vue'\n// 引入主题文件\nimport 'tinymce/themes/silver'\n// 引入你需要的插件\nimport 'tinymce/plugins/paste' //粘贴插件，很强大，配置后可以粘贴图片\nimport 'tinymce/plugins/image' //上传图片的插件\nimport 'tinymce/plugins/table' //表格\nimport 'tinymce/plugins/wordcount'\n```\n\n\n由于`Editor-vue`也是官方封装的组件，所以需要注册组件使用。\n\n\n```javascript\ncomponents: {  Editor;}\n```\n\n\n使用组件，代码如下：\n\n\n```javascript\n<template>\n  <div class=\"tinymce-editor\">\n    <editor\n      :key=\"tinymceFlag\"\n      class=\"editor\"\n      v-model=\"myValue\"\n      :init=\"tinymceInit\">\n    </editor>\n    <a-button @click=\"handleSubmit\" type=\"primary\" class=\"button\">{{ label }}</a-button>\n  </div>\n</template>\n\n<script>\n// 引入基本文件\n// eslint-disable-next-line no-unused-vars\nimport tinymce from 'tinymce/tinymce'\nimport Editor from '@tinymce/tinymce-vue'\n// 引入主题样式\nimport 'tinymce/themes/silver'\n// 引入你需要的插件\nimport 'tinymce/plugins/paste'\nimport 'tinymce/plugins/image'\nimport 'tinymce/plugins/table'\nimport OSS from '@/utils/oss.js'\nimport v1 from 'uuid'\n\nexport default {\n  name: 'Tinymce',\n  data () {\n    return {\n      tinymceFlag: 1,\n      myValue: '',\n      isShowFileDlg: false,\n      tinymceInit: {}\n    }\n  },\n  props: {\n    // 基本路径，默认为空根目录，如果你的项目发布后的地址为目录形式，\n    // 即abc.com/tinymce，baseUrl需要配置成tinymce，不然发布后资源会找不到\n    // 我也不知道为啥要设置baseUrl，我目前没有遇到这个问题。等遇到再说\n    baseUrl: {\n      type: String,\n      default: ''\n    },\n    // 定义允许上传的图片类型\n    accept: {\n      default: 'image/jpeg, image/png',\n      type: String\n    },\n    // 最大上传图片大小\n    maxSize: {\n      default: 5242880,\n      type: Number\n    },\n    // 偶尔会需要禁用富文本\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    // 设置默认需要的拓展\n    plugins: {\n      type: [String, Array],\n      default: 'image table wordcount'   // 可以按照自己需要配置默认需要的组件\n    },\n   \t// 设置默认菜单栏 ‘|’ 用来分隔功能\n    toolbar: {\n      type: [String, Array],\n      default: 'undo redo | formatselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | image table'\n    },\n    // 自己项目需要做一个类似提交表单的按钮\n    label: {\n      type: String,\n      default: '提交'\n    },\n    // 设置默认宽度\n    width: {\n      type: String,\n      default: '1200'\n    },\n    // 设置默认高度\n    height: {\n      type: String\n    }\n  },\n  components: {\n    Editor\n  },\n  mounted () {\n  },\n  created () {\n    // 定义self防止this调用时指向性问题\n    const self = this\n    self.tinymceInit = {\n      fontsize_formats: '11px 12px 14px 16px 18px 24px 36px 48px 50px 56px 60px 64px',\n      language_url: `/tinymce/langs/zh_CN.js`, // 设置中文语言的路径，我的是/public下的tinymce\n      skin_url: '/tinymce/skins/ui/oxide', // skin路径\n      language: 'zh_CN',\n      width: this.width,\n      browser_spellcheck: true, // 拼写检查\n      branding: false, // 去水印\n      statusbar: false, // 隐藏编辑器底部的状态栏\n      paste_data_images: true, // 允许粘贴图像\n      menubar: false, // 隐藏最上方menu\n      plugins: this.plugins,\n      toolbar: this.toolbar,\n      // 设置图片上传时的上传函数，支持图片复制粘贴前上传到指定服务器然后返回url到富文本\n      images_upload_handler: (blobInfo, success, failure) => {\n        if (blobInfo.blob().size > self.maxSize) {\n          failure('文件体积不能超过' + this.maxSize / (1024 * 1024) + 'Mb')\n        }\n        if (self.accept.indexOf(blobInfo.blob().type) >= 0) {\n          uploadPic()\n        } else {\n          failure('图片格式错误, 仅支持' + this.accept + '格式的图片')\n        }\n        // 异步上传到OSS\n        async function uploadPic () {\n          if (self.client) {\n            //值得注意的是，测试时，微信截图后直接在富文本进行粘贴后会出现OSS文件类型报错，需要传入Buffer流或者Blob文件，可blobInfo.blob()按道理应该是blob才对，可还是报错，无奈做了一个blobInfo.blob()的带的File文件对象 ==》 ArrayBuffer流 ==》 Buffer流 才使得OSS能够识别。\n            const reader = new FileReader()\n            reader.readAsArrayBuffer(blobInfo.blob()) // File文件对象 ==》 ArrayBuffer流\n            reader.onload = function (event) {\n              console.log(event.target.result)\n              // 引入UUID防止文件覆盖\n              const fileName = `${v1()}-${blobInfo.name()}`\n              self.client\n                // ArrayBuffer流 ==》 Buffer流 ==》 OSS.put()\n                .put(fileName, toBuffer(event.target.result))\n                .then(result => {\n                  // 得到OSS返回的url\n                  result.url = result.res.requestUrls[0].split('?')[0]\n                  // 将上传完成的状态抛出\n                  self.$emit('on-upload-complete', result) // 抛出 'on-upload-complete' 钩子\n                  // 返回url\n                  success(result.url)\n                })\n                .catch(err => {\n                  // 失败\n                  failure(err)\n                })\n            }\n          } else {\n            // 封装的OSS的错误提示（ak失效时触发）\n            await self.$message.info('上传配置已失效，重新加载中...')\n          }\n          return {\n            failure () {}\n          }\n          // ArrayBuffer流 ==》 Buffer流\n          function toBuffer (ab) {\n            const buf = Buffer.alloc(ab.byteLength)\n            const view = new Uint8Array(ab)\n            for (let i = 0; i < buf.length; ++i) {\n              buf[i] = view[i]\n            }\n            return buf\n          }\n        }\n      }\n    }\n  },\n  watch: {\n    myValue (newValue) {\n      this.$emit('input', newValue)\n    }\n  },\n  activated () {\n    // 当使用keep-alive时，在切换标签页再切回来会出现富文本key缺少无法使用的情况，在这个里做一个处理，让每次的key不一样\n    this.tinymceFlag++\n  },\n  methods: {\n    // 自己的业务需求需要一个提交按钮，将值传回父组件\n    handleSubmit () {\n      this.$emit('submit', this.myValue)\n    }\n  },\n  computed: {\n    // 封装的OSS的初始化方法\n    client: function () {\n      return OSS.client()\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n  .tinymce-editor {\n    margin-left: 30px;\n    .button {\n      margin-top: 15px;\n      float: right;\n    }\n  }\n</style>\n```\n\n\n> 坑②：当使用`keep-alive`时，富文本会出现`key`重复的问题\n\n\n\t坑③：微信截图完直接粘贴图片后`blobInfo.blob()`生成一个不能被`OSS`识别的`File`对象，需要`File`文件对象 ==》 `ArrayBuffer`流 ==》 `Buffer`流 才能被`OSS`识别\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-01-15",
        "type": "Post",
        "slug": "sbgn9r",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:48:00.000Z",
        "title": "Tinymce-Vue初体验",
        "category": "学习笔记",
        "tags": [
          "富文本",
          "Vue"
        ],
        "status": "Archived",
        "urlname": "b3c87db0-ebc5-4eb3-9529-2ea17e5d4bc8",
        "updated": "2023-08-26 14:48:00"
      },
      "body": "",
      "realName": "Tinymce-Vue初体验",
      "relativePath": "/Tinymce-Vue初体验.md"
    },
    {
      "id": "aea49f8c-44b2-44d5-a269-c0d1ff23625d",
      "doc_id": "aea49f8c-44b2-44d5-a269-c0d1ff23625d",
      "title": "aea49f8c-44b2-44d5-a269-c0d1ff23625d",
      "updated": 1693063320000,
      "body_original": "\n# 引言\n\n\n在中后台管理类系统中，**多页签**的需求非常普遍，用户常常需要在多个页签内跳转，比如填写表单时去查询某个列表获取一些字段信息再回到表单页面填写。这样的需求在 Vue 中使用 [keep-alive](https://v3.cn.vuejs.org/api/built-in-components.html#keep-alive) 即可实现，但是在 React 中，React Router 切换路由后就会卸载组件，而本身并没有提供类似 keep-alive 的功能，所以实现多页签的功能就会变得格外困难。我的项目也遇到了同样的问题，这里记录一下技术调研和技术选型的过程。\n\n\nReact 多页签 UI 本身好实现，难点是没有官方提供类似 Vue 的 keep-alive 功能，而使用 React Router，路由切换会直接卸载组件，导致无法缓存，用户的数据和行为因此丢失了。\n\n\n社区上关于多页签的需求呼声也非常高，但是如 React 社区比较出名的中后台方案[Ant Design Pro](https://github.com/ant-design/ant-design-pro)也不支持该功能，至今仍然有很多[Issue](https://github.com/ant-design/ant-design-pro/issues?q=%E5%A4%9A%E9%A1%B5%E7%AD%BE%E9%9C%80%E6%B1%82)提出这类需求：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FuCO9hJ-9X7b-OFn_NHjdjHcbZoU.png)\n\n\n[偏右](https://github.com/afc163)大佬早在 2017 年对此做出了回应，详见[能否提供 tab 切换模式 · Issue #220 · ant-design/ant-design-pro · GitHub](https://github.com/ant-design/ant-design-pro/issues/220)，这个 Issue 虽然关闭了，但这些年仍然活跃：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FvCuqsZHkUWinokfvz1NcpDwc5Id.png)\n\n\n看 👎 的数量就知道，用户其实对这种回答很不买帐。再来看 2019 年偏右对这个问题的解释，稍微具体了些：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FofX-2QeIqDSJCDnMrh_wshVNfkp.png)\n\n\n# 项目简介\n\n\n所在部门的项目是一个小程序发布平台的管理后台，用于租户小程序的代码提交、提审、发布等工作流。前端客户端是 React 16.13.1，BFF 层则是 Koa2 的 Node 端，后端则是 Go。\n\n\n# 需求背景\n\n\n因为开发人员和测试人员会经常对小程序进行查询、提交代码、体验等等操作，有两个痛点很明显：\n\n1. 列表查询的搜索条件会因为切换路由而消失，特别是有些筛选条件是从数据库拿的，会在数据库和网页之间来回复制粘贴，浪费时间。\n2. 对于测试人员和开发人员来说，浏览器的标签页经常会开很多，如果我想多操作几个小程序，则需要又多开浏览器的标签页进行操作，本来就是 SPA 单页应用，所有的操作应该尽量在一个页面上完成。\n\n# 方案选型\n\n\n经过一番调研之后，基本的思路大概有三种：\n\n1. 使用 Redux，数据往 store 里面怼，实现页面数据的”缓存“。\n2. 改写 React Router 源码，切换路由不卸载，改为隐藏。\n3. 使用社区的轮子，当时选了 GitHub 里的两个产品： [React Keeper](https://github.com/lanistor/react-keeper) 和 [react-router-cache-route](https://github.com/CJY0208/react-router-cache-route)\n\n其实每种方案都存在一些问题，最终的选择是使用了排除法。\n第一种方案的缺点是，项目本身的接入 Redux 的操作繁琐，改造侵入性比较大，不是很好的选择。\n第二种的思路和 [react-router-cache-route](https://github.com/CJY0208/react-router-cache-route) 比较像，就不想重复造轮子了。\n第三种选用开源方案，用社区的优秀轮子：[react-router-cache-route](https://github.com/CJY0208/react-router-cache-route)\n\n\n结合目前项目的情况，不想改动点太多，所以选择了开源方案 [react-router-cache-route](https://github.com/CJY0208/react-router-cache-route)\n\n\n# 方案实施\n\n\n多标签页需求可以拆分为两步：\n\n1. 实现页面数据的缓存\n2. 菜单路由结合多标签 ui\n\n## 使用[react-router-cache-route](https://github.com/CJY0208/react-router-cache-route)实现页面的数据缓存\n\n\n首先遇到的第一个问题就是我目前的项目中，路由用的是配置是路由，即通过[react-router-config](https://github.com/ReactTraining/react-router)中的`renderRoutes`将配置式路由进行转换：\n\n\n```javascript\nfunction renderRoutes(routes, extraProps, switchProps) {\n  if (extraProps === void 0) {\n    extraProps = {};\n  }\n\n  if (switchProps === void 0) {\n    switchProps = {};\n  }\n  // 将配置式路由生成声明式路由，生成\n  // <Switch>\n  // \t\t<Route path={} exact={}></Route>\n  // </Switch>\n  return routes\n    ? React.createElement(\n        Switch,\n        switchProps,\n        routes.map(function (route, i) {\n          return React.createElement(Route, {\n            key: route.key || i,\n            path: route.path,\n            exact: route.exact,\n            strict: route.strict,\n            render: function render(props) {\n              return route.render\n                ? route.render(\n                    _extends({}, props, {}, extraProps, {\n                      route: route,\n                    })\n                  )\n                : React.createElement(\n                    route.component,\n                    _extends({}, props, extraProps, {\n                      route: route,\n                    })\n                  );\n            },\n          });\n        })\n      )\n    : null;\n}\n\n```\n\n\n而[react-router-cache-route](https://github.com/CJY0208/react-router-cache-route)目前不支持配置式路由。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Ft59aRxMoSdz4eMGTfBLOXfG3xGx.png)\n\n\n所以就需要对`renderRoutes`方法进行改造，在生成路由时，用他提供的 CacheRoute 替换 Route，用 CacheSwitch 替换 Switch。\n\n\n```javascript\nimport React from \"react\";\nimport CacheRoute, { CacheSwitch } from \"react-router-cache-route\";\n\n// 重写react-router-config中的renderRoutes方法\n// 将react-router-dom中的Switch和Route组件替换为react-router-cache-route中的CacheSwitch和CacheRoute组件\n// 用于组件的缓存，利用react-router-cache-route轮子，在切换路由时不让组件卸载，而是隐藏\nexport const renderRoutes = (routes, extraProps = {}, switchProps = {}) => {\n  return routes\n    ? React.createElement(\n        CacheSwitch,\n        switchProps,\n        routes.map(function (route, i) {\n          return React.createElement(CacheRoute, {\n            key: route.key || i,\n            path: route.path,\n            exact: route.exact,\n            strict: route.strict,\n            render: function render(props) {\n              return route.render\n                ? route.render({ ...props, ...extraProps, route: route })\n                : React.createElement(route.component, {\n                    ...props,\n                    ...extraProps,\n                    route: route,\n                  });\n            },\n          });\n        })\n      )\n    : null;\n};\n\n```\n\n\n## 菜单路由结合多标签 ui\n\n\nui 的逻辑参考的是[react-antd-multi-tabs-admin](https://github.com/hsl947/react-antd-multi-tabs-admin)。\n\n\n### UI 界面\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FkGiH4KxP7eKbIfUMnPhEcx9n1Ml.png)\n\n\n### 功能点\n\n1. 根据左侧菜单栏生成对应的 Tab 标签\n2. 右键可以刷新、关闭、关闭其他、关闭全部\n3. Tab 标签页本身可以关闭，关闭后自动切换到已打开的标签页\n4. 切换标签页时保持原有的数据不会重新加载\n\n### 思考\n\n\n### 数据存储\n\n\n用 store 存储标签页数据。Tab 标签页是一个全局共享，考虑到数据共享的问题，将数据存储到 store 中，并在每个页面共享。\n\n\n> 可以考虑把当前打开的标签数据同步至 localstory 中，实现刷新后依然可以恢复已打开的标签页，但是目前感觉比较鸡肋，只有把表单数据一起同步才有实用价值。\n\n\n### 菜单和 Tab 页同步\n\n\n因为 url 已经和菜单页同步，所以获取当前菜单最方便的方式就是从 url 中获取当前的路由，然后生成标签页，当切换标签页时，直接用 history.push 的方式改变 url，此时菜单页也会跟着变。\n\n\n## 实施\n\n\n### 新建 tabPanes.tsx\n\n\n```typescript\nimport React, {\n  FC,\n  useState,\n  useEffect,\n  useRef,\n  useCallback,\n  Component,\n} from \"react\";\nimport { useHistory, useLocation } from \"react-router-dom\";\nimport { Tabs, Alert, Dropdown, Menu } from \"antd\";\nimport Home from \"@pages/miniapps\";\nimport { getKeyName } from \"@utils/routerUtils\";\nimport { SyncOutlined } from \"@ant-design/icons\";\nimport { useSelector } from \"react-redux\";\nimport style from \"./index.module.less\";\nimport { CommonObjectType, RefType } from \"@type/type\";\nimport { useActions } from \"@utils/hook\";\nimport { RootState } from \"@reducers/index\";\n\nconst { TabPane } = Tabs;\n\nconst initPane = [\n  {\n    title: \"代码管理\",\n    key: \"miniapps\",\n    content: Home,\n    closable: false,\n    path: \"/miniapps\",\n  },\n];\n\ninterface Props {\n  // 默认激活的Tab页\n  defaultActiveKey: string;\n  // 标签页的props\n  panesItem: {\n    title: string;\n    content: Component;\n    key: string;\n    closable: boolean;\n    path: string;\n  };\n  // 激活的标签页\n  tabActiveKey: string;\n}\n\n// 多页签组件\nconst TabPanes: FC<Props> = (props) => {\n  // 记录当前激活的Tab页\n  const [activeKey, setActiveKey] = useState<string>(\"\");\n  // 记录当前打开的Tab页\n  const [panes, setPanes] = useState<CommonObjectType[]>(initPane);\n  // 记录Tab页的刷新状态\n  const [isReload, setIsReload] = useState<boolean>(false);\n  // 记录当前右键选中的Tab页\n  const [selectedPanel, setSelectedPanel] = useState<CommonObjectType>({});\n  // 用useRef记录最新的Tab页数据\n  const pathRef: RefType = useRef<string>(\"\");\n\n  // 取出操作Tab页的action\n  const { layouts } = useActions([\"layouts\"]);\n  // 从store取出当前的Tab页列表和刷新路径\n  const { curTab, reloadPath } = useSelector(\n    (state: RootState) => state.layouts\n  );\n\n  // 取出props\n  const { defaultActiveKey, panesItem, tabActiveKey } = props;\n  // 用history进行跳转，结合react-router-cache-route会将数据进行缓存\n  const history = useHistory();\n  // 取出当前的path，例如/miniapps /log等\n  const { pathname, search } = useLocation();\n  // 可能会有带参数的情况\n  const fullPath = pathname + search;\n\n  // 记录当前打开的tab\n  const storeTabs = useCallback((ps): void => {\n    // 对路径进行累加，对当前打开的路径进行全存储\n    const pathArr = ps.reduce(\n      (prev: CommonObjectType[], next: CommonObjectType) => [\n        ...prev,\n        next.path,\n      ],\n      []\n    );\n    // 将数据记录到store中\n    layouts.setTab(pathArr);\n  }, []);\n\n  // 从本地存储中恢复已打开的tab列表\n  const initTabs = useCallback((): void => {\n    const initPanes = curTab.reduce(\n      (prev: CommonObjectType[], next: string) => {\n        const { title, tabKey, component: Content } = getKeyName(next);\n        return [\n          ...prev,\n          {\n            title,\n            key: tabKey,\n            content: Content,\n            closable: tabKey !== \"/miniapps\",\n            path: next,\n          },\n        ];\n      },\n      []\n    );\n    // 从路由中获取当前需要打开的Tab页\n    const { tabKey } = getKeyName(pathname);\n    // 设置当前打开的Tab页\n    setPanes(initPanes);\n    // 设置当前激活的Tab页\n    setActiveKey(tabKey);\n  }, [pathname]);\n\n  // 初始化页面\n  useEffect(() => {\n    initTabs();\n  }, [initTabs]);\n\n  // tab切换\n  const onChange = (tabKey: string): void => {\n    setActiveKey(tabKey);\n  };\n\n  // 移除tab\n  const remove = (targetKey: string): void => {\n    const delIndex = panes.findIndex((item: any) => item.key === targetKey);\n    panes.splice(delIndex, 1);\n\n    // 删除非当前tab\n    if (targetKey !== activeKey) {\n      const nextKey = activeKey;\n      setPanes(panes);\n      setActiveKey(nextKey);\n      storeTabs(panes);\n      return;\n    }\n\n    // 删除当前tab，地址往前推，如果前面没有tab页就往后推\n    const nextPath = curTab[delIndex - 1] || curTab[delIndex + 1];\n    history.push(nextPath);\n    // 记录删除后的Tab页\n    setPanes(panes);\n    // 将数据记录到store\n    storeTabs(panes);\n  };\n\n  // tab点击删除操作\n  const onEdit = (targetKey: string | any, action: string) =>\n    action === \"remove\" && remove(targetKey);\n\n  // tab点击，激活标签页\n  const onTabClick = (targetKey: string): void => {\n    const { path } = panes.filter(\n      (item: CommonObjectType) => item.key === targetKey\n    )[0];\n    history.push({ pathname: path });\n  };\n\n  // 刷新当前 tab\n  const refreshTab = (): void => {\n    setIsReload(true);\n    setTimeout(() => {\n      setIsReload(false);\n    }, 1000);\n\n    layouts.reloadTab(pathname + search);\n    setTimeout(() => {\n      layouts.reloadTab(\"null\");\n    }, 500);\n  };\n\n  // 关闭其他或关闭所有\n  const removeAll = async (isCloseAll?: boolean) => {\n    const { path, key } = selectedPanel;\n    console.log(\"selectedPanel\", path, key);\n    // 关闭所有就跳转到代码管理\n    // 关闭其他就跳转到右键选择的tab页上\n    // 情况一：在当前激活的tab页操作关闭其他，则会保留当前的tab页；\n    // 情况二：在其他未激活的Tab页操作关闭其他，则会跳转到鼠标操作的tab页\n    history.push(isCloseAll ? \"/miniapps\" : path);\n\n    // 当前已打开的tab页\n    // 如果右键操作的不是代码管理页（miniapps），且选择的是关闭其他，则当前打开的Tab页是代码管理页+ 右键点击所在的页面\n    // 否则：如果右键操作的是代码管理页（miniapps），或者选择的是关闭所有，则当前打开的Tab页是代码管理页\n    const nowPanes =\n      key !== \"/miniapps\" && !isCloseAll\n        ? [...initPane, selectedPanel]\n        : initPane;\n    setPanes(nowPanes);\n    // 如果是关闭全部，就跳转到代码管理页\n    setActiveKey(isCloseAll ? \"/miniapps\" : key);\n    storeTabs(nowPanes);\n  };\n\n  useEffect(() => {\n    const newPath = pathname + search;\n\n    // 当前的路由和上一次的一样，return\n    if (!panesItem.path || panesItem.path === pathRef.current) return;\n\n    // 保存这次的路由地址\n    pathRef.current = newPath;\n  });\n\n  useEffect(() => {\n    const index = panes.findIndex((_: CommonObjectType) => {\n      return _.key === panesItem.key;\n    });\n    // 无效的新tab，return\n    if (\n      !panesItem.key ||\n      (index > -1 && pathRef.current === panes[index].path)\n    ) {\n      setActiveKey(tabActiveKey);\n      return;\n    }\n\n    // 新tab已存在，重新覆盖掉（解决带参数地址数据错乱问题）\n    if (index > -1) {\n      panes[index].path = pathRef.current;\n      setPanes(panes);\n      setActiveKey(tabActiveKey);\n      return;\n    }\n    // 添加新tab并保存起来\n    panes.push(panesItem);\n    setPanes(panes);\n    setActiveKey(tabActiveKey);\n    storeTabs(panes);\n  }, [panes]);\n\n  const isDisabled = () => selectedPanel.key === \"/miniapps\";\n  // tab右击菜单\n  const menu = (\n    <Menu>\n      <Menu.Item\n        key=\"1\"\n        onClick={() => refreshTab()}\n        disabled={selectedPanel.path !== fullPath}\n      >\n        刷新\n      </Menu.Item>\n      <Menu.Item\n        key=\"2\"\n        onClick={(e) => {\n          e.domEvent.stopPropagation();\n          remove(selectedPanel.key);\n        }}\n        disabled={isDisabled()}\n      >\n        关闭\n      </Menu.Item>\n      <Menu.Item\n        key=\"3\"\n        onClick={(e) => {\n          e.domEvent.stopPropagation();\n          removeAll();\n        }}\n      >\n        关闭其他\n      </Menu.Item>\n      <Menu.Item\n        key=\"4\"\n        onClick={(e) => {\n          e.domEvent.stopPropagation();\n          removeAll(true);\n        }}\n        disabled={isDisabled()}\n      >\n        全部关闭\n      </Menu.Item>\n    </Menu>\n  );\n\n  const onRightClick = (e: CommonObjectType, panel: object) => {\n    e.preventDefault();\n    setSelectedPanel(panel);\n  };\n\n  return (\n    <div>\n      <Tabs\n        activeKey={activeKey}\n        className={style.tabs}\n        defaultActiveKey={defaultActiveKey}\n        hideAdd\n        onChange={onChange}\n        onEdit={onEdit}\n        onTabClick={onTabClick}\n        type=\"editable-card\"\n      >\n        {panes.map((pane: CommonObjectType) => (\n          <TabPane\n            closable={pane.closable}\n            key={pane.key}\n            tab={\n              <Dropdown\n                overlay={menu}\n                placement=\"bottomLeft\"\n                trigger={[\"contextMenu\"]}\n              >\n                <span onContextMenu={(e) => onRightClick(e, pane)}>\n                  {isReload &&\n                    pane.path === fullPath &&\n                    pane.path !== \"/401\" && (\n                      <SyncOutlined title=\"刷新\" spin={isReload} />\n                    )}\n                  {pane.title}\n                </span>\n              </Dropdown>\n            }\n          >\n            {reloadPath !== pane.path ? (\n              <pane.content path={pane.path} />\n            ) : (\n              <div style={{ height: \"100vh\" }}>\n                <Alert message=\"刷新中...\" type=\"info\" />\n              </div>\n            )}\n          </TabPane>\n        ))}\n      </Tabs>\n    </div>\n  );\n};\n\nexport default TabPanes;\n\n```\n\n\n### 新建 useTabActive 自定义 Hook\n\n\n```typescript\nconst noNewTab = [\"/login\", \"/\"]; // 不需要新建 tab的页面\ninterface PanesItemProps {\n  title: string;\n  content: Component;\n  key: string;\n  closable: boolean;\n  path: string;\n}\n\nexport const useTabActive = () => {\n  const { pathname, search } = useLocation();\n  const [panesItem, setPanesItem] = useState<PanesItemProps>({\n    title: \"\",\n    // @ts-ignore\n    content: null,\n    key: \"\",\n    closable: false,\n    path: \"\",\n  });\n  const pathRef: RefType = useRef<string>(\"\");\n  const [tabActiveKey, setTabActiveKey] = useState<string>(\"miniapps\");\n\n  useEffect(() => {\n    // 记录标签页\n    const { tabKey, title, component: Content } = getKeyName(pathname);\n    // 新tab已存在或不需要新建tab，return\n    if (pathname === pathRef.current || noNewTab.includes(pathname)) {\n      setTabActiveKey(tabKey);\n      return;\n    }\n    // 记录新的路径，用于下次更新比较\n    const newPath = search ? pathname + search : pathname;\n    pathRef.current = newPath;\n    setPanesItem({\n      title,\n      content: Content,\n      key: tabKey,\n      closable: tabKey !== \"/miniapps\",\n      path: newPath,\n    });\n    setTabActiveKey(tabKey);\n  }, [pathname]);\n\n  return { panesItem, tabActiveKey };\n};\n\n```\n\n\n### 将原来的 content 内容组件进行替换\n\n\n```typescript\nconst { panesItem, tabActiveKey } = useTabActive()\n\n<Layout.Content>\n  <TabPanes\n    defaultActiveKey=\"miniapps\"\n    panesItem={panesItem}\n    tabActiveKey={tabActiveKey}\n   />\n</Layout.Content>\n\n```\n\n\n# 问题\n\n\n## routes 路由重复渲染\n\n\n```typescript\nimport React, { useEffect } from \"react\";\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Redirect,\n} from \"react-router-dom\";\nimport { RouteConfigComponentProps } from \"react-router-config\";\nimport { renderRoutes } from \"@utils/routerUtils\";\nimport config from \"@utils/config\";\nimport { useDispatch } from \"react-redux\";\nimport Layout from \"@layouts/default\";\nimport Autho from \"@components/autho\";\nimport NotFined from \"@components/errorPage/404\";\nimport { useActions } from \"@utils/hook\";\n\n// 合并路由\nconst routes = [\n  ...require(\"@pages/manager_develop/router\").default,\n  ...require(\"@pages/miniapps/router\").default,\n  ...require(\"@pages/templates/router\").default,\n  ...require(\"@pages/log/router\").default,\n  ...require(\"@pages/dashboard/router\").default,\n  ...require(\"@pages/operations/router\").default,\n  { path: \"*\", exact: true, component: NotFined },\n];\n\nconst loginRoute = require(\"@pages/login/router\").default;\n\ntype RouteComponentType = React.ComponentType<RouteConfigComponentProps<any>>;\n\nconst Root: RouteComponentType = function (props) {\n  const dispatch = useDispatch();\n  // 取出操作Tab页的action\n  const { layouts } = useActions([\"layouts\"]);\n  window.router = props;\n  window.dispatch = dispatch;\n\n  if (!props.route) {\n    return null;\n  }\n  // @ts-ignore\n  if (props.pathname === \"/\") {\n    window.router.history.push(config.homeUrl);\n    layouts.setTab([\"/miniapps\"]);\n  }\n  // （1）这里渲染了一次\n  return renderRoutes(props.route.routes);\n};\n\nexport const rootRoutes = [\n  {\n    component: Root,\n    path: \"/\",\n    name: \"首页\",\n    routes: [\n      ...loginRoute,\n      {\n        // （2）这里渲染了一次\n        component: (props) => (\n          <Layout key=\"root_layout\">\n            {props.route && renderRoutes(props.route.routes)}\n          </Layout>\n        ),\n        routes: [\n          ...routes.map((item) => ({\n            ...item,\n            component: () => {\n              const C = item.component;\n              return (\n                <Autho block=\"nav\" funcCode={item.menuCode}>\n                  <C />\n                </Autho>\n              );\n            },\n          })),\n        ],\n      },\n    ],\n  },\n];\n\nconst RouterMap = () => {\n  return (\n    <Router basename={config.routerBaseName}>\n      {/* (3)这里渲染了一次*/}\n      {renderRoutes(rootRoutes)}\n    </Router>\n  );\n};\n\nexport default RouterMap;\n\n```\n\n\n这里一共在三个地方调用了`renderRoutes(rootRoutes)`进行了组件渲染，而且`rootRoutes`的结构比较诡异：\n\n\n```json\n[\n  {\n    path: \"/\",\n    name: \"首页\",\n    routes: [\n      {\n        path: \"/login\",\n        exact: true,\n      },\n      {\n        routes: [\n          {\n            path: \"/operations/error\",\n            exact: true,\n            name: \"错误日志\",\n            menuCode: \"error\",\n          },\n          {\n            path: \"/operations/errorinfo\",\n            name: \"错误详情\",\n            menuCode: \"errorinfo\",\n            exact: true,\n          },\n          {\n            path: \"/operations/performance\",\n            name: \"性能监控\",\n            menuCode: \"performance\",\n            exact: true,\n          },\n          {\n            path: \"*\",\n            exact: true,\n          },\n        ],\n      },\n    ],\n  },\n];\n\n```\n\n\n参考 cms 的路由结构：\n\n\n```json\n[\n  {\n    routes: [\n      {\n        path: \"/\",\n        exact: true,\n      },\n      {\n        path: \"/register_customer\",\n        name: \"customer\",\n        title: \"集团客户\",\n        exact: true,\n      },\n      {\n        path: \"/region_customer\",\n        name: \"customer\",\n        title: \"区域客户\",\n        exact: true,\n      },\n      {\n        path: \"/user_project_visit\",\n        name: \"customer\",\n        title: \"项目客户\",\n        exact: true,\n      },\n      {\n        path: \"*\",\n        exact: true,\n      },\n    ],\n  },\n];\n\n```\n\n\n或者另一种嵌套结构：\n\n\n```json\n[\n  {\n    path: \"/\",\n    name: \"首页\",\n    routes: [\n      {\n        path: \"/operations/error\",\n        exact: true,\n        name: \"错误日志\",\n        menuCode: \"error\",\n      },\n      {\n        path: \"/operations/errorinfo\",\n        name: \"错误详情\",\n        menuCode: \"errorinfo\",\n        exact: true,\n      },\n      {\n        path: \"/operations/performance\",\n        name: \"性能监控\",\n        menuCode: \"performance\",\n        exact: true,\n      },\n      {\n        path: \"*\",\n        exact: true,\n      },\n    ],\n  },\n];\n\n```\n\n\n## Layout 布局组件耦合严重\n\n\n```typescript\n<Layout style={{ minHeight: \"100vh\", height: \"100%\", overflow: \"hidden\" }}>\n  <Sider\n    collapsible\n    collapsed={collapsed}\n    onCollapse={setCollapsed}\n    style={{ position: \"fixed\", zIndex: 100, height: \"100%\" }}\n  >\n    <div style={{ display: \"flex\", padding: 16 }}>\n      {platforms.length && (\n        <Select\n          onSelect={(id) => {\n            select({ ...platforms.find((item) => item.component_id === id) });\n          }}\n          defaultValue={component_id}\n          className={styles.env}\n        >\n          {platforms.map((opt) => (\n            <Select.Option\n              key={opt.component_id}\n              value={opt.component_id}\n              title={opt.component_name}\n            >\n              {opt.component_name}\n            </Select.Option>\n          ))}\n        </Select>\n      )}\n      <LogoutOutlined onClick={logout} className={styles.logut} />\n    </div>\n    {renderMenu()}\n  </Sider>\n  <Layout style={{ marginLeft: collapsed ? \"80px\" : \"200px\" }}>\n    <Layout.Content>\n      <TabPanes\n        defaultActiveKey=\"miniapps\"\n        panesItem={panesItem}\n        tabActiveKey={tabActiveKey}\n      />\n    </Layout.Content>\n    <Footer style={{ textAlign: \"center\" }}>Copyright ©</Footer>\n  </Layout>\n</Layout>\n\n```\n\n\n可以看到，布局组件嵌套了包括小程序平台的业务组件逻辑，我这次也把 Tab 组件嵌套进去了，耦合有点强，后续维护成本高，后面考虑从路由出发，重新梳理下结构。\n对比 cms 的布局组件，就具有相对高的通用性\n\n\n```typescript\n<div\n  className=\"common-layout-default\"\n  style={{ background: props.bgColor || \"#fff\" }}\n>\n  <Header></Header>\n  <div\n    className=\"common-layouts-side-styles\"\n    style={{ maxWidth: props.maxWidth, minWidth: props.minWidth }}\n  >\n    <div className=\"layout-side\">\n      <SideNavigation></SideNavigation>\n    </div>\n    <div className=\"layout-content\">{props.children}</div>\n  </div>\n  <Footer></Footer>\n</div>\n\n```\n\n\n# 需要测试的功能点\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FkGiH4KxP7eKbIfUMnPhEcx9n1Ml.png)\n\n\n## 登录相关\n\n- 直接输入.../login 进行登录后标签页功能\n- 正常退出后重新登录后标签页功能\n\n## 权限相关\n\n- 无页面权限时的标签页功能\n- 目前路由和标签页是全匹配新建的，只有当路由完全一致时才会新建标签页，否则会显示无权限，例如`.../p-yunke-ai-third-platform/operations/error`和`.../p-yunke-ai-third-platform/operations/error/`，多了一个`/`都不行\n\n## 标签页功能\n\n\n默认代码管理页面为默认页面，无法关闭。\n\n- 新增标签页\n\n\t> 点击左侧菜单，如果打开的是不同的页面，则会新建 tab\n\n- 关闭标签页\n- 刷新当前页\n\n\t> 只有在当前激活的标签页才能进行刷新页面的操作\n\n- 关闭其它标签\n- 关闭全部标签\n\n\t> 规则：在当前已打开的 tab 页， 如果右键操作的不是代码管理页（miniapps），且选择的是关闭其他，则当前打开的 Tab 页是代码管理页+ 右键点击所在的页面  \n\t> 否则：如果右键操作的是代码管理页（miniapps），或者选择的是关闭所有，则当前保留的 Tab 页是代码管理页\n\n\n## 页面数据缓存\n\n\n目前支持在不同标签页切换时不会清空表单数据，但是刷新依然会清空（代码管理页面除外，单独做了刷新后依旧可以缓存数据）\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-10-12",
        "type": "Post",
        "slug": "peqmq8",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了一个 React 中后台系统多页签方案，包括标签页功能、页面数据缓存、权限相关等功能点。同时，还涉及到路由结构和 Layout 布局组件等方面的问题。本文旨在帮助读者理解多页签实现的原理及其应用场景。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "React 中后台系统多页签方案",
        "category": "技术分享",
        "tags": [
          "React"
        ],
        "status": "Archived",
        "urlname": "aea49f8c-44b2-44d5-a269-c0d1ff23625d",
        "updated": "2023-08-26 15:22:00"
      },
      "body": "",
      "realName": "React 中后台系统多页签方案",
      "relativePath": "/React 中后台系统多页签方案.md"
    },
    {
      "id": "969bc5c0-227e-40fc-bed8-74216c1c53a9",
      "doc_id": "969bc5c0-227e-40fc-bed8-74216c1c53a9",
      "title": "969bc5c0-227e-40fc-bed8-74216c1c53a9",
      "updated": 1693060980000,
      "body_original": "\n# 二进制与十进制之间的转换\n\n\n## 十进制转换成二进制\n\n\n### 取余法\n\n\n```java\npublic void test1() {\n  String numstr = \"\";\n  int de = 31;\n  while (de > 0) {\n    int res = de % 2; //除2 取余数作为二进制数\n    numstr = res + numstr;\n    de = de / 2;\n  }\n  System.out.println(numstr); //11111\n}\n```\n\n\n十进制整数转换为二进制整数采用“除 2 取余，逆序排列”法。具体做法是：用 2 整除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为小于 1 时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。\n\n\n### 原理\n\n\n假设十进制整数 A 化得的二进制数为`abcde`的形式，那么用上面的方法按权展开， 得 `A=a(2^4)+b(2^3)+c(2^2)+d(2^1)+e(2^0)` （后面的和不正是化十进制的过程吗） 假设该数未转化为二进制,除以基数`2`得 `A/2=a(2^4)/2+b(3^1)/2+c(2^2)/2+d(1^3)/2+e(2^0)/2` 注意：`e`除不开二，余下了！其他的绝对能除开，因为他们都包含`2`，而`e`乘的是`1`，他本身绝对不包含因数`2`，只能余下。所以可以得到余数`e`，`A/2 - e/2` 得到新的整数`a(2^3)+b(2^2)+c(2^1)+d(2^0)`，然后 再除以基数`2`余下了`d`，以此类推。当这个数不能再被`2`除时，先余掉的`e`位数在原数低，而后来的余数数位高，所以要把所有的余数反过来写。正好是`abcde`\n\n\n### 移位异或法\n\n\n```java\npublic void test2() {\n  int num = 31;\n  //定义一个String用于返回得到的二进制\n  String binary = \"\";\n  while (num > 0) {\n    //获取每一位\n    int bit = num & 1;\n    //将获取的位添加到字符串\n    binary = bit + binary;\n    //向右移一位\n    num = num >> 1;\n  }\n  System.out.println(binary);\n}\n```\n\n\n这种位运算运用了一个特点：任何二进制数与 1 进行与运算都会得到其最低的低位有效位，即二进制数的最后一个数本身。所以让这个正整数与 1 进行与运算，再右移一位后把最后一位消除掉（整数/2），再进行如此的循环操作就可以得到这个正整数的每一位二进制数，因为先运算的数位低，后运算的高，所以进行一个反向排列就可以得到该正整数对应的二进制数。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2020-04-17",
        "type": "Post",
        "slug": "oslix7",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:43:00.000Z",
        "title": "谈一谈二进制",
        "category": "技术分享",
        "tags": [
          "数据结构"
        ],
        "status": "Archived",
        "urlname": "969bc5c0-227e-40fc-bed8-74216c1c53a9",
        "updated": "2023-08-26 14:43:00"
      },
      "body": "",
      "realName": "谈一谈二进制",
      "relativePath": "/谈一谈二进制.md"
    },
    {
      "id": "af91247d-4fac-406b-8272-9a807defeefd",
      "doc_id": "af91247d-4fac-406b-8272-9a807defeefd",
      "title": "af91247d-4fac-406b-8272-9a807defeefd",
      "updated": 1693060980000,
      "body_original": "\n# 引言\n\n\n在 2018 年学习 Java 的 WEB 开发时，就慢慢变得上瘾起来，不太愿意用视频中给的静态网页来做项目。自己便用不太熟练的 JS 写了个注册网页，然后还用上了邮箱验证码，很喜欢这个网页。但是后来的项目一直用不上，直到最近做一个网站，刚好可以用到之前做的注册网页。就把它用更高级的 Angular JS 改造了一下，并改成了手机短信验证码，感觉更有成就感了！ 此次开发的短信微服务是利用 SpringBoot 快速搭建 ActiveMQ，因为我的云服务器和域名都在腾讯云，而且腾讯云短信每个月送 100 条短信，对我日常开发测试而言，根本用不完，所以使用腾讯云短信 API 完成发送短信，里面有好多技术都是第一次接触，所以写一下记录下细节。\n\n\n# 项目架构\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FuN9hIJs_P9C-Ybf_nfv6rgLcLFA.png)\n\n\n# 利用 SpringBoot 搭建 ActiveMQ\n\n\n## 创建 Maven 工程 letttgaco_sms_service（注意：打包方式为 jar）\n\n\n添加如下依赖至 pom.xml\n\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>cn.letttgaco.sms</groupId>\n\t<artifactId>letttgaco_sms_service</artifactId>\n\t<version>1.0</version>\n    <!-- 用Eclipse建SpringBoot项目会默认为jdk1.6 这里调整为jdk1.7 -->\n\t<properties>\n\t\t<java.version>1.7</java.version>\n\t</properties>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>1.4.0.RELEASE</version>\n\t</parent>\n\t<dependencies>\n        <!-- 起步依赖 SpringBoot核心部分就是依赖传递，它会自动引入WEB开发所需要的所有包，\n\t\t\t甚至连tomcat都内置了，所以这也是它搭建如此之快的原因了-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\t\t<!-- activtemq 只需要引入这一个依赖，它就会把所有用到的关联jar包都依赖传递过来-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-activemq</artifactId>\n\t\t</dependency>\n\t\t<!-- 腾讯云短信API -->\n\t\t<dependency>\n\t\t\t<groupId>com.github.qcloudsms</groupId>\n\t\t\t<artifactId>qcloudsms</artifactId>\n\t\t\t<version>1.0.6</version>\n\t\t</dependency>\n        <!-- springboot热部署 除了改pom文件，其他文件改了都不用重启，简直节省大量时间啊-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-devtools</artifactId>\n\t\t</dependency>\n\t</dependencies>\n</project>\n```\n\n\n## 创建引导类 Application.java\n\n\n这个类是程序的入口，启动它就能启动 SpringBoot 容器\n\n\n```java\npackage cn.letttgaco.sms;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n//@SpringBootApplication其实就是以下三个注解的总和\n//@Configuration： 用于定义一个配置类\n//@EnableAutoConfiguration ：Spring Boot会自动根据你jar包的依赖来自动配置项目。\n//@ComponentScan： 告诉Spring 哪个packages 的用注解标识的类 会被spring自动扫描并且装入bean容器。\npublic class Application {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n}\n```\n\n\n## 使用腾讯云 SMS 需要准备的信息\n\n\n在腾讯云开通短信服务，申请好短信签名和短信模板后，可以将相关配置储存到配置文件 application.properties（直接在 resources 中创建）中。[点击前往腾讯云短信官方文档](https://cloud.tencent.com/document/product/382/18071)\n\n\n```java\n// 短信应用SDK AppID\n\tint appid = 1400xxxx; // 1400开头\n\n    // 短信应用SDK AppKey\n    String appkey = \"qwertyuiopasdfghjkl123456789\";\n\n    // 需要发送短信的手机号码\n    String[] phoneNumbers = {\"21212313123\", \"12345678902\", \"12345678903\"};\n\n    // 短信模板ID，需要在短信应用中申请\n    int templateId = 7839; // NOTE: 这里的模板ID`7839`只是一个示例，真实的模板ID需要在短信控制台中申请\n    // 签名\n    String smsSign = \"腾讯云\"; // NOTE: 签名参数使用的是`签名内容`，而不是`签名ID`。这里的签名\"腾讯云\"只是一个示例，真实的签名需要在短信控制台申请。\n```\n\n\n## 创建腾讯云 SMS 工具类 SmsUtil.java\n\n\n```java\npackage cn.letttgaco.sms;\n\nimport java.io.IOException;\nimport java.util.Map;\n\nimport org.json.JSONException;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.env.Environment;\nimport org.springframework.stereotype.Component;\n\nimport com.github.qcloudsms.SmsMultiSender;\nimport com.github.qcloudsms.SmsMultiSenderResult;\nimport com.github.qcloudsms.httpclient.HTTPException;\n@Component\npublic class SmsUtil {\n\t//用来读取springboot的配置文件中的内容\n\t@Autowired\n\tprivate Environment env;\n    \n\t/**\n\t * 我只在配置文件中存储了appid和appkey,其他信息我选择从上层传过来\n\t * @param map\n\t */\n\tpublic void sendSms(Map<String,String> map) {\n\t\ttry {\n\t\t\t//因为我这里只会用到单个手机号，所以用map传输\n\t\t\tString phone = map.get(\"phone\");\n\t\t\tint templateId = Integer.parseInt(map.get(\"templateId\"));\n\t\t\tString smsSign = map.get(\"smsSign\");\n            //多个手机号可以在数组中填写多个\n\t\t\tString[] phoneNumbers = {phone};\n\t\t\tString code = map.get(\"code\");\n            //我的短信模板是“欢迎注册，{1}为您的验证码,请于5分钟内填写。”\n            //{1}对应下面数组中的第一个信息\n\t\t\tString[] params = { code };// 对应模板中的内容\n\t\t\t//从配置文件中获取信息\n\t\t\tint appid = Integer.parseInt(env.getProperty(\"appid\"));\n\t\t\tString appkey = env.getProperty(\"appkey\");\n\t\t\tSmsMultiSender msender = new SmsMultiSender(appid,appkey);\n\t\t\t// 签名参数未提供或者为空时，会使用默认签名发送短信\n\t\t\tSmsMultiSenderResult result = msender.sendWithParam(\"86\", phoneNumbers,templateId, params, smsSign, \"\", \"\");\n\t\t\tSystem.out.println(result);\n\t\t} catch (HTTPException e) {\n\t\t\t// HTTP响应码错误\n\t\t\te.printStackTrace();\n\t\t} catch (JSONException e) {\n\t\t\t// json解析错误\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// 网络IO错误\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n```\n\n\n## 创建消息的消费者 SmsListener.java\n\n\n利用 SpringBoot 甚至不用配置 ActiveMQ 的 xml 文件！！！！\n\n\n```java\npackage cn.letttgaco.sms;\n\nimport java.util.Map;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jms.annotation.JmsListener;\nimport org.springframework.stereotype.Component;\n/**\n * 消息的消费端,监听消息\n * @author LetTTGACO\n *\n */\n@Component\npublic class SmsListener {\n\t\n\t@Autowired\n\tprivate SmsUtil smsUtil;\n\t//destination=\"sendSms\"指消费端会监听名称为sendSms的队列\n\t@JmsListener(destination=\"sendSms\")\n\tpublic void sendSms(Map<String,String> map) {\n\t\tsmsUtil.sendSms(map);\n\t}\n\n}\n```\n\n\n## 创建消息的生产者\n\n\n```java\npackage cn.letttgaco.user.service.impl;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.jms.core.JmsMessagingTemplate;\n\nimport com.alibaba.dubbo.config.annotation.Service;\n\n\n/**\n * 消息的生产者\n * @author LetTTGACO\n *\n */\n@RestController\npublic class UserServiceImpl implements UserService {\n\t\n    @Autowired\n\tprivate JmsMessagingTemplate jmsMessagingTemplate;\n    \n\t@Value(\"${templateId}\")\n\tprivate String templateId;\n\t\n\t@Value(\"${smsSign}\")\n\tprivate String smsSign;\n\t\n\t@RequestMapping(\"/sendSms\")\n\tpublic void sendSms(String phone) {\n\t\t//将短信内容发送给ActiveMQ\n\t\tMap<String, String> map = new HashMap<String, String>();\n\t\tmap.put(\"phone\", phone);//手机号\n\t\tmap.put(\"templateId\", templateId);//签名模板\n\t\tmap.put(\"smsSign\", smsSign);//签名内容\n\t\tjmsMessagingTemplate.convertAndSend(\"sendSms\",phone);\n\t\t\n\t}\n\t\n}\n```\n\n\n# 测试\n\n\n> 注：可以在 application.properties 设置内置 tomcat 的访问端口号，默认为 8080。\n\n\n```xml\nserver.port=9080\n```\n\n\n## 启动 Application.java\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fog02flc86lD33GHFiEu9v_zJOA3.png)\n\n\n## 打开浏览器\n\n\n输入`http://localhost:9080/sendSms?phone=13333333333` 消息产生过程：\n\n1. 浏览器访问到控制层 sendSms()方法产生消息，并推送给 ActiveMQ。\n2. 消费者监听消息，接收 ActiveMQ 的消息，执行发送短信的任务。\n3. 手机收到短信\n\n---\n\n\n至此，短信微服务搭建成功！\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-04-02",
        "type": "Post",
        "slug": "qykfat",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "这篇文章介绍了如何使用 SpringBoot、ActiveMQ 和腾讯云 SMS 搭建 Java 短信微服务，并提供了详细的步骤和代码示例。",
        "更新时间": "2023-08-26T14:43:00.000Z",
        "title": "Java短信微服务开发 SpringBoot+ActiveMQ+腾讯云SMS",
        "category": "技术分享",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "af91247d-4fac-406b-8272-9a807defeefd",
        "updated": "2023-08-26 14:43:00"
      },
      "body": "",
      "realName": "Java短信微服务开发 SpringBoot+ActiveMQ+腾讯云SMS",
      "relativePath": "/Java短信微服务开发 SpringBoot+ActiveMQ+腾讯云SMS.md"
    },
    {
      "id": "49a7c01d-86a0-4cf9-bb14-7a55a4651215",
      "doc_id": "49a7c01d-86a0-4cf9-bb14-7a55a4651215",
      "title": "49a7c01d-86a0-4cf9-bb14-7a55a4651215",
      "updated": 1693063320000,
      "body_original": "\n# 引言\n\n\n在没有遇到[yuque-hexo](https://github.com/x-cold/yuque-hexo)之前，我博客是 Hexo+Github Pages 的部署方式：\n\n- 本地配置 Hexo 源码\n- 利用本地的 markdown 编辑器书写文章\n- Hexo 部署到 Github Pages/Coding Pages 上\n\n缺点也很明显：\n\n- 本地编辑器鱼龙混杂，使用手感一言难尽\n- 代码存储在本地不方便\n- GitHub Pages 国内访问速度令人堪忧（有段时间我还双重部署在了 Coding Pages 上，但是太不稳定了）\n\n本地的编辑器我是挑了又挑，总算找到一个手感还不错的[Typora](https://typora.io/)，但还是限于本地编辑的局限性和不方便，就懒的在本地写博客了。 在试用了语雀之后，发现语雀的编辑器太好用了，功能齐全，速度也快。后来我就一直在语雀上记录各种文章，但是并没有同步到博客。所在公司团队也用语雀来记录各种技术方案等文档。就这样我的博客几乎停更了一年。\n\n\n---\n\n\n直到我遇到了[yuque-hexo](https://github.com/x-cold/yuque-hexo)，突然就引起了我的兴趣。结合推荐的最佳实践文章，我没日没夜搞了好几天，终于搭建好了我的[新博客](https://1874.cool/)。\n\n\n# 开始\n\n\n我的新博客是基于\n\n\n> Hexo + 语雀 + yuque-hexo + web hook + severless + Github Actions\n\n\n托管平台我选择的是\n\n\n> 腾讯云的 COS 静态网站+自定义 CDN 加速\n\n\n至于为什么选择腾讯云 COS，是因为我的云服务器、域名、图床都使用的腾讯云的服务。再加上 COS 静态网站+CDN 加速的极致体验，让我心动了。而且我这个战五渣的个人博客的访问量对于收费的 COS 来说，也没多钱，就先做个试验吧，万一哪天~~博客火了~~（没钱了），再换也不迟。\n\n\n# 部署流程\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FvjX9uckFsBD3DDgkfoo-IZ3b8yJ.png)\n\n\n> PS：在Github Actions 持续集成 Docker 构建并部署 Node 项目到云服务器中，我已经将调用云函数改为调我自己的 node 项目了，再由 node 服务调用 github actions\n\n\n# 初始化 Hexo\n\n\n首先需要在本地初始化 hexo 仓库\n\n\n```shell\nnpx hexo-cli init blog\n```\n\n\n> npx 可以在不全局安装依赖情况下使用 hexo-cli 的命令\n\n\n初始化 hexo 成功后可以安装你喜欢的主题等配置，这里不作赘述。\n\n\n# 安装 yuque-hexo 插件\n\n\n官方文档：[yuque-hexo](https://github.com/x-cold/yuque-hexo)\n\n\n## 安装依赖\n\n\n```shell\nnpm i yuque-hexo\n```\n\n\n## 配置语雀\n\n1. 访问[工作台](https://www.yuque.com/dashboard)=>账户设置=Token=>新建 token 并配置好权限。**Access Token 即为 YUQUE_TOKEN**\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FiMisZ8z0CXkE_JhM4M3HYtVKH8Z.png)\n\n1. 访问[工作台](https://www.yuque.com/dashboard)=>账户设置=>账户设置=>个人路径，设置语雀的简易的个人路径（建议），**拿到个人路径。**\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FqEnqU_PHRB_3vaMUYJP2hjyTXfN.png)\n\n1. 新建一个放置博客的知识库（可见范围为互联网可见）\n2. 进入博客知识库，设置博客知识库的路径（建议），**拿到知识库的路径**。\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FmlvxdkN3QSn1fj3FDrQr6tDfi5r.png)\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fm5RGoda0mSPPczTrWRFxT4L16DS.png)\n\n\n## 配置 hexo\n\n\n拿到上述的语雀个人路径和知识库路径，进行 hexo 的配置。\n\n\n> package.json\n\n\n```json\n{\n  \"scripts\": {\n    \"hexo:build\": \"hexo generate\",\n    \"hexo:clean\": \"hexo clean\",\n    \"deploy\": \"hexo deploy\",\n    \"server\": \"hexo server\",\n    \"hexo\": \"npm run hexo:clean && npm run hexo:build && npm run server\",\n    \"yuque:clean\": \"yuque-hexo clean\",\n    \"yuque:sync\": \"yuque-hexo sync\",\n    \"yuque\": \"npm run yuque:clean && npm run yuque:sync\"\n  },\n  \"yuqueConfig\": {\n    \"postPath\": \"source/_posts\",\n    \"baseUrl\": \"https://www.yuque.com/api/v2\",\n    \"login\": \"语雀个人路径\",\n    \"repo\": \"知识库路径\",\n    \"onlyPublished\": true,\n    \"onlyPublic\": true\n  }\n}\n```\n\n\n# 配置腾讯云 COS\n\n\n当我们开始时我们需要做如下准备：\n\n- 域名 （需要备案，不备案可临时使用 COS 提供的临时域名）\n- 腾讯云账号 开通 COS 服务（建议使用 V5 版本 COS 控制台，如为 V4 版本可提交工单让后台升级为 V5 版本）\n\n参考资料：[一键部署 hexo 博客到腾讯云 COS 对象存储](https://werty.cn/2019/06/hexo/%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91COS%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/)\n\n\n## 开启静态网站\n\n\n访问 [腾讯云对象存储控制台](https://console.cloud.tencent.com/cos/bucket)=>基础配置=>静态网站， **开启静态网站功能。**\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FikwiN4n7oezapO3LJA6XYK6dZOQ.png)\n\n\n## 配置自定义 CDN 加速域名\n\n\n访问 [腾讯云对象存储控制台](https://console.cloud.tencent.com/cos/bucket)=>域名与传输管理=>自定义 CDN 加速域名，**配置自定义加速域名**\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fl2amqnJo65UKTDg7ozmsg5amAeH.png)\n\n\n## 解析域名\n\n\n访问[我的域名管理](https://console.cloud.tencent.com/cns)=>添加域名解析记录=>让域名指向上面的 CNAM 域名\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FiZKKLW8VFjLpUY4DPvvCdh-kePL.png)\n\n\n## 获取配置参数\n\n\n首先我们需要在腾讯云控制台获取下列所需的配置参数：\n\n\n| 名称        | 描述                     |\n| --------- | ---------------------- |\n| SecretId  | 开发者拥有的项目身份识别 ID，用以身份认证 |\n| SecretKey | 开发者拥有的项目身份密钥           |\n| Bucket    | COS 中用于存储数据的容器名称       |\n| Region    | Bucket 所在的地域信息。        |\n\n\n### 获取 SecretId 和 SecretKey\n\n\n进入[访问管理](https://console.cloud.tencent.com/cam/overview)=>[密钥管理](https://console.cloud.tencent.com/cam/capi)=>【新增密钥】=>**获取 SecretId 和 SecretKey**\n\n\n> 这里建议可以新增子用户，并设置权限，获取子用户的密钥，这里不作赘述。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FhvBmhn85j6XZG2H1SeRFFfH4v21.png)\n\n\n### 获取 bucket 和 region\n\n\n访问[腾讯云对象存储控制台](https://console.cloud.tencent.com/cos/bucket)=>基本信息，**获取存储桶名称和所属地域**\n\n\n### \n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FlY6trvKTOwRUZBKjO1N5Zs8K6N1.png)\n\n\n# 配置 Github Actions\n\n\n首先我们需要在 github 新建一个私有博客仓库（以下简称**博客仓库**），用于存放 hexo 源码，并与本地的 hexo 做关联。 所需的配置参数：\n\n\n| 名称          | 描述                 |\n| ----------- | ------------------ |\n| SECRET_ID   | 腾讯云的 SecretId      |\n| SECRET_KEY  | 腾讯云的 SecretKey     |\n| YUQUE_TOKEN | 语雀的 Access Token   |\n| BUCKET      | 腾讯云 COS 静态网站的存储桶名称 |\n| REGION      | 腾讯云 COS 静态网站的地域名称  |\n\n\n## 配置 Github\n\n\n### 获取 Github 访问 Token\n\n\n访问[GIthub Token 配置](https://github.com/settings/tokens/)=>Generate new token=>勾选必要的参数，生成 token\n\n\n> 注意下：这个 Token 只会出现一次，最好复制出来使用，如果忘记了，只能重新生成一个\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FussD8LZRmLdE4Bf7syjdq7j1Sps.png)\n\n\n> Github Token 用途：\n\n\t- 用来在流水线工作时，上传语雀文章到博客仓库。\n\t- 下文中需要用到这个 token 外部调用 Github Actions\n\n### 配置仓库 Actions secrets\n\n\n进入博客仓库的设置，配置 `secrets`。把之前获取的腾讯云的`SECRET_ID` 和 `SECRET_KEY`和语雀的`YUQUE_TOKEN`配置到这里。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fj3i2PVipW8AfTyzzJ8bW_voyFtR.png)\n\n\n> SECRET_ID、SECRET_KEY、BUCKET、REGION 用于上传静态网站文件到 COS YUQUE_TOKEN 用于拉取语雀的文章 GITHUB_TOKEN 不用配置，可以在 Github Actions 中直接获取\n\n\n## 配置博客仓库\n\n\n在根目录新增`.github/workflows/main.yaml`文件 这里直接上代码：\n\n\n```yaml\nname: Deplo To COS\n\non:\n\t# 本地测试时可以开启，部署后不建议开启，因为会涉及到更改一些配置，会多次频繁触发构建\n\t# 允许手动push触发\n  # push:\n  #    branches:\n  #      - master\n  # 允许外部仓库事件触发\n  repository_dispatch:\n    types:\n    \t# 这里的值需要和下文的云函数的event_type保持一致\n      - start\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: 检查分支\n        uses: actions/checkout@master\n\n      - name: 安装node环境\n        uses: actions/setup-node@master\n        with:\n          node-version: \"12.x\"\n\n      - name: 缓存依赖\n        uses: actions/cache@v1\n        id: cache\n        with:\n          path: node_modules\n          key: ${{runner.OS}}-${{hashFiles('**/package-lock.json')}}\n\n      - name: 安装依赖\n        if: steps.cache.outputs.cache-hit != 'true'\n        run: |\n          export TZ='Asia/Shanghai'\n          npm install\n\n      - name: 安装COS相关依赖\n        run: |\n          sudo pip install coscmd\n          sudo pip install tccli\n\n      - name: 配置COS\n        env:\n          SECRET_ID: ${{ secrets.SECRET_ID }}\n          SECRET_KEY: ${{ secrets.SECRET_KEY }}\n          BUCKET: ${{ secrets.BUCKET }}\n          REGION: ${{ secrets.REGION }}\n        run: |\n          coscmd config -a $SECRET_ID -s $SECRET_KEY -b $BUCKET -r $REGION\n          tccli configure set secretId $SECRET_ID\n          tccli configure set secretKey $SECRET_KEY\n          tccli configure set region $REGION\n\n      - name: 拉取语雀的文章\n        env:\n          YUQUE_TOKEN: ${{ secrets.YUQUE_TOKEN }}\n        run: |\n          npm run yuque:clean\n          npm run yuque:sync\n\n      - name: 配置Git用户名邮箱\n        run: |\n          git config --global user.name \"1874\"\n          git config --global user.email \"1225751694@qq.com\"\n\n      - name: 提交yuque拉取的文章到GitHub仓库\n        run: |\n          echo `date +\"%Y-%m-%d %H:%M:%S\"` begin > time.txt\n          git add .\n          git commit -m \"Refresh yuque json\" -a\n\n      - name: 推送文章到仓库\n        uses: ad-m/github-push-action@master\n        with:\n        \t# GITHUB_TOKEN不用配置在secrets\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: 生成静态文件\n        run: |\n          npm run hexo:clean\n          npm run hexo:build\n\n      - name: 上传文章到cos并刷新CDN\n        run: |\n          coscmd upload -rfs --delete ./public/ /\n          tccli cdn PurgePathCache --cli-unfold-argument --Paths https://1874.cool/ --FlushType flush\n```\n\n\n# 配置腾讯云函数\n\n\n> PS：在Github Actions 持续集成 Docker 构建并部署 Node 项目到云服务器中，我已经将调用云函数改为调我自己的 node 项目了，因为腾讯云函数现在（2022-07-16）好贵了！\n\n1. 访问[云数控制台](https://console.cloud.tencent.com/scf)=>新建云函数\n2. 模版选择从头开始，函数类型选择事件函数，运行环境选择 python2.7\n3. 在线编写函数代码\n\n```python\n# -*- coding: utf8 -*- \nimport requests \ndef main_handler(event, context):\n    r = requests.post(\"https://api.github.com/repos/LetTTGACO/1874/dispatches\",\n    json = {\"event_type\": \"start\"},\n    headers = {\"User-Agent\":'curl/7.52.1',\n              'Content-Type': 'application/json',\n              'Accept': 'application/vnd.github.everest-preview+json',\n              'Authorization': 'token Github访问token'})\n    if r.status_code == 204:\n        return \"This's OK!\"\n    else: \n        return r.status_code\n```\n\n\n> event_type 说明 event_type 值需要和 Github Actions 中配置的 repository_dispatch 的 types 值保持一致 Authorization 说明 Authorization 值为 字符串 “token + Github 访问 token”，不要忘了加 token\n\n1. 触发期配置=>自定义创建=>配置如下图所示\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fv6EtiOMRj1v9_23wK-di7YAsKfT.png)\n\n1. 部署完成后进入触发管理，最下面就是云函数地址\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FkhVJCWmBWFVsqWAW3uVCw5vVuDq.png)\n\n\n# 配置语雀 webhook\n\n\n访问博客知识库=>设置=>消息推送，选择其他渠道，设置机器人名称和上文获取到的云函数地址，选择触发条件\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fr_bBB8LiuuO4bZ-xPbS1rpXD1ir.png)\n\n\n> 发布文档和更新文档，需要选择文档有较大更新，推送给关注者，才会触发 webhook。 但是经过我的测试，一旦某一篇文章选择文档有较大更新，推送给关注者。后续的更新，不管选没选文档有较大更新，推送给关注者，都会触发 webhook。如果因为部署频繁导致出错的话，建议选择评审阶段触发。也可以每次通过测试按钮手动触发。\n\n\n# Done！发布文章\n\n\n无论是发布新文章还是更新删除等等操作，只要选择文档有较大更新，推送给关注者即可自动触发。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fg0QmVZZQc9nRAGKw9fdIzw4uMsH.png)\n\n\n# 常见问题\n\n\n## 语雀图片显示异常（防盗链）的解决办法\n\n\n由于语雀的图片由有防盗链的限制，会导致部署后，博客网站显示图片异常。 处理办法有两种：\n\n1. 在语雀上使用图片的时候，避开直接复制图片到语雀。先将图片上传到自己的图床后，直接使用 markdown 的图片语法：`![](https://xxxx.com/a.jpg)`插入图片到适当位置，例如：\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FioacWCiuPFjNteg-vR3cLc1WLxS.png)\n\n1. 为了不破坏语雀编辑器的体验，我修改了 yuque-hexo 的源代码，发布了[yuqe-hexo-with-cdn](https://github.com/LetTTGACO/yuque-hexo-with-cdn)插件。适配了将语雀中的图片上传到腾讯云 COS 图床后，将原有的语雀图片链接替换掉。\n\n## yuqe-hexo-with-cdn 插件\n\n\n替换依赖[yuque-hexo](https://github.com/x-cold/yuque-hexo)为[yuqe-hexo-with-cdn](https://github.com/LetTTGACO/yuque-hexo-with-cdn)\n\n\n```shell\nnpm i yuqe-hexo-with-cdn\n```\n\n\n> 目前 x-code 已经将我的方案合并到主分支了，可以直接使用yuque-hexo进行配置\n\n\n修改博客仓库的 package.json\n\n\n```json\n{\n  \"scripts\": {\n    \"hexo:build\": \"hexo generate\",\n    \"hexo:clean\": \"hexo clean\",\n    \"deploy\": \"hexo deploy\",\n    \"server\": \"hexo server\",\n    \"hexo\": \"npm run hexo:clean && npm run hexo:build && npm run server\",\n    \"yuque:clean\": \"yuque-hexo clean\",\n    \"yuque:sync\": \"yuque-hexo sync\",\n    \"yuque\": \"npm run yuque:clean && npm run yuque:sync\"\n  },\n  \"yuqueConfig\": {\n    \"postPath\": \"source/_posts\",\n    \"baseUrl\": \"https://www.yuque.com/api/v2\",\n    \"login\": \"语雀个人路径\",\n    \"repo\": \"知识库路径\",\n    \"onlyPublished\": true,\n    \"onlyPublic\": true,\n    \"imgCdn\": {\n      \"enabled\": true,\n      \"bucket\": \"COS存储桶名称\",\n      \"region\": \"COS地域名称\",\n      \"prefixKey\": \"blog-images\"\n    }\n  }\n}\n```\n\n\nimgCdn 语雀图片转腾讯云 COS 图床配置说明 注意：开启后会将匹配到的所有的图片都上传到 COS\n\n\n| **参数名**   | **含义**                | **默认值** |\n| --------- | --------------------- | ------- |\n| enabled   | 是否开启                  | false   |\n| bucket    | 腾讯 COS 的 bucket 名称    | -       |\n| region    | 腾讯 COS 的 region(地域名称) | -       |\n| prefixKey | 文件前缀                  | -       |\n\n\n> prefixKey 说明： 如果需要将图片上传到 COS 的根目录，那么 prefixKey 不用配置。 如果想上传到指定目录 blog/image 下，则需要配置 prefixKey 为“prefixKey”: “blog/image”。 目录名前后都不需要加斜杠\n\n\n**上传到 COS 图床也是需要腾讯云的**[**SECRET_ID 和 SECRET_KEY**](about:blank#GCUe2)**作为环境变量注入的，但在之前的流程中，我们已经在博客仓库的 secrets 注入了，所以这里就不需要再额外注入了。** **插件更多详情介绍请移步：**[yuqe-hexo-with-cdn](https://github.com/LetTTGACO/yuque-hexo-with-cdn)\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-01-19",
        "type": "Post",
        "slug": "roeayv",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "该文档介绍了如何使用语雀云端写作Hexo+Github Actions+COS进行持续集成，以及如何配置腾讯云函数和语雀webhook，最后介绍了一些常见问题及解决方案。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "语雀云端写作Hexo+Github Actions+COS持续集成",
        "category": "技术分享",
        "tags": [
          "CI/CD",
          "Hexo"
        ],
        "status": "Archived",
        "urlname": "49a7c01d-86a0-4cf9-bb14-7a55a4651215",
        "updated": "2023-08-26 15:22:00"
      },
      "body": "",
      "realName": "语雀云端写作Hexo+Github Actions+COS持续集成",
      "relativePath": "/语雀云端写作Hexo+Github Actions+COS持续集成.md",
      "needUpdate": 1
    },
    {
      "id": "e9a8c0ae-05f5-4bb4-b40b-2df593e8814d",
      "doc_id": "e9a8c0ae-05f5-4bb4-b40b-2df593e8814d",
      "title": "e9a8c0ae-05f5-4bb4-b40b-2df593e8814d",
      "updated": 1693060920000,
      "body_original": "\n# 前言\n\n\n在优化小程序发布平台的时候，当时研究代码的时候，发现同事写的一段代码，是用来做异步任务切割的，当时很好奇这个任务切割可以解决什么问题。\n\n\n# 调研\n\n\n由于微信那边的限制，一次性只能同时发起 6 个接口请求，如果发起的更多就会报错。所以才有了这个任务切割的代码，但是在我实际的测试过程中发现，同时发起的 6 个请求，其实还是串行执行的，上一个结束之后才会调用下一个，然后我就对比了各个方式的调用结果。\n\n\n# 测试\n\n\n## 一次性发送 100 个请求\n\n\n```javascript\nconst post = () => {\n  return new Promise((resolve, reject) => {\n    fetch('http://localhost:18740/users/1').then((res) => res.json()).then((r) => {\n      console.log(r);\n      resolve(r)\n    })\n  })\n}\n\nfor (let index = 0; index < 100; index++) {\n  post()\n}\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FqXLYewoSqF2lUHzTtHkn4eZqlQL.png)\n\n\n## await 串行调用 100 个接口\n\n\n```javascript\nconst post = () => {\n  return new Promise((resolve, reject) => {\n    fetch('http://localhost:18740/users/1').then((res) => res.json()).then((r) => {\n      console.log(r);\n      resolve(r)\n    })\n  })\n}\n\nfor (let index = 0; index < 100; index++) {\n  await post()\n}\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fm_bNFGmIkCQEzLsQMtBVnydBvV7.png)\n\n\n## 分组调用，等待上一组接口全部返回再调用下一组\n\n\n```javascript\nconst flatJobs = (jobs, concurrent_count) => {\n  const concurrentCount = concurrent_count || 6\n  return jobs\n    .reduce((queues, c, i) => {\n      if (i % concurrentCount > 0) {\n        queues[queues.length - 1].push(c)\n        return queues\n      }\n\n      queues.push([c])\n      return queues\n    }, [[]])\n}\n\n\nconst runSerialJobsQueue = async (jobs) => {\n  let p = 0\n  const res = []\n  while (p < jobs.length) {\n    const part_res = await Promise.all(jobs[p].map(fn => fn().catch(() => false)))\n    res.push(...part_res)\n    ++p\n  }\n  return res\n}\n\nconst post = () => {\n  return new Promise((resolve, reject) => {\n    fetch(\"http://localhost:18740/users/1\").then((res) =>res.json()).then(r => resolve(r))\n  })\n}\n\nconst rows = Array(100).fill(0)\n\nconst jobs = rows.map((row) => {\n  return async () => {\n    const res = await post(row)\n    return { res }\n  }\n})\n\nconst j = flatJobs(jobs)\nrunSerialJobsQueue(j)\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fg43nh7sWluHTdS1FccEUWY6ye5d.png)\n\n\n## 连接程池调用，只要有连接调用结束释放连接，便开始新的连接\n\n\n```javascript\nasync function asyncPool(poolLimit, array, iteratorFn) {\n  // if (shouldAssert) {\n  //   assertType(poolLimit, \"poolLimit\", [\"number\"]);\n  //   assertType(array, \"array\", [\"array\"]);\n  //   assertType(iteratorFn, \"iteratorFn\", [\"function\"]);\n  // }\n  const ret = [];\n  const executing = [];\n  for (const item of array) {\n    const p = Promise.resolve().then(() => iteratorFn(item, array));\n    ret.push(p);\n\n    if (poolLimit <= array.length) {\n      const e = p.then(() => executing.splice(executing.indexOf(e), 1));\n      executing.push(e);\n      if (executing.length >= poolLimit) {\n        await Promise.race(executing);\n      }\n    }\n  }\n  return Promise.all(ret);\n}\n\n\n\nconst post = () => {\n  return new Promise((resolve, reject) => {\n    fetch('http://localhost:18740/users/1').then((res) => res.json()).then((r) => {\n      console.log(r);\n      resolve(r)\n    })\n  })\n}\n\n\nconst results = asyncPool(6, Array(100).fill(0), post);\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FmjVFdQv6FKc8HpFVo4Ciy3bU9h6.png)\n\n\n# 思考\n\n\n可以看出，无论是先循环中一次性跑完异步请求，还是 await 串行去跑接口，或者说分组用 promise.all 去执行，或者用线程池去执行，100 个接口的用时都几乎没有差别。那就有了新的疑问，既然还是一个个处理的，为什么超过 6 个，微信就给限制了，反正也是一个个处理的。\n\n\n经过分析，其实这 100 个接口虽然是同时发起，也就是并发的，但是却不是同时执行（并行）的，微信既限制了并发量，也限制了并行量，所以才导致了这样的结果。\n\n\n当然，微信去限制并发和并行是为了安全考虑的，一次性发送太多接口，会导致系统炸了！\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-08-14",
        "type": "Post",
        "slug": "epmi4g",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "关于接口的请求的一些思考",
        "category": "技术分享",
        "tags": [
          "并发"
        ],
        "status": "Archived",
        "urlname": "e9a8c0ae-05f5-4bb4-b40b-2df593e8814d",
        "updated": "2023-08-26 14:42:00"
      },
      "body": "",
      "realName": "关于接口的请求的一些思考",
      "relativePath": "/关于接口的请求的一些思考.md"
    },
    {
      "id": "9a588e82-f423-4887-a07b-159f06e02b09",
      "doc_id": "9a588e82-f423-4887-a07b-159f06e02b09",
      "title": "9a588e82-f423-4887-a07b-159f06e02b09",
      "updated": 1693060920000,
      "body_original": "\n# 引言\n\n\n最近在调试开发环境的时候，`node`环境各种问题，索性全部重新安装一次，这里记录下整个安装过程。\n\n\n# 卸载\n\n\n## 卸载 nvm\n\n\n当我们直接在终端输入`nvm`时，提示告诉我们，当卸载`nvm`时还需要取环境变量中将相关的变量全部删除才行。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FlfNndBLq_OVgSi11jH36W2r-n-3.png)\n\n1. 删除`～/.nvm`文件夹\n\n```shell\nrm -rf ~/.nvm\n```\n\n1. 如果有以下文件，依次用文本编辑器打开，并删除其中的 nvm 相关的变量\n- `~/.profile`\n- `~/.bash_profile`\n- `~/.zshrc`\n- `~/.bashrc`\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FnEHSYHDcKow3IZtIdWH7hrFdVQy.png)\n\n\n## 卸载 node、yarn、npm\n\n\n检查以下目录，将`node`、`yarn`、`npm`相关的文件和文件夹全部删除\n\n- `~/`\n- `/usr/local/bin`\n\n# 安装\n\n\n## 安装 node（可选）\n\n\n由于项目中经常会使用`git hooks`来规范代码，而其脚本指定的node地址一般指向的是`/usr/local/bin/node`，如果你使用`nvm`管理`node`版本的话，node地址一般是`/Users/xxx/.nvm/versions/node/v12.22.12/bin/node`，所以在运行时可能会报错`node command not found`。而我自己用的是`WebStorm`，就有这个问题。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FrqJL1Fp9eHIZXC8eNYbEkrnPtZt.png)\n\n\n解决办法有两种：\n\n1. 建立软链接，将`nvm`中的`node`指向`/usr/local/bin/node`，相当于创建了一个快捷方式。\n\n```shell\nln -s /Users/fangpengfei/.nvm/versions/node/v12.22.12/bin/node /usr/local/bin/node\n```\n\n\n> 但是这种建立软链方式可能会有个问题：用户对`/usr/local/bin`文件夹的访问权限不够（即使使用了`sudo`），这就是另一个问题了，可以谷歌一下，这里不再赘述。\n\n1. **先从官网安装包安装**`node`**（推荐）**\n\n因为安装包会直接将`node`安装在`/usr/local/bin/node`中，这样系统也有了一份`node`。值得注意的是，这里我还建议可以在未安装`nvm`前，先全局安装`yarn`和`pnpm`（需要的话），这样后面也不需要将`nvm`中的`yarn`软链到`/usr/local/bin/yarn`上。\n\n\n## 安装 nvm\n\n\n当然你也可以直接安装`nvm`，利用`nvm`管理`node`版本，后续如果出现上述问题，再用软链方式解决就行。 进入`nvm`的[github](https://github.com/nvm-sh/nvm#install--update-script=)官网，用`curl`安装`nvm`\n\n\n```shell\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\n```\n\n\n利用`nvm`安装`node`，这里我从官网安装的`node`版本是`v16.14.2`，所以`nvm`我再装一个`v12`版本的，并且设置为`default`版本以应对大部分项目的`node`版本要求。\n\n\n```shell\nnvm install 12nvm alias default 12\n```\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FuB-VClzE71G3G6Nr7YA7qRZgY1e.png)\n\n\n# 大功告成！\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-04-22",
        "type": "Post",
        "slug": "is8lw3",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何在MacOS上卸载nvm/node并重新安装。包括卸载nvm、node、yarn、npm的步骤，以及安装node和nvm的过程。同时，还提供了解决node地址问题的两种方法。",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "MacOS开发环境治理-卸载nvm/node并重新安装",
        "category": "技术分享",
        "tags": [
          "Node"
        ],
        "status": "Archived",
        "urlname": "9a588e82-f423-4887-a07b-159f06e02b09",
        "updated": "2023-08-26 14:42:00"
      },
      "body": "",
      "realName": "MacOS开发环境治理-卸载nvm!node并重新安装",
      "relativePath": "/MacOS开发环境治理-卸载nvm!node并重新安装.md"
    },
    {
      "id": "88e73589-a9b1-4652-b05e-116b288aa5b8",
      "doc_id": "88e73589-a9b1-4652-b05e-116b288aa5b8",
      "title": "88e73589-a9b1-4652-b05e-116b288aa5b8",
      "updated": 1693060920000,
      "body_original": "\n在使用`springmvc+mybatis`分页插件`pagehelper`时，只在业务层引用了 mybatis 的分页插件的 jar 包而表现层接收时没有引用，会报这样的警告：\n\n\n```java\n警告: Hessian/Burlap: 'com.github.pagehelper.Page' is an unknown class in WebappClassLoader\ncontext:\ndelegate: false\nrepositories:\n----------> Parent Classloader:\nClassRealm[plugin>org.apache.tomcat.maven:tomcat7-maven-plugin:2.2\njava.lang.ClassNotFoundException: com.github.pagehelper.Page\n```\n\n\n解决办法：`mybatis`的分页`pagehelper`插件依赖于`mybatis`的相关 jar 包，因此解决办法是在表现层同时加入分页`pagehelper`的`jar`包和`mybatis`的相关 jar 包，如下:\n\n\n```xml\n<dependency>\n\t<groupId>org.mybatis</groupId>\n\t<artifactId>mybatis</artifactId>\n</dependency>\n<dependency>\n\t<groupId>org.mybatis</groupId>\n\t<artifactId>mybatis-spring</artifactId>\n</dependency>\n<dependency>\n\t<groupId>com.github.miemiedev</groupId>\n\t<artifactId>mybatis-paginator</artifactId>\n</dependency>\n<dependency>\n\t<groupId>com.github.pagehelper</groupId>\n\t<artifactId>pagehelper</artifactId>\n</dependency>\n```\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-02-08",
        "type": "Post",
        "slug": "ywdq07",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "Mybatis分页插件警告解决办法",
        "category": "技术分享",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "88e73589-a9b1-4652-b05e-116b288aa5b8",
        "updated": "2023-08-26 14:42:00"
      },
      "body": "",
      "realName": "Mybatis分页插件警告解决办法",
      "relativePath": "/Mybatis分页插件警告解决办法.md"
    },
    {
      "id": "4df7c95e-9f18-437e-a4fa-34f2dfd07c74",
      "doc_id": "4df7c95e-9f18-437e-a4fa-34f2dfd07c74",
      "title": "4df7c95e-9f18-437e-a4fa-34f2dfd07c74",
      "updated": 1693060920000,
      "body_original": "\n# Access-Control-Allow-Origin 相关\n\n\n## 问题出现\n\n\nNo ‘Access-Control-Allow-Origin’ header is present on the requested resource，但是 status 200 OK\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fipa7Fg68MI7orwWfEZmwY-oNzX4.png)\n\n\n```text\nAccess to XMLHttpRequest at 'http://xxx/get' from origin 'http://ccc' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\n\n这种现象是服务器端后台允许 OPTIONS 请求,并且接口也允许 OPTIONS 请求,但是头部匹配时出现不匹配现象. 比如 origin 头部检查不匹配,比如少了一些头部的支持(如常见的 X-Requested-With 头部),然后服务端就会将 response 返回给前端,前端检测到这个后就触发 XHR.onerror,导致前端控制台报错.\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FkHkJ6Q9H_zop1YV_KAhWivdtRhD.png)\n\n\n## 解决办法\n\n\n增加跨域中间件：\n\n\n```javascript\nimport { Context } from \"koa\";\n\n/**\n * 跨域白名单\n */\nenum WhiteList {\n  DEV = 'http://dev-xxx.com:6666',\n  TEST_HTTP = 'http://test.com',\n  TEST_HTTPS = 'https://test.com',\n  PROD_HTTP = 'http://prod.com',\n  PROD_HTTPS = 'https://prod.com',\n}\n\n/**\n * 跨域中间件\n * @param ctx 上下文拿到Origin来判断是否是跨域请求\n * @param next 如果是跨域就设置允许的源和Headers,再放行\n */\nexport async function CORSMiddleware(ctx: Context, next: (err?: any) => Promise<any>): Promise<any> {\n  // 获取 Origin 请求头，只有非简单请求时，浏览器才会带上Origin字段来标识\n  const requestOrigin = ctx.get('Origin');\n\n  // 不管有没有跨域都要设置 Vary: Origin\n  ctx.set('Vary', 'Origin')\n\n  const whiteList = Object.values(WhiteList) as string[]\n\n  // 1.如果没有设置，说明没有跨域，跳过\n  // 2.或者 不在域名白名单中这直接跳过\n  if (!requestOrigin || !whiteList.includes(requestOrigin)) {\n    return await next();\n  }\n  // 设置响应头\n  ctx.set('Access-Control-Allow-Origin', requestOrigin)\n  // 跨域解决\n  ctx.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');\n  ctx.set('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');\n  // 该字段可选，用来指定本次预检请求的有效期，单位为秒。\n  // 当请求方法是PUT或DELETE等特殊方法或者Content-Type字段的类型是application/json时，服务器会提前发送一次请求进行验证\n  // 下面的的设置只本次验证的有效时间，即在该时间段内服务端可以不用进行验证\n  ctx.set(\"Access-Control-Max-Age\", '86400');\n  return await next();\n}\n```\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-09-03",
        "type": "Post",
        "slug": "fgligg",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "跨域场景汇总",
        "category": "技术分享",
        "tags": [
          "Bugs"
        ],
        "status": "Archived",
        "urlname": "4df7c95e-9f18-437e-a4fa-34f2dfd07c74",
        "updated": "2023-08-26 14:42:00"
      },
      "body": "",
      "realName": "跨域场景汇总",
      "relativePath": "/跨域场景汇总.md"
    },
    {
      "id": "ed1e7737-88f0-4197-8f29-47ceb92792f0",
      "doc_id": "ed1e7737-88f0-4197-8f29-47ceb92792f0",
      "title": "ed1e7737-88f0-4197-8f29-47ceb92792f0",
      "updated": 1693060920000,
      "body_original": "\n# 引言\n\n\n年末了，趁着项目排期相对空闲，抽空阅读[吴浩麟](https://github.com/gwuhaolin)老师的[《深入浅出 Webpack》](https://webpack.wuhaolin.cn/)这本书，准备搞一搞 webpack 中的点点滴滴，出一个 webpack 优化专题。刚好最近在想着做一个适合团队内部的前端中后台脚手架，来学习学习嘿嘿。\n\n\n# 配置\n\n\n## 在 webpack4.0 中使用 hard-source-webpack-plugin\n\n\n```shell\nnpm install hard-source-webpack-plugin -D\n```\n\n\n```javascript\n// webpack.config.js\nconst HardSourceWebpackPlugin = require('hard-source-webpack-plugin');\n\nmodule.exports = {\n  entry: // ...\n  output: // ...\n  plugins: [\n    new HardSourceWebpackPlugin()\n  ]\n}\n```\n\n\n具体配置可以参考官方文档[hard-source-webpack-plugin](https://github.com/mzgoddard/hard-source-webpack-plugin)\n\n\n## 在 webpack5.0 中使用 cache 选项\n\n\n在 webpack5.0 中，此插件的实现已内置到 cache 选项中，所以不能在 5.0 版本中使用，会报错！！\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FoiMFr2CMDshCw_MGF4WeqIKUYQA.png)\n\n\n因为在 webpack5.0，这个依赖被删除了！\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FmDnTPy5j_FwsIp5D0jp-34_JaJm.png)\n\n\n我在[issue](https://github.com/mzgoddard/hard-source-webpack-plugin/issues/514)中找到了可以使用 cache 选项来配置。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FpZWmwu0ixR5JgawCmB6DeAn_3f-.png)\n\n\n使用说明：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FvUqfwsno_MaITg4zneUPJyBrysU.png)\n\n\n具体配置文档请参考[webpack5.0#cache](https://webpack.js.org/configuration/other-options/#cache)\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-02-06",
        "type": "Post",
        "slug": "kolyq9",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了在Webpack中使用多进程/多实例解析资源的方法，以及优化Webpack性能的两种方法：在Webpack4中使用hard-source-webpack-plugin插件，在Webpack5中使用cache选项。本文还提到了使用hard-source-webpack-plugin插件的注意事项。",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "Webpack配置-多进程/多实例解析资源",
        "category": "技术分享",
        "tags": [
          "Webpack"
        ],
        "status": "Archived",
        "urlname": "ed1e7737-88f0-4197-8f29-47ceb92792f0",
        "updated": "2023-08-26 14:42:00"
      },
      "body": "",
      "realName": "Webpack配置-多进程!多实例解析资源",
      "relativePath": "/Webpack配置-多进程!多实例解析资源.md"
    },
    {
      "id": "d2a19be4-4efc-428a-9ebb-0a85e340290d",
      "doc_id": "d2a19be4-4efc-428a-9ebb-0a85e340290d",
      "title": "d2a19be4-4efc-428a-9ebb-0a85e340290d",
      "updated": 1697646660000,
      "body_original": "\n## 前言\n\n\n先介绍《我的笔记管理法》的启蒙老师——[Flomo 101](https://help.flomoapp.com/community/tips/idea.html)，正因为看了这个栏目，才让我总结出属于自己的工作流程，或者说笔记管理法。专栏中推荐的[《卡片笔记写作法：如何实现从阅读到写作 》](https://weread.qq.com/web/bookDetail/3d8326d072552e803d87c41)这本书也让我受益匪浅，我的卡片笔记就是从这本书开始的。\n\n\n## 《卡片笔记写作法：如何实现从阅读到写作 》\n\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/13a508a2-de5b-47bc-b05f-367d31c13e36/c3f48017-f17a-4627-9385-322c7fba7ff0/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20231018%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231018T163342Z&X-Amz-Expires=3600&X-Amz-Signature=8019df005e457d61dfe46a6a6ac59cb8738b95b0703c5390984d90bad373aba1&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n> **「我的研究课题是社会理论，持续时间是30年，成本为零」——尼克拉斯·卢曼**\n\n\n你是否会产生疑问：\n\n- 30年的研究，为什么成本会是零呢？\n- 他是怎么做到的？\n\n## 继续带着疑问\n\n- 你是否时常有一些突然蹦出的想法，然而因为没有及时记录下来就再也没想起来过，或者用到的时候却记不起详细的内容\n- 你是否在 Github 点了 Star 却再也没有去研究过，收藏 = 我看过了\n- 从0写文档时的艰难，苦于找不到资料和论点\n- 想搭建一个博客网站却不知道写什么，好不容易搭建的博客却大部份时间花在装修上\n- 你是否买了 Kindle 却拿来当泡面桶\n\n以上问题有3个关键节点：记录、回顾、分享。读完《卡片笔记写作法》，这些问题将全部迎刃而解。\n\n\n## **什么是卡片笔记法**\n\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/13a508a2-de5b-47bc-b05f-367d31c13e36/ff184069-f6cb-4410-91a3-44c7c895000e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20231018%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231018T163342Z&X-Amz-Expires=3600&X-Amz-Signature=14e63b3af1fd3976a9ede1e7ac5941793bec5f59f2561095976ddd667021937e&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n从本质上讲，卡片笔记法不是一种**「技巧」**，而是一个**「流程」**，一种存储和组织知识、扩展记忆、生成新连接和想法的方法。\n\n\n简单来说就是，把你感兴趣或者觉得自己未来会用到的知识收集起来，然后用一种标准化的方法处理这些笔记，确保颗粒度和标准统一，最后建立笔记之间的联系，供日后有需要的时候检索使用。\n\n\n卡片笔记法充当着**第二大脑**的角色。\n\n\n## 为什么要记录卡片\n\n\n> 试想一下如果你的文章并不是从一张白纸开始写起，而是已经有人把你准备了初稿，包括所有的参考资料、引文和一些非常高明的想法。唯一要做的就是修改这个初稿，然后把分享出去。你可能要找出错别字、修改某些句子的措辞，删除多余的句子，也许还要增加几段话来补论证漏洞。不过这个时候其实任务已经相当明确了，没有什么是在几天内完成不了的，当然也没有说很么是难以激励自己去做的。当终点就在眼前的时候，每个人都有动力。显然从初稿到成稿这一步没有任何问题。——《卡片笔记写作法》\n\n\n记录卡片，就是构建自己的知识网络的第一步，记录的同时也代表着思考，而思考是会有连锁反应的。通过和已有笔记的关联，诞生新的想法，继续记下来。\n\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/13a508a2-de5b-47bc-b05f-367d31c13e36/5fb9f447-dd22-4fbc-b3ee-566ce9ddb894/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20231018%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231018T163342Z&X-Amz-Expires=3600&X-Amz-Signature=8e0180d213aa0d53d655c03b274024a0f3ea2e7b8c97ce61029fa314ad99b9c1&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n在某种程度来说，知识网络的构建和「躺平说」不冲突，甚至我觉得知识网络的构建在一定程度上就是为了「躺平」。\n\n\n个人认为躺平更多的是对待工作对待生活的态度，享受生活，主打的就是一个轻松，这是躺平的核心逻辑。\n\n\n但无论你躺平与否，生活中、工作中遇到的问题和抉择是不会消失的。每当做抉择的时候，我们会更倾向于自我认为的性价比高的选择，能让我们用更少的时间、精力、金钱去面对这个问题。\n\n\n**而知识网络的构建就是为了消除不确定性，为了更好的决策，在这一点上和躺平不谋而合**\n\n\n## **回顾的重要性**\n\n\n相比之下，传统的笔记系统是为了找到你意图搜索的东西，让你的大脑疲于回忆，而卢曼卡片盒笔记系统则是为了给你呈现你已经忘记的想法，让你的大脑专注于思考。\n\n\n典型的日常工作包括以下全部或部分环节，比如阅读并记笔记；对卡片盒中的笔记建立关联，这个过程又会激发你新的想法；记下这些想法，并将它们添加到讨论中；写到纸上时，你又发现论点中有一个漏洞，于是到卡片笔记系统中去查找缺失的链接。\n\n\n想法就是在这样回顾的过程中不断产生和修正。\n\n\n## **分享你的洞见**\n\n\n> 费曼学习法：就是学任何东西，如果你能用简单的话，用自己的话，不带行话术语，说给八十岁的老太太听，说给八岁的小孩听。当这些人都听懂了，你就把这个概念搞明白了。\n\n\n我们平时写博客写分享也是同样的道理，当我将学习成果分享出去的时候，我会不断的给自己挑刺，寻找漏洞并补上，相当于加深和回顾你之前记下来的知识点。\n\n\n分享是为了让你更了解知识，而不是装逼，社区的反馈是为了让你得到持续不断的正反馈，持久化这个过程。\n\n\n写博客、参与开源社区项目等都是非常好的正反馈和技术进步。\n\n\n分享也是为了某个领域的精进。\n\n\n**知识是用于生产的，信息本质上是为了消除不确定性，而知识是为了更好的决策，为了塑造更好的自己。**\n\n\n## **Flomo**\n\n\n而Flomo就是从卢曼的卡片笔记管理法孕育出来的符合现代实践的笔记软件。\n\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/13a508a2-de5b-47bc-b05f-367d31c13e36/4b99f021-6f98-43dc-9306-1eb2784d945f/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20231018%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231018T163342Z&X-Amz-Expires=3600&X-Amz-Signature=93f2a6adccca5712e21942146089cdc7f96e33c5bd5035e3a0b0a51a294c0ae4&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\nflomo 101的理念让我非常感慨。\n\n\n“我教你如何阅读，如何思考，如何记笔记，当然我也卖软件。虽然我意识到你学会了之后，很有可能选择比我更优秀更强大的笔记软件。但其实这已经达到我布道的目的了。”\n\n\n我甚至觉得，所有工具类的产品都应该有101专栏，既然做了这个产品肯定是觉得大家可能需要它，并且为其投入精力。那么就应该花时间教大家为什么需要这款软件。我觉得这才是产品创始人应该要做的。\n\n\nFlomo笔记软件也在我的笔记管理法中充当了非常重要的角色。\n\n\n## **我的笔记管理法**\n\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/13a508a2-de5b-47bc-b05f-367d31c13e36/a51cf3a6-517f-448c-8800-c2d427e08c47/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20231018%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231018T163342Z&X-Amz-Expires=3600&X-Amz-Signature=facf0d62a103c6f96e26cd3858e8fa84bece402ae3ef9e55c0522c36216e4845&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n我的笔记管理法里面涉及几个信息输入和输出时的重要的场景和需求：\n\n- 突然蹦出的想法、计划，我想随便找个地方写下来\n- 在专注的环境中阅读吸收到的思考，我可以很全面的记下来，也可能先临时记下来，专注阅读\n- 在嘈杂/零碎的环境中吸收到的思考，我想先随便找个地方写下来，并且阅读的文章、视频可以先保存下来等到在专注的环境中仔细阅读\n\n在实践过程中，我发现【突然蹦出的想法】次数非常的多，甚至在专注阅读时看到某段话所产生的读书笔记其实也是一些自己的零碎思考，只不过有时候感悟比较深刻，有时候只是一点点思考。\n\n\n总结下来，Flomo这款软件充当了我非常重要的作用，它具备的快捷记录、标签分类、双向链接，在我的笔记管理流程中属于所有**灵感的汇集地。**\n\n- 在嘈杂/零碎环境中所依赖的文档收藏/稍后阅读需求，则用 Readwise Reader 和 Raindrop 补充。\n- 文档的沉淀，我用更面向文档形式的Notion和语雀来补充。\n- 分享我的文章，我则是使用我自己开发文档同步工具 Elog，将沉淀好的文档分享到各个博客平台/公众号/论坛上去\n- 更多的关于我工作/个人的OKR，我是用滴答清单做辅助。\n\n### **稍后阅读**\n\n\n在零碎的时间，例如早起、地铁、午休这些时间段中，都可以进入「快速浏览」模式。\n\n\n> 「快速浏览」的关键在于要把重点放在「发现」而不是「吸收」上面。因为前者花的时间很短，而后者会很长，最有效率的做法是，看到你感兴趣的，就把他扔在一个统一的地方，然后忘掉，去看发现下一个。等刷完你的时间线后，再开始「吸收」刚刚扔进来的一堆信息。这有点像你在 shopping, 把你想要的都放在购物车上，然后回家再把这一车的东西吸收整理。——Randy Lu《我的笔记管理法》\n\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/13a508a2-de5b-47bc-b05f-367d31c13e36/d3248ae6-b53f-4eb4-b923-ab8d823157f9/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20231018%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231018T163342Z&X-Amz-Expires=3600&X-Amz-Signature=5315175bfbe883516e18832a5e7198a16e64f915a6896dbb558a6b6f46bca4dd&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n当然，结合卡片笔记管理法中所提到的回顾的重要性，当我们收藏起来之后，一定要抽时间去阅读它，并记录自己想法，才能让收藏变的更有意义。\n\n\n### **如何阅读英文文档**\n\n\n英文社区的对于程序员非常重要，一手的技术、文章很多都是英文。在之前我都是右键翻译为中文，而且还是不会仔细地去看。自从有个 ChatGPT，我现在看到推荐的有意思英文文章也能点进去浅读一二。\n\n\n得益于 ChatGPT 插件的文章总结功能，我可以很方便的让 AI 帮我总结下这篇文档的重点。如果遇到我感兴趣或者想深入了解的知识点，我会找到对应的位置打开双语翻译，详细阅读。\n\n\n在 ChatGPT 应用爆发的现在，基于 ChatGPT 浏览器插件和双语翻译软件能让自己快速了解各种文档。\n\n\n### **为什么无法坚持写博客**\n\n\n就像V2EX社区评论经常说的那样，每个程序员都想有一个属于自己的工具网站和博客。\n\n\n但很多人当然也包括我都把时间花在装修上，博客迁移了一次又一次。\n\n\n就像文章开头说的，因为很多人把写博客当作从 0 到 1 的过程，脑子里或者身边几乎没有论点和实践，这样就很难形成一篇文档。\n\n\n写博客的过程就应该是一个组织之前笔记的过程，将之前的想法论点组织起来，自然而然就能确定文章的主题。而不是先确定主题，然后根据主题去寻找论点的过程。\n\n\n但值得注意的是：博客平台不是资讯网站，不必在意更新频率。\n\n\n正应如此，写作和思考在卡片笔记管理法中就应该是一个自然而然形成的过程。当你想要分享的时候就可以很容易的总结出一篇分享文档。\n\n\n正如当前这篇文章一样，它的形成就是各种想法柔和在一起产生的。\n\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/13a508a2-de5b-47bc-b05f-367d31c13e36/232a61fa-c131-4c1c-8b58-dc95d2eb4e98/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20231018%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231018T163342Z&X-Amz-Expires=3600&X-Amz-Signature=f9eeabc8cda50e01bbe5832515453b96c6ca1b07892a69c49194c1cae73fd2f7&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### **博客的定位**\n\n\n如Randy Lu的《为什么无法坚持写博客》中说的那样。\n\n\n> 写博客的第一个意义是**让陌生人通过博客了解到你是什么人、你在想什么、你做了什么**。不妨试想一下，如果你正准备找工作，一位素不相识的 HR 如果要了解你，光是一份简历就能让 HR 知道你的价值吗？如果你有一个精彩的博客，HR 也许能通过你的博客了解你对技术的属于自己的思考、你在业余时间在想的事情是什么。这比简历本身更像一份立体的简历。\n\n\n我认为博客和微信公众号等平台一样，都是一个打造个人 IP 的平台，有了个人 IP，才能撬动其他的资源。\n\n\n## **把工具嵌入到工作流程，而不是将工作流程嵌入工具**\n\n\n## **重要的不是记录，而是更好的思考**\n\n\n## 推荐\n\n\n### 书籍\n\n\n[《卡片笔记写作法：如何实现从阅读到写作 》](https://weread.qq.com/web/bookDetail/3d8326d072552e803d87c41)\n\n\n### 扩展阅读\n\n\n[Flomo 101](https://help.flomoapp.com/thinking/write-card.html)\n\n\n[为什么无法坚持写博客—— Randy Lu](https://lutaonan.com/blog/reason-why-your-blog-is-not-alive/)\n\n\n[我的笔记管理法—— Randy Lu](https://lutaonan.com/blog/how-do-i-take-note/)\n\n\n[少楠的知识管理B站](https://www.bilibili.com/video/BV1Vq4y1X7i8/)\n\n\n### 信息流入口\n\n\n[V2EX](https://www.v2ex.com/)\n\n\n[阮一峰的周刊](https://github.com/ruanyf/weekly)\n\n\n[Hack News](https://hackernews.betacat.io/zh.html)\n\n\n[Youtube](https://www.youtube.com/)\n\n\n[X（Twitter）](https://twitter.com/)\n\n\n[小宇宙播客](https://www.xiaoyuzhoufm.com/)\n\n\n[微信读书](https://weread.qq.com/web)\n\n\n### 软件/工具\n\n\n[Raindrop](https://raindrop.io/)：书签管理工具、稍后阅读工具\n\n\n[Readwise Reader](https://readwise.io/read)：稍后阅读工具\n\n\n[Notepal](https://notepal.randynamic.org/)：微信读书笔记同步到Flomo等\n\n\n[Flomo](https://flomoapp.com/)：卡片笔记软件\n\n\n[Notion](https://www.notion.so/)：All in one笔记软件\n\n\n[语雀](https://www.yuque.com/)：笔记软件\n\n\n[Elog](https://github.com/LetTTGACO/elog)：文档同步到博客\n\n\n[ChatGPT总结助手](https://chrome.google.com/webstore/detail/chatgpt-summary-assistant/nnjcoododbeemlmmhbfmmkbneniepaog)：结合 [Free GPT](https://github.com/chatanywhere/GPT_API_free)，总结网页文章插件\n\n\n[沉浸式翻译](https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh)：双语翻译插件\n\n\n## 引用\n\n\n[为什么无法坚持写博客—— Randy Lu](https://lutaonan.com/blog/reason-why-your-blog-is-not-alive/)\n\n\n[我的笔记管理法—— Randy Lu](https://lutaonan.com/blog/how-do-i-take-note/)\n\n\n[为何要写卡片—— Flomo 101](https://help.flomoapp.com/thinking/write-card.html)\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-08-18T14:16:00.000Z",
        "date": "2023-10-19",
        "type": "Post",
        "slug": "how-do-i-take-note",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-10-18T16:31:00.000Z",
        "title": "我的笔记管理法",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Published",
        "urlname": "d2a19be4-4efc-428a-9ebb-0a85e340290d",
        "updated": "2023-10-18 16:31:00"
      },
      "body": "",
      "realName": "我的笔记管理法",
      "relativePath": "/我的笔记管理法.md"
    },
    {
      "id": "74a06a6c-40b4-4408-8636-14cf996b3a71",
      "doc_id": "74a06a6c-40b4-4408-8636-14cf996b3a71",
      "title": "74a06a6c-40b4-4408-8636-14cf996b3a71",
      "updated": 1693060920000,
      "body_original": "\n# 背景\n\n\n最近在项目中遇到一个很有意思的图册业务需求：\n\n- 用户在后台上传 pdf 图册文件，前台可以进行 pdf 浏览，浏览方式为左右翻页模式（默认 pdf 是从上到下的），还有其他玩法，本质是花样看图（翻页电子书）。\n- 后续又产生了付费需求：可以预览前 5 页，后面图册浏览需要付费查阅。\n\n# 技术选型\n\n\n基于上述业务，我们简单进行需求拆解：\n\n- pdf 文件大小，需要考虑文件的上传速度和页面预览速度\n- 浏览方式，要求灵活性，所以要做成图片化浏览\n\n## 方案 1\n\n- 文件存储采用阿里云 oss 存储，前端服务直接跟 oss 存储交互，实现前端上传与下载，效率最大化（没有中间商赚差价）\n- 技术上选择 pdf.js + canvas；上传时，前端解析 pdf 文件后，按页读流，利用 canvas 转化为图片后上传；浏览时，直接对每页的图片进行读取并呈现；\n\n然而在实践过程中出现了预料之中的问题：由于后台上传的 pdf 大多都是几十甚至几百页的 pdf，从 oss 拿到 pdf 链接后，前端 canvas 进行渲染展示的速度相当感人，无法达到产品经理的要求。 问题分析:\n\n- 前端工作量大，时间不足。\n- 更深入思考技术细节：切图后的清晰度问题、图片压缩问题、图片命名规则问题、网络某个图片上传失败问题、大文件 OOM 问题等。\n\n## 方案 2\n\n\n基于以上问题，我们对方案进行改进：\n\n- 前端直接将 pdf 进行分片上传至 oss，保留了原 pdf，后续即便出现未知 pdf 故障也可以脚本处理（如图片清晰度问题）\n- 后端新增 pdf 处理服务，从 oss 获取 pdf 后处理切图后，再将图片上传 oss\n- 前端根据约定规则获取图片信息并呈现\n\n这样做的好处就是：\n\n- 前端专注于呈现，屏蔽了一些不必要的数据处理细节\n\n当然也有个缺点：\n\n- 用户上传 pdf 后立即进行预览，文件太大的情况下，后端还在处理中，前端可能获取不到图片\n\n当然了，最后考虑到使用场景，图册 pdf 制作需要时间，更新频率不会太高；我们保证其最终可见性，目前是足以支撑业务的。 不过在实践过程中，还是出现了一个小问题： 前端在预览 pdf 时，需要知道 pdf 的总页数，本来是由后端在解析 pdf 的时候顺便拿到 pdf 的页数后更新到数据库中，但是由于 oom 问题，需要前端在上传的时候拿到总页数后提交给后端。\n\n\n# 前端方案\n\n\n所以就还是需要前端借助 pdfjs 这个插件来解决问题： 先安装依赖：\n\n\n```shell\nnpm i pdfjs-dist -S\n```\n\n\n在上传 pdf 的时候进行解析，拿到 pdf 的总页数：\n\n\n```javascript\nimport PDFJS from 'pdfjs-dist'\nimport pdfjsWorker from 'pdfjs-dist/build/pdf.worker.entry'\n// 这里一定要设置！\nPDFJS.GlobalWorkerOptions.workerSrc = pdfjsWorker\n\n// 常用于上传的接口\nasync function upload(file) {\n  // OSS上传逻辑\n  ...\n  ...\n  const array = await file2Array(file.file)\n  const pdfDocument = await PDFJS.getDocument(array)\n  // 这样就可以拿到pdf的总页数了\n  this.filePageSize = pdfDocument.numPages\n  this.$emit('change', this.filePageSize)\n}\n\n\n// 这里要借助一个工具类将file文件转为Uint8Array\nfunction file2Array(file) {\n  const reader = new FileReader()\n  reader.readAsArrayBuffer(file)\n  return new Promise((resolve, reject) => {\n    reader.onload = async (e) => {\n      const array = new Uint8Array(e.target.result) // ArrayBuffer转Uint8Array\n      resolve(array)\n    }\n    reader.onerror = (err) => {\n      reject(err)\n    }\n  })\n}\n```\n\n\n# 后端方案\n\n\n## 技术选型\n\n\njava 实现 pdf 处理的技术现有技术大概有几种：pdfbox、PDFRenderer、jpedal、itext、ICEPDF。\n\n- pdfbox：是 appach 出品，开源、免费、今年还在更新。\n- PDFRenderer：sum 出品，只有一个 2012 年版本[0.9.1-patched](https://mvnrepository.com/artifact/com.sun.pdfview/pdfrenderer/0.9.1-patched)，不大行的样子\n- jpedal：收费\n- itext：[AGPL](https://github.com/itext/itext7/blob/develop/LICENSE.md) / [商业软件的](https://itextpdf.com/sales)双重许可。AGPL 是免费/开源软件许可证。这并不意味着该软件是[免费的](https://en.wikipedia.org/wiki/Gratis_versus_libre)！\n- ICEPDF：切图后质量不大行，有水印的 pdf，切图后水印会特别清晰。\n\n基于以上调研，最终选择了 pdfbox。\n\n\n## 遇到的问题\n\n\n### java.awt.AWTError: Assistive Technology not found: org.GNOME.Accessibility.AtkWrapper\n\n\n### 现象\n\n\n本地正常，无此问题，pass 部署后第一次调用 pdf 处理时报 error 错误。\n\n\n### 排查\n\n- 根据报错信息初步判断，这应该是某个类不存在。（大意是说该辅助技术不存在）\n- 追溯内部代码，pdf 处理后生成图片使用 java.awt.toolkit 工具包。\n- 其初始化采用单例模式，如果有配置 Assistive Technology（辅助技术），则会实例化该辅助技术。\n\n### 原因\n\n- toolkit 类内部会基于 spi 机制加载辅助技术 assistive_technologies，该辅助技术非必须。\n- 该配置文件在 jdk/accessibility.properties 中。\n- 本地是 jdk 为 jdk1.8.0_221，无配置 assistive_technologies，无加载问题\n- 代码构建平台上基础镜像 jdk 为： java-8-openjdk，其内部配置 assistive_technologies，却无引入具体类，导致第一次初始化时异常。\n- 所以，**这是一起由 jdk 版本不同/环境不同、引发的问题**。\n\n### 解决\n\n- 第一种：修改 jdk/accessibility.properties 配置： 注释 assistive_technologies\n- 第二种：因为内部初始化为单例模式，初始化后 toolkit 对象存在则不在初始化，预先初始化。\n\n### java.lang.OutOfMemoryError: Java heap space\n\n\n### 现象\n\n\n上传一个 188M pdf 文件时，在某几页的处理会出现 OOM 堆内存溢出\n\n\n> 造成 OutOfMemoryError 原因一般有 2 种：\n\n\t- 内存泄露，对象已经死了，无法通过垃圾收集器进行自动回收，通过找出泄露的代码位置和原因，才好确定解决方案；\n\t- 内存溢出，内存中的对象都还必须存活着，这说明 Java 堆分配空间不足，检查堆设置大小（-Xmx 与-Xms），检查代码是否存在对象生命周期太长、持有状态时间过长的情况。\n\n### 排查\n\n- 启动加入参数：-XX:+HeapDumpOnOutOfMemoryError， 进行对 OOM 日志 dump\n- OOM 后进行日志分析，其占用空间为 2 部分：\n\t- 第一部分：原 pdf 所需内存。\n\t- 第二部分：每一页的 pdf 转图片过程需要的内存。（主要内存占用在此部分）\n- 针对第一部分，官方倒是有一个配置：MemoryUsageSetting._setupTempFileOnly_();\n\t- 即原 pdf 暂存在外存中，而非内存，减轻主内存暂用。\n- 针对第二部分\n\t- 取某一页的 pdf 流，进行解析；解析后的像素数据写入 BufferedImage 中，在调用原生 java.awt.image 画图生成。\n\t- 内部涉及 pdf 的解析、渲染+渲染算法、是否允许下采样等等。\n\n最终定位到，部分页后绘制成图所需的内存巨大，pdf 越是精致，越是巨大。这个跟图像的着色、轮廓、纹理、像素点、边缘锯齿、抖动等相关。这里水有点深，概念上就有分辨率、容量、清晰度、像素、矢量图、位图、栅格化、插值算法。 总之，一套流程下来，我们发现某些 pdf 的转化确实需要巨大的内存，典型的空间复杂度高。所以，这是个正常内存溢出，并非某些流或对象未及时关闭，本质上还是需要扩大虚拟机堆内存。 经测试，某 24M 的单页 pdf 图，转化成图片大约需要 800M 内存。（就是这么夸张！）\n\n\n### 优化总结\n\n- `PDDocument.load(file, MemoryUsageSetting.setupTempFileOnly())`将 pdf 暂存在本地磁盘，即省出了内存空间；像 100M 的 pdf 就能省 100M 内存呢\n- `PDFRenderer.renderImageWithDPI(i，72)；`降低 dpi，减少 dpi 比例，也可以一定程度上优化，但在呈现上跟原图比会有所缩放。\n- `PDFRenderer``.setSubsamplingAllowed(``true``);`允许下采样，下采样可以在更快、更小的内存密集型情况下使用，但它也可能导致质量的损失，尤其是针对高空间频率的图像\n- 通过-Xmx 增加最大堆内存，终极大法，扩大内存\n\npdfbox 官方也有 oom 问题的处理建议，如下：\n\n\n> I’m getting an OutOfMemoryError. What can I do? The memory footprint depends on the PDF itself and on the resolution you use for rendering. Some possible options:\n\n\t- increase the `Xmx` value when starting java\n\t- use a scratch file by loading files with this code `PDDocument.load(file, MemoryUsageSetting.setupTempFileOnly())`\n\t- be careful not to hold your images after rendering them, e.g. avoid putting all images of a PDF into a `List`\n\t- don’t forgot to close your `PDDocument` objects\n\t- decrease the scale when calling `PDFRenderer.renderImage()`, or the dpi value when calling `PDFRenderer.renderImageWithDPI()`\n\t- disable the cache for `PDImageXObject` objects by calling `PDDocument.setResourceCache()` with a cache object that is derived from `DefaultResourceCache` and whose call `public void put(COSObject indirect, PDXObject xobject)` does nothing. Be aware that this will slow down rendering for PDF files that have an identical image in several pages (e.g. a company logo or a background). More about this can be read in [PDFBOX-3700](https://issues.apache.org/jira/browse/PDFBOX-3700).\n\n# 文件加密设计\n\n\n一个 pdf，可能含 200+的页码，切成图片后分开存放，即产生 200+记录。如果存储在库里，有点浪费空间，同时还是能通过接口规则获取数据。如果单纯的通过统一路径后加 1、2、3、4，也是很容易的推导后续的数据。所以需要制定内部加密规则。\n\n\n## 基本流程\n\n\n明文  + 规则（密钥）  -> 密文  （典型的对称加密的加密段) **明文**为 uuid：如数据库存放格式：/fileUrl/**68428de9168548f3a9da61a6ee5faaf3**  ,   黑体部分即明文 **规则**： 即密钥：rule = “zxcvbnmlkjhgfdsa” **密文**： 为具体的 oss 文件名：`/fileUrl/``**6**``**g**``**8428de9168548f3a9da61a6ee5faaf**``**1**` ，这是第一页/张，`/fileUrl/`**68**`**z**`**428de9168548f3a9da61a6ee5faaf**`**2**`  ,   这是第二页/张\n\n\n## 加密规则\n\n\n### java 版\n\n\n```java\n/**\n * pdfHelper\n *\n */\npublic class PdfHelper {\n    /**\n     * uuid规则构造器\n     * 原理：去除最后一位字符，再取剩下最后一位字符为起始值，经过规则转换后，插入第i个位置；\n     * 规则：ruleMark\n     * 如ABCD,1 -> C ABC 1\n     * 如ABCD,2 -> D ABC 2\n     *\n     * @param sourceUuid 源id\n     * @param pageNum    页码 第n页\n     * @return 规则后的uuid\n     */\n    public static String uuidBuilder(String sourceUuid, int pageNum) {\n        String splitUuid = sourceUuid.substring(0, sourceUuid.length() - 1);\n        String publicMark = splitUuid.substring(splitUuid.length() - 1);\n        String ruleMark = ruleMark(publicMark, pageNum);\n        int index = pageNum;\n        while (index > splitUuid.length()) {\n            index = index - splitUuid.length();\n        }\n        return splitUuid.substring(0, index) + ruleMark + splitUuid.substring(index) + pageNum;\n    }\n\n    public static String ruleMark(String mark, int pageNum) {\n        String rule = \"qwertyuiopasdfghjklzxcvbnm1234567890\";\n        int index = rule.indexOf(mark) + pageNum;\n        while (index > rule.length() - 1) {\n            index = index - rule.length();\n        }\n        char c = rule.charAt(index);\n        return String.valueOf(c);\n    }\n\n}\n```\n\n\n### javascript 版\n\n\n```javascript\n/**\n * uuid规则构造器\n * 原理：去除最后一位字符，再取剩下最后一位字符为起始值，经过规则转换后，插入第i个位置；\n * 规则：ruleMark\n * 如ABCD,1 -> C ABC 1\n * 如ABCD,2 -> D ABC 2\n *\n * @param sourceUuid 源id\n * @param pageNum 页码 第n页\n * @return string 规则后的uuid\n */\n\nfunction uuidBuilder(sourceUuid, pageNum) {\n  const ruleMark = (mark, pageNum) => {\n    const rule = 'qwertyuiopasdfghjklzxcvbnm1234567890'\n    let index = rule.indexOf(mark) + pageNum\n    while (index > rule.length - 1) {\n      index = index - rule.length\n    }\n    const c = rule.charAt(index)\n    return c\n  }\n  const splitUuid = sourceUuid.substring(0, sourceUuid.length - 1)\n  const publicMark = splitUuid.substring(splitUuid.length - 1)\n  const ruleMarkV = ruleMark(publicMark, pageNum)\n  let index = pageNum\n  while (index > splitUuid.length) {\n    index = index - splitUuid.length\n  }\n  return splitUuid.substring(0, index) + ruleMarkV + splitUuid.substring(index) + pageNum\n}\n\nexport default uuidBuilder\n```\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-02-24",
        "type": "Post",
        "slug": "owidng",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了一种利用 pdf.js 和 pdfbox 技术实现大文件 PDF 预览的解决方案。通过采用前端 pdf.js 插件解析 PDF 文件并转化为图片，后端 pdfbox 进行 PDF 处理和切图，实现了大文件的分片上传和处理。同时，本文介绍了在实践过程中遇到的内存溢出问题和解决方案。",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "大文件pdf预览解决方案",
        "category": "技术分享",
        "tags": [
          "Vue",
          "Java"
        ],
        "status": "Archived",
        "urlname": "74a06a6c-40b4-4408-8636-14cf996b3a71",
        "updated": "2023-08-26 14:42:00"
      },
      "body": "",
      "realName": "大文件pdf预览解决方案",
      "relativePath": "/大文件pdf预览解决方案.md"
    },
    {
      "id": "53037fea-b13b-4fc6-8c6b-a254bb871dcd",
      "doc_id": "53037fea-b13b-4fc6-8c6b-a254bb871dcd",
      "title": "53037fea-b13b-4fc6-8c6b-a254bb871dcd",
      "updated": 1693060980000,
      "body_original": "\n# 前言\n\n\nLinux 下，命令行显示路径仅最后一个文件名，非常不方便， 最近在学大数据的时候才偶然发现这个小细节，简直太省心了，记录一下。\n\n\n# Centos 命令提示符显示完整路径\n\n\n编辑`[/etc/profile]`文件，在末尾添加环境变量 PS1\n\n\n```text\nexport PS1='[\\u@\\h `pwd`]\\$'\n```\n\n\n刷新配置文件，使其生效\n\n\n```text\n$> source /etc/profile\n```\n\n\n> 命令释义： \\u 显示当前用户账号 \\h 显示当前主机名 只显示当前路径最后一个目录 显示当前绝对路径（当前用户目录会以 ~代替） pwd 显示当前全路径 $ 显示命令行’$‘或者’#’符号\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FvMg0RbCcEOrUnaGLzYP-7n0P77y.png)\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-05-04",
        "type": "Post",
        "slug": "olp6f6",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:43:00.000Z",
        "title": "Centos命令提示符显示完整路径",
        "category": "学习笔记",
        "tags": [
          "Linux"
        ],
        "status": "Archived",
        "urlname": "53037fea-b13b-4fc6-8c6b-a254bb871dcd",
        "updated": "2023-08-26 14:43:00"
      },
      "body": "",
      "realName": "Centos命令提示符显示完整路径",
      "relativePath": "/Centos命令提示符显示完整路径.md"
    },
    {
      "id": "86181a01-bf90-440b-876f-93e680ed7f92",
      "doc_id": "86181a01-bf90-440b-876f-93e680ed7f92",
      "title": "86181a01-bf90-440b-876f-93e680ed7f92",
      "updated": 1696147260000,
      "body_original": "\n> 💡 1. 今日学习的文章链接和视频链接  \n> 2. 自己看到题目的第一想法  \n> 3. 看完代码随想录之后的想法  \n> 4. 自己实现过程中遇到哪些困难  \n> 5. 今日收获，记录一下自己的学习时长\n\n\n## 题目链接\n\n\n### 977.有序数组的平方\n\n\n题目建议：本题关键在于理解双指针思想\n\n\n题目链接：[https://leetcode.cn/problems/squares-of-a-sorted-array/](https://leetcode.cn/problems/squares-of-a-sorted-array/)\n文章讲解：[https://programmercarl.com/0977.有序数组的平方.html](https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html)\n视频讲解： [https://www.bilibili.com/video/BV1QB4y1D7ep](https://www.bilibili.com/video/BV1QB4y1D7ep)\n\n\n### 209.长度最小的子数组\n\n\n题目建议：本题关键在于理解滑动窗口，这个滑动窗口看文字讲解 还挺难理解的，建议大家先看视频讲解。  拓展题目可以先不做。\n\n\n题目链接：[https://leetcode.cn/problems/minimum-size-subarray-sum/](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n文章讲解：[https://programmercarl.com/0209.长度最小的子数组.html](https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html)\n视频讲解：[https://www.bilibili.com/video/BV1tZ4y1q7XE](https://www.bilibili.com/video/BV1tZ4y1q7XE)\n\n\n### 59.螺旋矩阵II\n\n\n题目建议：本题关键还是在转圈的逻辑，在二分搜索中提到的区间定义，在这里又用上了。\n\n\n题目链接：[https://leetcode.cn/problems/spiral-matrix-ii/](https://leetcode.cn/problems/spiral-matrix-ii/)\n文章讲解：[https://programmercarl.com/0059.螺旋矩阵II.html](https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html)\n视频讲解：[https://www.bilibili.com/video/BV1SL4y1N7mV/](https://www.bilibili.com/video/BV1SL4y1N7mV/)\n\n\n### 总结\n\n\n题目建议：希望大家也做一个自己对数组专题的总结\n\n\n文章链接：[https://programmercarl.com/数组总结篇.html](https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html)\n\n\n## 解题思路\n\n\n### 977.有序数组的平方\n\n\n第一反应就是直接暴力平方然后排序。双指针思想什么的完全没头绪，还是先看题解的思路吧：\n\n\n数组其实是有序的， 只不过负数平方之后可能成为最大数了。\n\n\n那么数组平方的**最大值就在数组的两端，不是最左边就是最右边，不可能是中间**。\n\n\n此时可以考虑双指针法了，`i`指向起始位置，`j`指向终止位置。\n\n\n定义一个新数组result，和A数组一样的大小，让`k`指向result数组终止位置。\n\n\n如果`A[i] * A[i] < A[j] * A[j]` 那么`result[k--] = A[j] * A[j];`\n\n\n如果`A[i] * A[i] >= A[j] * A[j]` 那么`result[k--] = A[i] * A[i];`\n\n\n如动画所示：\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a4be2e11-5fd8-4a8b-abbf-edb717d3d1bd/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20231012%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T081950Z&X-Amz-Expires=3600&X-Amz-Signature=ea73aa4202afd4db62a3bc98ed72dd85cbdd46215e74ad73caaeeb45aa006fcb&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### 209.长度最小的子数组\n\n\n没啥头绪，看了好一会暴力解法才明白是怎么运行的。\n\n- 外层用来循环整个数组\n- 内层用来循环当前下标及其之后所有数的和\n- 直到循环完后找到最小的length\n- 相当于两个\n\n滑动窗口的思想就不需要内层循环，用两个指针\n\n- 指针i用来循环整个数组\n- 指针j会在sum大于等于目标值时，从sum中减去当前值并向右移动\n- 所以这个最坏的情况就是全是目标值-1的值组成的数组，指针j每走一步，i都需要走一步。即时间复杂度最坏为O(2n)\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/4e47acdd-4a9e-4fc3-a4b9-36689bd79103/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84_%281%29.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20231012%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20231012T081950Z&X-Amz-Expires=3600&X-Amz-Signature=d4683181554261fb5afd3e371a4cbab2bd9fa0aa1f1bcc6eb4e33f0943158784&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### 59.螺旋矩阵II\n\n\n## 题解\n\n\n### 977.有序数组的平方\n\n\n```javascript\n/**\n * 暴力解法\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortedSquares = function(nums) {\n  // 直观明了的暴力解法\n  return nums.map(item => {\n    return item * item\n  }).sort((a, b) => a-b)\n};\n```\n\n\n```javascript\n/**\n * 双指针解法\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortedSquares = function(nums) {\n  // i指向起始位置，j指向终止位置\n  let i = 0, j = nums.length - 1, k = nums.length - 1\n  // 定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。\n  const res = new Array(nums.length).fill(0)\n  while (i <= j) {\n    // 得出平方值\n    let left = nums[i] * nums[i]\n    let right = nums[j] * nums[j]\n    if (left < right) {\n      // 右边的大，就把右边的平方值放到新数组\n      // 新数组上的指针向左移动\n      res[k--] = right\n      // 并且右边的指针向左移动\n      j--\n    } else {\n      // 左边的大，就把左边的平方值放到新数组\n      // 新数组上的指针向左移动\n      res[k--] = left\n      // 并且左边的指针向右移动\n      i++\n    }\n  }\n  return res\n};\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortedSquares = function(nums) {\n    // 双指针\n    let res = []\n    // 定义左右指针\n    let left = 0, right = nums.length - 1\n\n    while(left <= right) {\n        const le = nums[left] * nums[left]\n        const ri = nums[right] * nums[right]\n        if(le < ri) {\n            // 给数组前增加元素\n            res.unshift(ri)\n            // 右边的大，右边指针向左移动\n            right --\n        } else {\n            // 左边的大，左边指针向右移动\n            res.unshift(le)\n            left ++\n        }\n    }\n\n    return res\n\n};\n```\n\n\n### 209.长度最小的子数组\n\n\n```javascript\n/**\n * 暴力解法\n * @param {number} target\n * @param {number[]} nums\n * @return {number}\n */\nvar minSubArrayLen = function(target, nums) {\n  // 定义一个足够大的长度\n  let result = 999999999999\n  let subLength = 0; // 子数组长度\n  for (let i = 0; i < nums.length; i++) {\n    let sum = 0 // 每次从头开始计时\n    for (let j = i; j < nums.length; j++) {\n      sum = sum + nums[j] // 计算和\n      if (sum >= target) { // 如果大于等于目标值\n        subLength = j - i + 1 // 得到数组长度\n        result = result < subLength ? result : subLength // 和之前的长度做比较，谁短就是谁\n        break  // 找符合条件最短的子序列，所以一旦符合条件就break，没必要再加sum了\n      }\n    }\n  }\n  // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列\n  return result === 999999999999 ? 0 : result\n};\n```\n\n\n```javascript\n/**\n * 滑动窗口解法\n * @param {number} target\n * @param {number[]} nums\n * @return {number}\n */\nvar minSubArrayLen = function(target, nums) {\n  // 定义一个长度结果\n  let res = 999999999999\n  // 子数组的长度\n  let subLen = 0\n  // 定义一个窗口初始下标\n  let i = 0\n  // 和\n  let sum = 0\n  for (let j = 0; j < nums.length; j++) {\n    // 相对于暴力解法，这里的sum在相加之后不用break\n    sum = sum + nums[j]\n    // 一旦大于等于目标值，就检查最小长度\n    while (sum >= target) {\n      // 得到子数组长度\n      subLen = j - i + 1\n      // 检查最小长度\n      res = res < subLen ? res : subLen\n      // 减去初始位置的值，直到让sum小于目标值\n      sum = sum - nums[i]\n      // 并且移动窗口起始位置，\n      i++\n    }\n  }\n  return res === 999999999999 ? 0 : res\n};\n```\n\n\n### 59.螺旋矩阵II\n\n\n## 收获\n\n\n题解能看懂，也能写出来，但是感觉没有什么通用性的收获。对我来说虽然都是数组的题目，但是解题思路不具备通用性。差不多是那种从没头绪⇒看题解⇒原来可以这样理解⇒理解了⇒下一道题又困住了。回头再刷几道数组题看看，估计还是我刷题刷少了。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-13T14:16:00.000Z",
        "date": "2023-07-13",
        "type": "Post",
        "slug": "leetcode-day-2",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-10-01T08:01:00.000Z",
        "title": "【代码随想录】算法训练营第2天",
        "category": "算法刷题",
        "tags": [
          "算法训练营",
          "数组专题"
        ],
        "status": "Invisible",
        "urlname": "86181a01-bf90-440b-876f-93e680ed7f92",
        "updated": "2023-10-01 08:01:00"
      },
      "body": "",
      "realName": "【代码随想录】算法训练营第2天",
      "relativePath": "/【代码随想录】算法训练营第2天.md"
    },
    {
      "id": "dff5c177-a377-4ba9-9924-54113ce1ec5e",
      "doc_id": "dff5c177-a377-4ba9-9924-54113ce1ec5e",
      "title": "dff5c177-a377-4ba9-9924-54113ce1ec5e",
      "updated": 1689003180000,
      "body_original": "\n## 思考\n\n\n每周新认知、新思考…\n\n\n## 文章\n\n\n这里是当周摘录的代码之外的优质好文…\n\n\n## 杂谈\n\n\n一些有趣/令人深思的言论\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-10T15:33:00.000Z",
        "date": "2023-07-10 15:33:00",
        "type": "Post",
        "slug": "beyond-code-2023-w28",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-07-10T15:33:00.000Z",
        "title": "代码之外 2023-W28",
        "category": "代码之外",
        "tags": [],
        "status": "Draft",
        "urlname": "dff5c177-a377-4ba9-9924-54113ce1ec5e",
        "updated": "2023-07-10 15:33:00"
      },
      "body": "",
      "realName": "代码之外 2023-W28",
      "relativePath": "/代码之外 2023-W28.md"
    },
    {
      "id": "a0d6553b-62bf-4019-8aa9-4219242f7b9a",
      "doc_id": "a0d6553b-62bf-4019-8aa9-4219242f7b9a",
      "title": "a0d6553b-62bf-4019-8aa9-4219242f7b9a",
      "updated": 1690299060000,
      "body_original": "\n> 💡 1. 今日学习的文章链接和视频链接  \n> 2. 自己看到题目的第一想法  \n> 3. 看完代码随想录之后的想法  \n> 4. 自己实现过程中遇到哪些困难  \n> 5. 今日收获，记录一下自己的学习时长\n\n\n## 题目链接\n\n\n## 解题思路\n\n\n## 题解\n\n\n## 收获\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-14T10:17:00.000Z",
        "date": "2023-07-14",
        "type": "Post",
        "slug": "leetcode-day-3",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-07-25T15:31:00.000Z",
        "title": "【代码随想录】算法训练营第3天",
        "category": "算法刷题",
        "tags": [
          "算法训练营"
        ],
        "status": "Invisible",
        "urlname": "a0d6553b-62bf-4019-8aa9-4219242f7b9a",
        "updated": "2023-07-25 15:31:00"
      },
      "body": "",
      "realName": "【代码随想录】算法训练营第3天",
      "relativePath": "/【代码随想录】算法训练营第3天.md"
    },
    {
      "id": "346c9ff0-8751-4367-9d60-a88c2fff08b4",
      "doc_id": "346c9ff0-8751-4367-9d60-a88c2fff08b4",
      "title": "346c9ff0-8751-4367-9d60-a88c2fff08b4",
      "updated": 1689001800000,
      "body_original": "\n## 开源工具\n\n\n这里是当月发现的有趣、有用的开源项目…\n\n\n### Elog\n\n\n[https://elog.1874.cool](https://elog.1874.cool/)\n\n\n> 开放式跨平台博客解决方案\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/34429141-438f-441e-b26b-fd08f019754f/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230927%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230927T015952Z&X-Amz-Expires=3600&X-Amz-Signature=72d48db7211b3667666f4c037f43d0dd0f4a9c2ca46f77117c74287a9f90972b&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n## 技术新视界\n\n\n这里是当月发现的前哨技术点\n\n\n## 技术方案\n\n\n这里是当月发现的有用的技术方案…\n\n\n## 技术好文\n\n\n这里是当月发布摘录的技术原理之类的优质文章…\n\n\n## 技术周边\n\n\n这里是当月发现的有趣、有用的技术“边界上”的工具、资源…\n\n\n## 思考&杂谈\n\n\n一些技术圈内(相关的)的话题、看法、思考\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-10T14:49:00.000Z",
        "date": "2023-07-10",
        "type": "Post",
        "slug": "weekly-2023-w28",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-07-10T15:10:00.000Z",
        "title": "技术周刊 2023-W28",
        "category": "技术周刊",
        "tags": [],
        "status": "Draft",
        "urlname": "346c9ff0-8751-4367-9d60-a88c2fff08b4",
        "updated": "2023-07-10 15:10:00"
      },
      "body": "",
      "realName": "技术周刊 2023-W28",
      "relativePath": "/技术周刊 2023-W28.md"
    },
    {
      "id": "4296105d-56f7-4dc7-be6a-ac69ba786d50",
      "doc_id": "4296105d-56f7-4dc7-be6a-ac69ba786d50",
      "title": "4296105d-56f7-4dc7-be6a-ac69ba786d50",
      "updated": 1688994900000,
      "body_original": "\n# Why Notion ?\n\n\n这是我第三次进行博客的迁移了！\n\n\n原本的博客是基于[语雀](https://www.yuque.com/) 云端书写 + 语雀 webhook + 自建Node API服务 + [yuqe-hexo-with-cdn](https://github.com/LetTTGACO/yuque-hexo-with-cdn) + [Hexo](https://hexo.io/) + Github Actions 持续集成部署到腾讯云COS静态网站上。\n\n\n现在是基于 [Notion](https://www.notion.so/zh-cn) + [NotionNext](https://tangly1024.com/article/notion-next) 持续集成部署到 [Vercel](https://vercel.com/) 上。\n\n\n本人接触Notion有一段时间了，但是一直没怎么用起来，原因有三\n\n- 当时以为没有中文\n- 语雀的写作舒适感要更好一点\n- 还没感受到Notion的强大\n\n在用了2年时间语雀之后，语雀的产品策略越来越离谱，各种收费割韭菜。再加上之前一段时间开发 Elog 对接语雀和 Notion 的 Api 时，发现 Notion 原来这么好用。\n\n- Notion 的 Properties 天然对Api很友好。再也不用在语雀的文章头部手动添加 Front-Matter。\n- Notion 的筛选和排序对于统一分类管理文章很方便\n- Notion AI 永远的神。ChatGPT 火起来之后，对于 Notion 这种写作工具来说简直是锦上添花。用来帮忙写总结，写技术方便，修正文章格式等等。虽然现在还是有很多能力没有深度绑定，但是已经足够好用了！坐等官方更新！\n- 找到中文插件了，其实用习惯之后，是不是中文也没那么重要了。不过一个有中文的话会让小白用户更快的爱上 Notion\n\n# Why NotionNext ?\n\n\n其实一开始是准备用我自己的 [Elog](https://elog.1874.cool/) 工具来将 Notion 文档同步到博客平台。在无意间发现了 [NotionNext](https://tangly1024.com/article/notion-next) ，部署简单，对于 Notion 的格式支持度非常高，所以我才选择了它。\n\n\n不得不说，NotionNext 对于我的 Elog 在 Notion 的发展是一个不小的打击，Elog 完全没有优势。不过这也让我看到了我的 Elog 的未来的发展方向。\n\n\n通过深入 NotionNext 的研究，发现大家都逃不过缝合怪。Notion社区生态的强大完全可以造就一个又一个的 类 NotionNext，所以我也相信我的 Elog 在不久后也能成为一个优秀的博客同步工具。\n\n\n正如我的 Elog 介绍\n\n\n> Elog: 开放式跨平台博客解决方案，随意组合写作平台(语雀/Notion)和部署平台(Hexo/Vitepress/HuGo/Confluence)等\n\n\nElog 生态将是我未来的强大优势！\n\n\n# 迁移中遇到的的问题\n\n\n## Notion 对于 markdown 的导入还没有很完美\n\n\n其实已经很好了，就是有几个小问题\n\n1. Notion 没能完全区分行内代码块和代码块\n\n有时候会把行内代码块识别为代码块，造成不必要的换行和格式错乱。我导入的60多篇文档，一大半都有这个问题，好在有 Notion Ai 的帮助，才让我不那么痛苦的手动调整格式。\n\n1. Notion 对于代码块的语言识别不够完善\n\n对于常见的 `TypeScript` 和 `JavaScript` 没能完全识别出来，导致代码的格式化出现问题，代码少了换行，全部堆积在一起。而且 Notion Ai  处理它的速度也比较慢，不如我手动按照原文档复制粘贴来得快。\n\n\n而且处理之后的文档在同步到别的工作区也会丢失一部份的代码块的语言识别和格式化，这让我有点头痛，好在只是一次性的工作量……\n\n\n## NotionNext 虽强大但也还有小瑕疵\n\n1. NotionNext 不支持 `Internal integration token`\n\nNotionNext 是基于公开分享的页面来实时获取 Notion Database 中的数据，这意味着你的 Notion 数据源被完全公开了，用户有可能通过 `Page Id`找到你的博客源数据，而一些你不想被分享的文章或者数据就暴露了。\n\n\n虽然官方给出的方案是 可以使用 cookie 中的 `auth_token`，但是它是有有效期的。而且经过我的实测，`auth_token`存在并发问题：NotionNext 会在短时间内请求很多次API。在我60来篇文档的部署过程中就出现了请求次数过多的错误，所以我暂时还是用的公开的页面来部署。\n\n\n不过话说回来，既然部署到博客都能公开，那这个数据库里面的文档其实被看到也无所谓啦～\n\n\n话虽如此，我还是寻求过解决方案，因为我的 Elog 就是基于 `Notion Internal integration token` 来部署的（所以 Elog 的功能很有限）。我尝试过改动 Notion Next 中的相关API 来支持它，结果得到的答案是，NotionNext 所使用的 [react-notion-x](https://github.com/NotionX/react-notion-x) 库不是基于官方API来开发的。\n\n\n正如 [react-notion-x](https://github.com/NotionX/react-notion-x) 中 [Why use notion-client over @notionhq/client? ](https://github.com/NotionX/react-notion-x/issues/457)所描述的那样\n\n\n> `notion-client`在官方客户端发布之前就出现了，官方客户端不支持所有块类型并且由于某种原因效率极低。更多细节在[这里](https://github.com/NotionX/react-notion-x/tree/master/packages/notion-compat)\n\n\n`Notion Internal integration token` 是官方 API 所提供的令牌，而官方 API [@notionhq/client](https://github.com/makenotion/notion-sdk-js) 无法支持所有现有的 Notion 功能模块，所以需要等官方 API 完善了才能使用它。\n\n1. NotionNext 不是很稳定\n\nNotionNext 部署的博客，浏览器控制台会出现很多报错。大部分都是使用 React/NextJs 不标准导致的，当然它也存在性能问题，我能感觉到他调用了很多不必要的 API 。好在有缓存，导致线上问题不那么明显。\n\n\n还有一些 UI、路由、网站配置等小问题需要作者去解决，不过当下最好的办法当然是自己修复它。我已经修复了一些看起来比较明显的问题，还有一些需要接下来一小段时间去解决它。当然，如果能参与 NotionNext 的开发的话会更好。\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-09T18:39:00.000Z",
        "date": "2023-04-10",
        "type": "Post",
        "slug": "migrate-blog-to-notion",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "博客迁移记录",
        "更新时间": "2023-07-10T13:15:00.000Z",
        "title": "迁移博客到 Notion",
        "category": "技术分享",
        "tags": [
          "Notion"
        ],
        "status": "Published",
        "urlname": "4296105d-56f7-4dc7-be6a-ac69ba786d50",
        "updated": "2023-07-10 13:15:00"
      },
      "body": "",
      "realName": "迁移博客到 Notion",
      "relativePath": "/迁移博客到 Notion.md"
    },
    {
      "id": "335ae226-1802-4706-98b5-2a09bde056a1",
      "doc_id": "335ae226-1802-4706-98b5-2a09bde056a1",
      "title": "335ae226-1802-4706-98b5-2a09bde056a1",
      "updated": 1685550180000,
      "body_original": "\n# 引言\n\n\n这篇文章我其实最想解决的是【如何简单快速打造一个能同时导出`cjs`和`esm`的`npm`包】。在看了网上的各种教程，都没我想要的。要么就是利用`rollup`来构建，但是配置问题和兼容性问题又很棘手。最后是在看了[typedi](https://github.com/typestack/typedi)的代码仓库，发现很适合我，就借鉴过来了。 因为我的`npm`包是在`node`端使用的，所以只需要`cjs`和 esm`类型`的包就行，而`ts-node`就刚刚好能满足我的需求，所以我也没有使用其他构建工具。\n\n\n# 配置\n\n\n## 目录\n\n\n项目关键文件如下：\n\n\n```text\nnode-agile-client\n|--.github\n|  |--workflows\n|  |\t|--cd.yml\n|--build\n|  |--cjs\n|  |\t|--index.js\n|  |--esm5\n|  |\t|--index.js\n|  |--types\n|  |\t|--index.d.ts\n|  |--package.json\n|--src\n|  |--index.ts  \n|--package.json\n|--tsconfig.json\n|--tsconfig.esm5.json\n|--tsconfig.cjs.json\n|--tsconfig.types.json\n```\n\n- .github：github actions 配置文件\n- build：文件夹是打包后的产物，也是发不到 npm 上的文件夹，仓库 src 的文件是不会上传到 npm 的\n\t- cjs：CommonJS 模块的代码\n\t- esm5：ES Modules 模块的代码\n\t- types：类型声明文件\n\t- package.json：对 npm 包的定义说明\n- src：项目文件代码\n- package.json：对项目文件的定义说明及命令行操作\n- tsconfig.json：ts 编译配置主体文件\n- tsconfig.esm5.json：编译成 ems5 的编译配置\n- tsconfig.cjs.json：编译成 cjs 的编译配置\n- tsconfig.types.json：编译成类型声明文件的编译配置\n\n## package.json\n\n\n这是一份最终配置，具体代码：[node-agile-client](https://github.com/LetTTGACO/node-agile-client)\n\n\n```json\n{\n  \"name\": \"node-agile-client\",\n  \"version\": \"0.0.3\",\n  \"description\": \"AgileConfig的node客户端\",\n  \"main\": \"./cjs/index.js\",\n  \"module\": \"./esm5/index.js\",\n  \"typings\": \"./types/index.d.ts\",\n  \"scripts\": {\n    \"prebuild\": \"rimraf build\",\n    \"build\": \"npm run build:cjs && npm run build:esm5 && npm run build:types\",\n    \"build:esm5\": \"tsc --project tsconfig.esm5.json\",\n    \"build:cjs\": \"tsc --project tsconfig.cjs.json\",\n    \"build:types\": \"tsc --project tsconfig.types.json\",\n    \"postbuild\": \"cp LICENSE build/LICENSE && cp README.md build/README.md && cp package.json build/package.json\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/LetTTGACO/node-agile-client.git\"\n  },\n  \"tags\": [\n    \"agile\"\n  ],\n  \"keywords\": [\n    \"配置中心\"\n  ],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/LetTTGACO/node-agile-client/issues\"\n  },\n  \"homepage\": \"https://github.com/LetTTGACO/node-agile-client#readme\",\n  \"dependencies\": {\n    \"axios\": \"^0.26.1\",\n    \"fs-extra\": \"^10.1.0\",\n    \"md5\": \"^2.3.0\",\n    \"path\": \"^0.12.7\",\n    \"ws\": \"^8.5.0\"\n  },\n  \"devDependencies\": {\n    \"@types/fs-extra\": \"^9.0.13\",\n    \"@types/md5\": \"^2.3.2\",\n    \"@types/ws\": \"^8.5.3\",\n    \"rimraf\": \"^3.0.2\",\n    \"ts-node\": \"^10.8.1\",\n    \"typescript\": \"^4.7.4\"\n  }\n}\n```\n\n\n因为这个`package.json`最后会被拷贝到`build`文件夹中去，所以以下配置都是基于`build`目录下的配置选项\n\n\n| 关键参数    | 值                  | 备注             |\n| ------- | ------------------ | -------------- |\n| main    | ./cjs/index.js     | commonjs 的入口文件 |\n| module  | ./esm5/index.js    | esmodule 的入口文件 |\n| typings | ./types/index.d.ts | 类型声明的入口文件      |\n\n\n## tsconfig.json\n\n\n```json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"moduleResolution\": \"node\",\n    \"target\": \"es2018\",\n    \"lib\": [\"es2018\"],\n    \"outDir\": \"build/node\",\n    \"rootDirs\": [\"./src\"],\n    \"strict\": true,\n    \"sourceMap\": true,\n    \"inlineSources\": true,\n    \"removeComments\": false,\n    \"esModuleInterop\": true,\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"exclude\": [\"build\", \"node_modules\", \"sample\", \"**/*.spec.ts\", \"test/**\"]\n}\n```\n\n\n## tsconfig.cjs.json\n\n\n```json\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"module\": \"CommonJS\",\n    \"outDir\": \"build/cjs\"\n  },\n}\n```\n\n\n## tsconfig.esm5.json\n\n\n```json\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"module\": \"ES2015\",\n    \"target\": \"ES5\",\n    \"outDir\": \"build/esm5\",\n  },\n}\n```\n\n\n## tsconfig.types.json\n\n\n```json\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"declaration\": true,\n    \"emitDeclarationOnly\": true,\n    \"outDir\": \"build/types\",\n  },\n}\n```\n\n\n# 自动化发布\n\n\n在项目根目录新建`.github/workflows/cd.yml`，并配置`github actions`，`secrets.NPM_PUBLISH_TOKEN`需要去`npm`官网生成`token`并配置到`github`仓库的`Actions secrets`中。\n\n\n```yaml\nname: CD\non:\n  release:\n    types: [created]\njobs:\n  publish:\n    name: Publish to NPM\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: 'lts/*'\n          registry-url: https://registry.npmjs.org\n      - run: npm ci --ignore-scripts\n      - run: npm run build:cjs\n      - run: npm run build:esm5\n      - run: npm run build:types\n      - run: cp LICENSE build/LICENSE\n      - run: cp README.md build/README.md\n      - run: jq 'del(.devDependencies) | del(.scripts)' package.json > build/package.json\n      - run: npm publish ./build\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_PUBLISH_TOKEN }}\n```\n\n\n# 大功告成！\n\n\n经过以上配置，就可以在`github`创建`release`版本时触发`actions`，将`build`文件夹中的压缩包发布到`npm`了！\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-06-23",
        "type": "Post",
        "slug": "qzmpp5",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何使用Github Actions自动化发布npm包，以及如何打造一个同时导出cjs和esm的npm包。文章详细介绍了配置文件的目录结构和关键参数，以及自动化发布的具体步骤。",
        "更新时间": "2023-05-31T16:23:00.000Z",
        "title": "利用github actions自动化发布npm",
        "category": "技术分享",
        "tags": [
          "Github Actions",
          "Node"
        ],
        "status": "Published",
        "urlname": "335ae226-1802-4706-98b5-2a09bde056a1",
        "updated": "2023-05-31 16:23:00"
      },
      "body": "",
      "realName": "利用github actions自动化发布npm",
      "relativePath": "/利用github actions自动化发布npm.md"
    },
    {
      "id": "d7b1453e-530d-4614-8d41-c5ac6972e351",
      "doc_id": "d7b1453e-530d-4614-8d41-c5ac6972e351",
      "title": "d7b1453e-530d-4614-8d41-c5ac6972e351",
      "updated": 1685550180000,
      "body_original": "\n# 引言\n\n\n在之前的文章[语雀云端写作 Hexo+Github Actions+COS 持续集成](https://1874.cool/roeayv) 中，语雀`webhook`触发构建的流程如下：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FmBBicekAEyyKQlzZSWZxgWjZ0Qn.jpeg)\n\n\n而当时腾讯云函数对个人使用还是在一定条件下免费的，本着能白嫖就白嫖的心态就用它做中转服务调用了。结果从上个月开始，腾讯云函数涨价了，而且费用也不便宜，我看了下账单，一个月差不多要快 10 块钱了，这我可忍不了。 所以就打算自己搭建一个`node`服务，自己调用`Github Actions`的`API`触发构建。流程如下：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FiOZZFrZK2WNImXPudM_Eggi4hCJ.jpeg)\n\n\n# 部署流程\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FpafgH_mmn7S7Xdf2eI_tZuZUpco.jpeg)\n\n\n# 搭建 Node 服务\n\n\n搭建记录请看[Midway 项目搭建](https://1874.cool/zbbxv0)\n\n\n# 开通腾讯云容器镜像服务（可选）\n\n\n目前腾讯云容器镜像服务对个人还是免费的，我就先用这个，不免费了再说。也可以直接推送到`Docker Hub`\n\n\n> 实操过程中发现：由于 Github Actions 使用的机器都是美国的，所以选择在香港/海外新建会快很多很多！\n\n\n\t![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fi5ZyPntP28VPpJP66tQDzSirGxn.png)\n\n\n具体开通流程和快速入门请直接移步[腾讯云容器镜像服务个人版快速入门](https://cloud.tencent.com/document/product/1141/63910)\n\n\n# 配置 Github Actions\n\n\n## 编写 workflows 流程\n\n\n在 Node 项目的根目录新建`.github/workflows/docker-build-deploy.yml`文件\n\n\n```yaml\nname: Docker Image CI & CD\n\non:\n  # 在直接推送/pr到Master分支时触发\n  push:\n    branches: [ \"master\" ]\n  pull_request:\n    branches: [ \"master\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: 构建镜像\n        # 选择推送到香港的镜像仓库会快很多\n        run: docker build --file Dockerfile --tag hkccr.ccs.tencentyun.com/命名空间/镜像名称 .\n      - name: 登录腾讯的 docker 镜像仓库\n        run: echo \"${{ secrets.TENCENT_REGISTRY_PASSWORD }}\" | docker login hkccr.ccs.tencentyun.com --username=用户名 --password-stdin\n      - name: 把构建好的镜像推送到腾讯仓库\n        run: docker push hkccr.ccs.tencentyun.com/命名空间/镜像名称\n\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 初始化ssh并执行sh启动镜像\n        run: |\n          eval $(ssh-agent -s)\n          echo \"${{secrets.SERVER_SSH_PRIV_KEY}}\" > deploy.key\n          mkdir -p ~/.ssh\n          chmod 0600 deploy.key\n          ssh-add deploy.key\n          echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config\n          ssh root@${{secrets.SERVER_IP}} \"cd /home/deploy && sh deploy.sh\"\n    # 在build结束后才会运行deploy\n    needs: build\n```\n\n\n## Github Secrets\n\n\n上面 yml 文件中的 `secrets.XXX` 是一些秘钥，`Github` 为了保护你的秘钥，提供了使用变量的办法，我们可以在仓库的 `Settings -> Secrets`中定义变量，然后按照 `${{ secrets.XXX }}` 的格式，即可拿到变量值。\n\n\n## 连接云服务器\n\n\n`secrets.SERVER_SSH_PRIV_KEY` 是用来访问远程服务器的私钥，具体：\n\n- 在云服务器生成密钥对\n- 在远程服务器上添加公钥 (将公钥添加到服务器的 ~/.ssh/authorized_keys 文件中)\n- 在 Github 仓库设置私钥 (Settings > Secrets)\n\n`secrets.SERVER_IP` 是远程服务器地址\n\n\n## deploy.sh\n\n\n```shell\n#/bin/bash\ndocker pull hkccr.ccs.tencentyun.com/命名空间/镜像名称docker stop 镜像名称docker rm 镜像名称docker run -d --name 镜像名称 -p 7001:7001 hkccr.ccs.tencentyun.com/命名空间/镜像名称\n```\n\n\n# 配置 DockerFile\n\n\n## Dockerfile\n\n\n在 Node 项目的根目录新建`Dockerfile`文件\n\n\n```docker\nFROM node:12 AS build\n\nWORKDIR /app\n\nCOPY . .\n\nRUN npm install\n\nRUN npm run build\n\nFROM node:12-alpine\n\nWORKDIR /app\n\nCOPY --from=build /app/dist ./dist\nCOPY --from=build /app/bootstrap.js ./\nCOPY --from=build /app/package.json ./\n\nRUN apk add --no-cache tzdata\n\nENV TZ=\"Asia/Shanghai\"\n# 只安装生产的包\nRUN npm install --production\n\n# 暴露端口号\nEXPOSE 7001\n# 使用pm2启动项目\nRUN npm install pm2 -g\nCMD [ \"pm2-runtime\", \"npm\", \"--\", \"start\" ]\n```\n\n\n上述相关的 npm 命令需要根据自己实际命令修改。\n\n\n## .dockerignore\n\n\n在 Node 项目的根目录新建`.dockerignore`文件，可以将`.gitignore`中的配置复制过去\n\n\n# Done！\n\n\n接下来就可以推送代码到 master 分支，就会自动部署项目了！\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FgtBByqByzlP4sMg5Ibn8-8xhuLX.png)\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-07-16",
        "type": "Post",
        "slug": "ovugli",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何使用 Github Actions 持续集成 Docker 构建并部署 Node 项目到云服务器。具体流程包括搭建 Node 服务、开通腾讯云容器镜像服务、配置 Github Actions、编写 workflows 流程、连接云服务器、配置 DockerFile 等。最终实现推送代码到 master 分支自动部署项目。",
        "更新时间": "2023-05-31T16:23:00.000Z",
        "title": "Github Actions持续集成 Docker构建并部署Node项目到云服务器",
        "category": "技术分享",
        "tags": [
          "Docker",
          "CI/CD",
          "Node",
          "Github Actions"
        ],
        "status": "Published",
        "urlname": "d7b1453e-530d-4614-8d41-c5ac6972e351",
        "updated": "2023-05-31 16:23:00"
      },
      "body": "",
      "realName": "Github Actions持续集成 Docker构建并部署Node项目到云服务器",
      "relativePath": "/Github Actions持续集成 Docker构建并部署Node项目到云服务器.md"
    },
    {
      "id": "f674c03b-a560-4d80-984a-ede9d0ec6d9f",
      "doc_id": "f674c03b-a560-4d80-984a-ede9d0ec6d9f",
      "title": "f674c03b-a560-4d80-984a-ede9d0ec6d9f",
      "updated": 1685550180000,
      "body_original": "\n# 引言\n\n\n其实一开始没打算要搞这玩意儿的，事情的起因还得从我同事开始说起。 同事利用空余时间，开发了一款表情包小程序和 App，里面有各种表情包可以下载，挺有意思，我也推荐了其他朋友使用。\n\n\n然后我就琢磨着也搞个什么玩玩，前几天想到了一个点子，准备着手开发`Node`服务端时，想到有一些连接参数、可配置参数、账号密码什么的我又不想写死在代码里。因为公司用的是`Apollo`，一些可配置的参数是放在`Apollo`来管理的。再加上我问了下我同事，他的项目就是把这些东西写死在代码里的，他也觉得如果有一个配置中心来管理这些的话会方便很多。 \n\n\n但是`Apollo`过于复杂了，对于我这种小项目是有点过了，于是在`Github`搜索一圈之后，偶然发现了[AgileConfig](https://github.com/dotnetcore/AgileConfig)这个轻量级的配置中心，但可惜的是只有`C#`的客户端，其他语言的客户端都没有。于是我就抱着试一试的想法加了这个项目的 QQ 群，果然还没有人开发`nodejs`的客户端。 于是我的兴趣就来了，由于我以前有`Java`语言的基础，所以`C#`的代码勉强能读懂，所以结合着`C#`的客户端和与群主的交流，终于开发出了一个相对稳定的`nodejs`客户端：[node-agile-client](https://github.com/LetTTGACO/node-agile-client) \n\n\n就此分享下我的开发过程和源码逻辑。\n\n\n# 开始\n\n\n配置中心听起来很高大上，其实说白了就是一个在线的数据库，客户端可以通过`http`请求去获取某个应用在某个环境下的`JSON`配置。所以我要做的就是通过`http`请求拿数据就完事，就是如此简单。\n\n\n当然配置中心最核心的不只是能分应用分环境地存储数据，高可用也是其必不可少的能力。所以配置中心一般都是多节点分布式部署，客户端的代码大部分代码逻辑也是围绕着高可用去实现。\n\n\n[AgileConfig](https://github.com/dotnetcore/AgileConfig)服务端除了向外暴露获取配置的`http`接口，还提供了`websocket`长链接机制，当配置中心发生配置变更时会发送消息告诉客户端。\n\n\n# 基础工作原理流程图\n\n\n于是我就构思了[node-agile-client](https://github.com/LetTTGACO/node-agile-client)的基础工作原理流程图：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FnGZZCTPJNVUKA3cSKxwOv45nRzh.png)\n\n\n我的想法是充分利用缓存，`node`使用端在需要时只需要读取本地的配置文件或者内存中的缓存即可拿到`json`文件。对于缓存的处理，如下图所示：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fi902QOqP5_v6kgBr4U5XnKHf_As.jpeg)\n\n\n# 完整工作原理流程图\n\n\n在完整的研究了`AgileConfig`的`C#`客户端原理之后，发现`AgileConfig`有以下几个功能点：\n\n\n---\n\n- 多节点`http`访问\n- 多节点`websocket`访问\n- `websocket`心跳检测时会返回当前配置中心文件的`md5`\n- 手动更新配置时会通过`websocket`向客户端发送需要更新的消息\n- 手动关闭连接时会通过`websocket`向客户端发送需要关闭连接的消息\n\n所以基于以上几个功能点，我画出了`node-agile-client`的完整工作原理流程图：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fi8seFPwjcCvorcZxZY1A2bMTZz4.png)\n\n\n# 代码实现\n\n\n接下来就到了代码实现的阶段，由于是第一次完整开发`npm`包，没啥经验，所以实现需求是第一要务，暂不考虑`npm`包的打包压缩、`TypeScript`支持等等功能。开发出来的包也并不适用于生产环境，待后期慢慢完善。\n\n\n## 目录结构\n\n\n## 源码逻辑\n\n\n先说明一下配置参数说明：\n\n\n| 配置项名称       | 数据类型    | 配置项说明       | 必填 | 备注                                            |\n| ----------- | ------- | ----------- | -- | --------------------------------------------- |\n| appid       | string  | 应用 ID       | 是  | 对应后台管理中应用的`应用ID`                              |\n| secret      | string  | 应用密钥        | 是  | 对应后台管理中应用的`密钥`                                |\n| nodes       | string  | 应用配置节点      | 是  | 存在多个节点则使用逗号`,`分隔                              |\n| env         | string  | 配置中心的环境     | 否  | 通过此配置决定拉取哪个环境的配置信息；如果不配置，服务端会默认返回第一个环境的配置     |\n| name        | string  | 连接客户端的自定义名称 | 否  | 方便在 agile 配置中心后台对当前客户端进行查阅与管理                 |\n| tag         | string  | 连接客户端自定义标签  | 否  | 方便在 agile 配置中心后台对当前客户端进行查阅与管理                 |\n| httptimeout | number  | http 请求超时时间 | 否  | 配置 client 发送 http 请求的时候的超时时间，默认 100000(100 秒) |\n| debug       | boolean | debug 模式    | 否  | 打印更多信息                                        |\n\n\n```javascript\nconst axios = require('axios')\nconst path = require('path')\nconst fs = require('fs-extra')\n// utils\nconst { generateAuthorization, transformConfig, getTime, generateUrl } = require('./utils')\nconst { WS } = require('./ws')\n// const\nconst { WEBSOCKET_ACTION } = require('./const/ws')\n\n// 配置缓存\nlet agileConfigCache\n\n/**\n* 初始化agile配置\n* @param options\n* @returns {Promise<void>}\n*/\nasync function init(options) {\n  const { appid, secret, env, nodes } = options\n  const beginTime = Date.now();\n  // 生成请求头\n  // 请求http/websocket需要特定的请求头，详情看utils/auth.js文件\n  options.headers = generateAuthorization(options)\n  try {\n    // 初始化agile配置\n    await initAgileConfig(options);\n    console.info(`【agile】: 初始化agile服务成功，耗时: ${Date.now() - beginTime}ms。`);\n  } catch (err) {\n    console.error({\n      message: '【agile】: 初始化agile失败',\n      error: err\n    });\n    // 退出进程\n    process.exit(-1);\n  }\n}\n\n/**\n* 初始化agile配置\n* @param options\n* @returns {Promise<*|undefined>}\n*/\nasync function initAgileConfig(options) {\n  // websocket长连接\n  // 这里websocket和http请求不是阻塞的，防止http/ws其中一个连接失败时阻塞流程\n  getNotifications(options)\n  await getAgileConfigAsync(options, true);\n}\n\n/**\n* websockt连接\n* @param options\n*/\nfunction getNotifications(options) {\n  // 生成ws连接的Url\n  const wsPaths = generateUrl(options, true)\n  \n  // 递归调用，用于多节点保证可用性\n  function connect(index) {\n    try {\n      const ws = new WS(wsPaths[index], {\n        debug: !!options.debug,\n        wsOptions: { headers: options.headers },\n      })\n      ws.websocketOnOpen(() => {\n        console.info(`【agile】: websocket连接成功，连接地址：${wsPaths[index]}`)\n      })\n      ws.websocketOnMessage((data) => {\n        if (data.indexOf(\"Action\") !== -1) {\n          // 服务端更新了\n          const { Action: action } = JSON.parse(data)\n          if (action === WEBSOCKET_ACTION.RELOAD) {\n            // 不使用本地缓存，直接发起http请求更新缓存\n            getAgileConfigAsync(options, false).catch()\n          }\n          if (action === WEBSOCKET_ACTION.OFFLINE) {\n            // 关闭ws连接\n            ws.removeSocket(true)\n          }\n        } else if (data !== '0' && data.startsWith('V:')) {\n          // 心跳检测时/服务端主动关闭连接时，同步配置\n          // 对比本地缓存中的MD5和心跳检测时服务端返回的MD5\n          if (data.slice(2) !== agileConfigCache.md5) {\n            console.info('【agile】: 配置更新，即将重新读取配置')\n            // 不使用本地缓存，直接发起http请求更新缓存\n            getAgileConfigAsync(options, false).catch()\n          }\n        }\n      })\n      ws.websocketOnError((err) => {\n        console.warn({\n          message: '【agile】: websocket连接发生错误，正在尝试重新连接...',\n          error: err\n        });\n        // 连接下一个节点，尝试尝试重新连接ws\n        throw err\n      })\n      ws.websocketOnClose(() => {\n        console.warn('【agile】: websocket断开连接，将会读取本地缓存');\n      })\n    } catch (err) {\n      // 初始化失败时，更换ws节点\n      index = index + 1;\n      if (index < wsPaths.length) {\n        // 递归调用，连接下一个节点\n        connect(index)\n      } else {\n        console.error({\n          url: `【agile】：请求地址：${wsPaths}`,\n          message: `【agile】：websocket连接失败，将会读取本地缓存`,\n          error: err,\n        })\n      }\n    }\n  }\n  connect(0)\n}\n\n/**\n* 异步获取agile配置\n* @param options\n* @param useCache 是否使用缓存\n* @returns {Promise<*>}\n*/\nasync function getAgileConfigAsync(options, useCache) {\n  if (useCache) {\n    // 优先从缓存中获取信息\n    const beginTime = Date.now();\n    const agileConfig = getAgileConfigFromCache(beginTime);\n    if (agileConfig) {\n      return agileConfig;\n    }\n    console.info('【agile】: 开始初始化agile配置(通过接口获取)');\n  }\n  // 从接口中获取\n  try {\n    agileConfigCache = await getAgileConfigPromise(options);\n    // 写入本地文件\n    fs.writeJsonSync(path.resolve(__dirname, './agileConfig.json'), agileConfigCache);\n    console.info(`【agile】: 更新缓存成功, 更新时间：${getTime()}`)\n    return agileConfigCache;\n  } catch (err) {\n    console.warn({\n      message: '【agile】: 更新缓存失败，将会读取本地缓存',\n      error: err\n    });\n    throw err;\n  }\n}\n\n/**\n* 从缓存中获取agile配置\n* @param beginTime\n* @returns {*}\n*/\nfunction getAgileConfigFromCache(beginTime) {\n  if (agileConfigCache) {\n    return agileConfigCache;\n  }\n  try {\n    const cacheFile = path.join(__dirname, './agileConfig.json');\n    const isHave = !!fs.statSync(cacheFile).size;\n    console.info('【agile】: 开始初始化agile配置(通过缓存获取)');\n    if (isHave) {\n      // 从本地文件读取配置\n      agileConfigCache = fs.readJsonSync(path.resolve(__dirname, './agileConfig.json'));\n      if (agileConfigCache) {\n        return agileConfigCache\n      }\n    }\n  } catch (err) {}\n  \n  return agileConfigCache;\n}\n\n/**\n* 从服务端获取配置并写入缓存\n* @param options\n* @returns {Promise<*>}\n*/\nasync function getAgileConfigPromise(options) {\n  // 获取http请求url\n  const urlPaths = generateUrl(options, false);\n  let agileConfigRes\n  // 递归调用，适配多节点获取配置\n  const getConfig = async (index) => {\n    console.info(`【agile】：接口请求地址：${urlPaths[index]}`)\n    try {\n      const response = await axios.get(urlPaths[index], {\n        timeout: options.httptimeout || 100000,\n        headers: {\n          ...options.headers,\n        },\n      })\n      agileConfigRes = transformConfig(response.data);\n    } catch (err) {\n      index = index + 1;\n      if (index < urlPaths.length) {\n        // 递归调用，连接下一个节点\n        await getConfig(urlPaths, index);\n      } else {\n        console.error({\n          url: `agile请求地址：${urlPaths}`,\n          message: `【agile】警告：获取agile配置失败,appid: ${options.appid}`,\n          error: err,\n        })\n        throw err;\n      }\n    }\n  };\n  await getConfig(urlPaths, 0);\n  return agileConfigRes\n}\n\n\n/**\n* 同步获取Agile配置\n* @returns {*}\n*/\nfunction getAgileConfig() {\n  if (!agileConfigCache) {\n    try {\n      agileConfigCache = fs.readJsonSync(path.resolve(__dirname, './agileConfig.json'))\n    } catch (err) {}\n    if (!agileConfigCache) {\n      throw new Error('【agile】: 请确保agile初始化已完成！');\n    }\n  }\n  return agileConfigCache.data;\n}\n\nexports.init = init\nexports.getAgileConfig = getAgileConfig\n```\n\n\n```javascript\nconst { WebSocket } = require('ws');\n\nclass WS {\n  constructor(socketUrl, option) {\n    this.socketUrl = socketUrl\n    this.option = {\n      onOpenAutoSendMsg:\"\",\n      heartTime: 30000, // 心跳时间间隔\n      heartMsg: 'ping', // 心跳信息,默认为'ping'\n      isReconnect: true, // 是否自动重连\n      reconnectTime: 5000, // 重连时间间隔\n      reconnectCount: -1, // 重连次数 -1 则不限制\n      openCallback: null, // 连接成功的回调\n      closeCallback: null, // 关闭的回调\n      messageCallback: null, // 消息的回调\n      errorCallback: null, // 错误的回调\n      debug: false,  //是否打开debug模式\n      ...option,\n    }\n    this.websocket = null\n    this.sendPingInterval = null  //心跳定时器\n    this.reconnectInterval = null  //重连定时器\n    this.activeLink = true  //socket对象是否可用\n    this.disconnect = false  //是否是服务端主动切断socket连接\n    this.reconnectNum = 0 //重连次数限制\n    this.init()\n  }\n  \n  /**\n  * 初始化\n  */\n  init() {\n    Reflect.deleteProperty(this, this.websocket)\n    this.websocket = new WebSocket(this.socketUrl, {\n      ...this.option.wsOptions,\n    })\n    this.websocketOnOpen()\n    this.websocketOnMessage()\n    this.websocketOnError()\n    this.websocketOnClose()\n  }\n  \n  /**\n  * 连接成功\n  */\n  websocketOnOpen(callback) {\n    this.websocket.onopen = (event) => {\n      if (this.option.debug) console.log('%c websocket链接成功', 'color:green')\n      // 连接成功时定时向发送消息\n      this.sendPing(this.option.heartTime, this.option.heartMsg);\n      if(this.option.onOpenAutoSendMsg){\n        this.send(this.option.onOpenAutoSendMsg)\n      }\n      if (typeof callback === 'function') {\n        this.disconnect = false\n        callback(event)\n      } else {\n        (typeof this.option.openCallback === 'function') && this.option.openCallback(event)\n      }\n    }\n  }\n  \n  /**\n  * 发送数据\n  * @param message\n  */\n  send (message){\n    if (this.websocket.readyState !== this.websocket.OPEN) {\n      new Error('没有连接到服务器，无法发送消息')\n      return\n    }\n    this.websocket.send(message)\n  }\n  \n  /**\n  * 触发接收消息事件\n  * @param callback\n  */\n  websocketOnMessage(callback) {\n    this.websocket.onmessage = (event) => {\n      // 收到任何消息，重新开始倒计时心跳检测\n      if (typeof callback === 'function') {\n        callback(event.data)\n      } else {\n        (typeof this.option.messageCallback === 'function') && this.option.messageCallback(event.data)\n      }\n    }\n  }\n  \n  /**\n  * 连接错误\n  * @param callback\n  */\n  websocketOnError(callback) {\n    this.websocket.onerror = (event) => {\n      if (this.option.debug) console.error('连接发生错误', event)\n      if (typeof callback === 'function') {\n        callback(event)\n      } else {\n        (typeof this.option.errorCallback === 'function') && this.option.errorCallback(event)\n      }\n    }\n  }\n  \n  /**\n  * 连接关闭\n  */\n  websocketOnClose(callback) {\n    this.websocket.onclose = (event) => {\n      if (this.option.debug) console.warn('socket连接关闭,关于原因:', event)\n      clearInterval(this.sendPingInterval)\n      clearInterval(this.reconnectInterval);\n      if (this.activeLink && this.option.isReconnect) {\n        this.onReconnect()\n      } else {\n        this.activeLink = false;\n        if (this.option.debug) console.log('%c websocket链接完全关闭', 'color:green')\n      }\n      if (typeof callback === 'function') {\n        callback(event)\n      } else {\n        (typeof this.option.closeCallback === 'function') && this.option.closeCallback(event)\n      }\n    }\n  }\n  \n  /**\n  * 连接事件\n  */\n  onReconnect() {\n    if (this.option.debug) console.warn(`非正常关闭,${this.option.reconnectTime}毫秒后触发重连事件`)\n    if (this.option.reconnectCount === -1 || this.option.reconnectCount > this.reconnectNum) {\n      this.reconnectInterval = setTimeout(() => {\n        this.reconnectNum++\n        if (this.option.debug) console.warn(`正在准备第${this.reconnectNum}次重连`)\n        this.init()\n      }, this.option.reconnectTime)\n    } else {\n      this.activeLink = false;\n      if (this.option.debug) console.warn(`已重连${this.reconnectNum}次仍然没有响应,取消重连`)\n      clearInterval(this.reconnectInterval);\n    }\n  }\n  \n  /**\n  * 移除socket并关闭\n  */\n  removeSocket(disconnect) {\n    this.activeLink = false\n    this.disconnect = disconnect\n    this.websocket.close(1000)\n  }\n  \n  /**\n  * 心跳机制\n  * @param time\n  * @param ping\n  */\n  sendPing (time = 5000, ping = 'ping'){\n    clearInterval(this.sendPingInterval);\n    if (time === -1) return\n    this.send(ping)\n    this.sendPingInterval = setInterval(() => {\n      this.send(ping)\n    }, time)\n  }\n  \n  /**\n  * 返回websocket实例\n  * @returns {null}\n  */\n  getWebsocket() {\n    return this.websocket\n  }\n  \n  /**\n  * 查看连接状态\n  */\n  getActiveLink() {\n    return {\n      activeLink: this.activeLink,\n      disconnect: this.disconnect\n    }\n  }\n}\n```\n\n\n# 开始使用\n\n\n## 安装\n\n\n```shell\nnpm i node-agile-client\n```\n\n\n## 初始化\n\n\n```javascript\nconst { init } = require('node-agile-client');\n\ninit({\n  appid: 'app',\n  secret: 'xxx',\n  node: 'http://192.168.1.1,http://192.168.1.2',\n  env: 'DEV',\n  tag: '',\n  name: '',\n  httptimeout: 100,\n  debug: false,\n});\n```\n\n\n## 获取配置\n\n\n```javascript\nconst { getAgileConfig }  = require('node-agile-client');\n\nconst { token, url } = getAgileConfig();\n```\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-04-28",
        "type": "Post",
        "slug": "wqx8a7",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "该文档介绍了如何使用node-agile-client为开源社区做贡献，开发AgileConfig的NodeJS客户端。该客户端包括了异步获取agile配置、从缓存中获取agile配置、从服务端获取配置并写入缓存、同步获取Agile配置等功能。通过该客户端，可以轻松获取到Agile配置。",
        "更新时间": "2023-05-31T16:23:00.000Z",
        "title": "为开源社区做贡献-开发AgileConfig的NodeJS客户端：node-agile-client",
        "category": "技术分享",
        "tags": [
          "Node"
        ],
        "status": "Published",
        "urlname": "f674c03b-a560-4d80-984a-ede9d0ec6d9f",
        "updated": "2023-05-31 16:23:00"
      },
      "body": "",
      "realName": "为开源社区做贡献-开发AgileConfig的NodeJS客户端：node-agile-client",
      "relativePath": "/为开源社区做贡献-开发AgileConfig的NodeJS客户端：node-agile-client.md"
    },
    {
      "id": "08ccfc16-c8cb-42a2-ad65-b37c4d49ce78",
      "doc_id": "08ccfc16-c8cb-42a2-ad65-b37c4d49ce78",
      "title": "08ccfc16-c8cb-42a2-ad65-b37c4d49ce78",
      "updated": 1681103040000,
      "body_original": "\n# 引言\n\n\n最近发现`Alfred`简直不要太好用，快速打开网址功能（Web Search）在工作中使用起来行云流水，再也不用去一堆标签中寻找常用的网址。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fv_hSWNtWTOroC6OS4YOH23qjov0.png)\n\n\n但是在项目开发过程中，经常需要打开或运行各种项目，所以需要经常使`iTerm`或者`IDE`进入到各种项目文件夹中。在`VSCode`中，大家经常会使用`code`命令打开项目，再配合环境变量的别名设置，使用起来很方便。但是！我是忠诚的`WebStorm`党派，每次打开项目都得先打开应用然后找到需要打开的项目（不过后来发现，`WebStorm`其实也有命令行启动器，效果也一样）。但是这么做也有一个痛点，就是需要事先配置环境变量的别名才能做到快速打开。 最近一琢磨，可以利用`Aflfed`的`Workflows`功能去尝试一下，于是真被我搞出来了，这里记录一下。\n\n\n# 开始\n\n\n## Open in WebStorm\n\n\n用`WebStrom`打开项目。通过`code`命令打开指定目录下的文件夹，快速打开项目。效果如下：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/ljMKIzYLU9Vg0ZDdlgkVUc2TAFkL.gif)\n\n\n### 运行流程\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fi1CSGPgbhxcEmVJsWkhTRKofLx0.png)\n\n\n### 设置\n\n1. 右下角新建一个`Blank Workflow`，配置如下：\n\n注意`Bundle id`必须是唯一的才行。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FkbsFFLjrHAiiyFhMyAnsYxAG1cu.png)\n\n1. 右键新增一个`File Filter`，配置如下：\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FtNswxM5ZqzKXFXYXRPMO5gdQMc4.png)\n\n\n`Basic Setup`基础设置。\n\n- Keyword: code\n- with space: true\n- Placeholder Title: Open in WebStorm\n- Placeholder Subtext: 请继续输入以打开项目\n- File Types: 文件类型，随便拖一个文件夹进去表示只识别文件夹，过滤掉文件\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fteyhe06uV8m5mE7wZoNN6IJ-GE1.png)\n\n\n`Scope`搜索范围\n\n- Search Scope: 指定搜索范围，将目录拖拽进去即可\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FgE6bMn1YgtGzP1bkxhMhdRUvGn6.png)\n\n\n`Fields`和`Limit and Sort`保持不变，可以根据自己的习惯修改\n\n1. 左键单击并选择添加`Actions-Run Script`，配置如下：\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FusgOROVeGtM5HvHHey1GxHOKdxL.png)\n\n- Language: /bin/zsh 终端，也可以选择/bin/bash 终端\n- with input as {query}: true\n- running instances: Sequentially\n- Script: /usr/local/bin/wstorm “{query}”\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fj3KjVMT_TxIJCWRGGZdcplCQViA.png)\n\n\n注意：使用`/usr/local/bin/wstorm`命令需要在`WebStorm`中开启工具-创建命令行启动器，配置脚本位置为`/usr/local/bin`，并配置脚本命令为`wstorm`。\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FiyIJ9N-DdDJK4NvGJwCwO_EqjeW.png)\n\n\n## Open in iTerm\n\n\n从`iTerm`中打开文件夹。通过`cd`命令进入指定目录下的文件夹，快速打开项目并运行。效果如下：\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/ltjnpxJnEnmaDsxBBb2Q3M11U_tJ.gif)\n\n\n### 运行流程\n\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FlehoM7bdsPdu33pG4_DfRDM06wl.png)\n\n\n### 设置\n\n1. 新建一个`Blank workflow`，配置如下：\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FoiKddQ7QD7GegR1SoQ3Em0xGpwT.png)\n\n1. 新增`File Filter`，配置如下：\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/Fltm6hEMqabbF4xluHh9ph0HYpoG.png)\n\n1. 左键单击并选择添加 Actions-Run NSAppleScript，配置如下：\n\n![](https://blogimagesrep-1257180516.cos.ap-guangzhou.myqcloud.com/blog-images/FoE5xUh8YN6K2pZSd6a976xz5KF_.png)\n\n\n```text\n-- For the latest version:\n-- https://github.com/vitorgalvao/custom-alfred-iterm-scripts\n\n-- Set this property to true to always open in a new window\nproperty open_in_new_window : false\n\n-- Set this property to false to reuse current tab\nproperty open_in_new_tab : true\n\n-- Handlers\non new_window()\ntell application \"iTerm\" to create window with default profile\nend new_window\n\non new_tab()\ntell application \"iTerm\" to tell the first window to create tab with default profile\nend new_tab\n\non call_forward()\ntell application \"iTerm\" to activate\nend call_forward\n\non is_running()\napplication \"iTerm\" is running\nend is_running\n\non has_windows()\nif not is_running() then return false\nif windows of application \"iTerm\" is {} then return false\ntrue\nend has_windows\n\non send_text(custom_text)\ntell application \"iTerm\" to tell the first window to tell current session to write text custom_text\nend send_text\n\n-- Main\non alfred_script(query)\nif has_windows() then\nif open_in_new_window then\nnew_window()\nelse if open_in_new_tab then\nnew_tab()\nelse\n-- Reuse current tab\nend if\nelse\n-- If iTerm is not running and we tell it to create a new window, we get two\n-- One from opening the application, and the other from the command\nif is_running() then\nnew_window()\nelse\ncall_forward()\nend if\nend if\n\n-- Make sure a window exists before we continue, or the write may fail\nrepeat until has_windows()\ndelay 0.01\nend repeat\n\nsend_text(query)\ncall_forward()\nend alfred_script\n```\n\n\n# 大功告成！\n\n",
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-04-19",
        "type": "Post",
        "slug": "rm057k",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "Alfred YYDS",
        "更新时间": "2023-04-10T05:04:00.000Z",
        "title": "程序员必备——Mac效率工具Alfred Workflows配置",
        "category": "技术分享",
        "tags": [
          "效率工具"
        ],
        "status": "Published",
        "urlname": "08ccfc16-c8cb-42a2-ad65-b37c4d49ce78",
        "updated": "2023-04-10 05:04:00"
      },
      "body": "",
      "realName": "程序员必备——Mac效率工具Alfred Workflows配置",
      "relativePath": "/程序员必备——Mac效率工具Alfred Workflows配置.md"
    }
  ],
  "catalog": [
    {
      "object": "page",
      "id": "d2a19be4-4efc-428a-9ebb-0a85e340290d",
      "created_time": "2023-08-18T14:16:00.000Z",
      "last_edited_time": "2023-10-18T16:31:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/book-closed_red.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-08-18T14:16:00.000Z",
        "date": "2023-10-19",
        "type": "Post",
        "slug": "how-do-i-take-note",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-10-18T16:31:00.000Z",
        "title": "我的笔记管理法",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Published",
        "urlname": "d2a19be4-4efc-428a-9ebb-0a85e340290d",
        "updated": "2023-10-18 16:31:00"
      },
      "url": "https://www.notion.so/d2a19be44efc428a9ebb0a85e340290d",
      "public_url": "https://1874.notion.site/d2a19be44efc428a9ebb0a85e340290d"
    },
    {
      "object": "page",
      "id": "86181a01-bf90-440b-876f-93e680ed7f92",
      "created_time": "2023-07-13T14:16:00.000Z",
      "last_edited_time": "2023-10-01T08:01:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/images/page-cover/gradients_8.png"
        }
      },
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/mathematics_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-13T14:16:00.000Z",
        "date": "2023-07-13",
        "type": "Post",
        "slug": "leetcode-day-2",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-10-01T08:01:00.000Z",
        "title": "【代码随想录】算法训练营第2天",
        "category": "算法刷题",
        "tags": [
          "算法训练营",
          "数组专题"
        ],
        "status": "Invisible",
        "urlname": "86181a01-bf90-440b-876f-93e680ed7f92",
        "updated": "2023-10-01 08:01:00"
      },
      "url": "https://www.notion.so/2-86181a01bf90440b876f93e680ed7f92",
      "public_url": "https://1874.notion.site/2-86181a01bf90440b876f93e680ed7f92"
    },
    {
      "object": "page",
      "id": "dda51961-f514-4a53-8d18-3a0c1ece2132",
      "created_time": "2023-07-12T03:20:00.000Z",
      "last_edited_time": "2023-09-27T03:35:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/images/page-cover/gradients_8.png"
        }
      },
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/mathematics_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-12T03:20:00.000Z",
        "date": "2023-07-12",
        "type": "Post",
        "slug": "leetcode-day-1",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-09-27T03:35:00.000Z",
        "title": "【代码随想录】算法训练营第1天",
        "category": "算法刷题",
        "tags": [
          "算法训练营",
          "数组专题"
        ],
        "status": "Invisible",
        "urlname": "dda51961-f514-4a53-8d18-3a0c1ece2132",
        "updated": "2023-09-27 03:35:00"
      },
      "url": "https://www.notion.so/1-dda51961f5144a538d183a0c1ece2132",
      "public_url": "https://1874.notion.site/1-dda51961f5144a538d183a0c1ece2132"
    },
    {
      "object": "page",
      "id": "003fd62e-3f11-47f8-8479-9eb728ac6df8",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-09-27T01:49:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🥏"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-01-20",
        "type": "Post",
        "slug": "osar7h",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了yuque-hexo插件语雀图片防盗链的解决方案，包括具体的实现流程和常见问题的解决方案。同时，提供了对于其他云服务的实现思路。",
        "更新时间": "2023-09-27T01:49:00.000Z",
        "title": "yuque-hexo插件语雀图片防盗链的解决方案",
        "category": "技术分享",
        "tags": [
          "Hexo"
        ],
        "status": "Invisible",
        "urlname": "003fd62e-3f11-47f8-8479-9eb728ac6df8",
        "updated": "2023-09-27 01:49:00"
      },
      "url": "https://www.notion.so/yuque-hexo-003fd62e3f1147f884799eb728ac6df8",
      "public_url": "https://1874.notion.site/yuque-hexo-003fd62e3f1147f884799eb728ac6df8"
    },
    {
      "object": "page",
      "id": "385c919d-f253-4976-9819-824ea05304e4",
      "created_time": "2023-09-02T17:33:00.000Z",
      "last_edited_time": "2023-09-05T09:14:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/notification_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-09-02T17:33:00.000Z",
        "date": "2023-09-03",
        "type": "Post",
        "slug": "rollup-multi-input",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "用Rollup打包多入口npm库，实现文件按需引入",
        "更新时间": "2023-09-05T09:14:00.000Z",
        "title": "Rollup打包——多入口配置",
        "category": "技术分享",
        "tags": [
          "Rollup",
          "打包构建"
        ],
        "status": "Draft",
        "urlname": "385c919d-f253-4976-9819-824ea05304e4",
        "updated": "2023-09-05 09:14:00"
      },
      "url": "https://www.notion.so/Rollup-385c919df25349769819824ea05304e4",
      "public_url": "https://1874.notion.site/Rollup-385c919df25349769819824ea05304e4"
    },
    {
      "object": "page",
      "id": "d1b83320-1450-4412-a436-9f1e21689cf6",
      "created_time": "2023-04-15T10:21:00.000Z",
      "last_edited_time": "2023-08-26T15:38:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/graduate_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-15T10:21:00.000Z",
        "date": "2023-04-17",
        "type": "Post",
        "slug": "day-6",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:38:00.000Z",
        "title": "Seven的成长笔记【第6篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "d1b83320-1450-4412-a436-9f1e21689cf6",
        "updated": "2023-08-26 15:38:00"
      },
      "url": "https://www.notion.so/Seven-6-d1b8332014504412a4369f1e21689cf6",
      "public_url": "https://1874.notion.site/Seven-6-d1b8332014504412a4369f1e21689cf6"
    },
    {
      "object": "page",
      "id": "5d58e4df-d7ea-46d6-9c6a-19b9d301d672",
      "created_time": "2023-04-10T17:12:00.000Z",
      "last_edited_time": "2023-08-26T15:38:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/graduate_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-10T17:12:00.000Z",
        "date": "2023-04-10",
        "type": "Post",
        "slug": "day-1",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:38:00.000Z",
        "title": "Seven的成长笔记【第1篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "5d58e4df-d7ea-46d6-9c6a-19b9d301d672",
        "updated": "2023-08-26 15:38:00"
      },
      "url": "https://www.notion.so/Seven-1-5d58e4dfd7ea46d69c6a19b9d301d672",
      "public_url": "https://1874.notion.site/Seven-1-5d58e4dfd7ea46d69c6a19b9d301d672"
    },
    {
      "object": "page",
      "id": "dfc6606a-ab95-45f7-94c2-4a736afdf57a",
      "created_time": "2023-04-11T12:56:00.000Z",
      "last_edited_time": "2023-08-26T15:38:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/graduate_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-11T12:56:00.000Z",
        "date": "2023-04-11",
        "type": "Post",
        "slug": "day-2",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "Notion AI 真香～",
        "更新时间": "2023-08-26T15:38:00.000Z",
        "title": "Seven的成长笔记【第2篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "dfc6606a-ab95-45f7-94c2-4a736afdf57a",
        "updated": "2023-08-26 15:38:00"
      },
      "url": "https://www.notion.so/Seven-2-dfc6606aab9545f794c24a736afdf57a",
      "public_url": "https://1874.notion.site/Seven-2-dfc6606aab9545f794c24a736afdf57a"
    },
    {
      "object": "page",
      "id": "0b7ef73a-c23e-4019-8139-a87b987968f3",
      "created_time": "2023-04-12T16:14:00.000Z",
      "last_edited_time": "2023-08-26T15:37:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/graduate_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-12T16:14:00.000Z",
        "date": "2023-04-12",
        "type": "Post",
        "slug": "day-3",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "RxJs 针不错～",
        "更新时间": "2023-08-26T15:37:00.000Z",
        "title": "Seven的成长笔记【第3篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "0b7ef73a-c23e-4019-8139-a87b987968f3",
        "updated": "2023-08-26 15:37:00"
      },
      "url": "https://www.notion.so/Seven-3-0b7ef73ac23e40198139a87b987968f3",
      "public_url": "https://1874.notion.site/Seven-3-0b7ef73ac23e40198139a87b987968f3"
    },
    {
      "object": "page",
      "id": "6776bd5c-0ef2-4b60-b651-b08e0f4a4b24",
      "created_time": "2023-04-13T15:46:00.000Z",
      "last_edited_time": "2023-08-26T15:36:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/graduate_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-13T15:46:00.000Z",
        "date": "2023-04-14",
        "type": "Post",
        "slug": "day-4",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "Notion 函数写起来真要命",
        "更新时间": "2023-08-26T15:36:00.000Z",
        "title": "Seven的成长笔记【第4篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "6776bd5c-0ef2-4b60-b651-b08e0f4a4b24",
        "updated": "2023-08-26 15:36:00"
      },
      "url": "https://www.notion.so/Seven-4-6776bd5c0ef24b60b651b08e0f4a4b24",
      "public_url": "https://1874.notion.site/Seven-4-6776bd5c0ef24b60b651b08e0f4a4b24"
    },
    {
      "object": "page",
      "id": "7a8d6502-371a-49f8-baa2-c6e0127040f4",
      "created_time": "2023-04-16T16:39:00.000Z",
      "last_edited_time": "2023-08-26T15:36:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/graduate_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-16T16:39:00.000Z",
        "date": "2023-04-15",
        "type": "Post",
        "slug": "day-5",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:36:00.000Z",
        "title": "Seven的成长笔记【第5篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "7a8d6502-371a-49f8-baa2-c6e0127040f4",
        "updated": "2023-08-26 15:36:00"
      },
      "url": "https://www.notion.so/Seven-5-7a8d6502371a49f8baa2c6e0127040f4",
      "public_url": "https://1874.notion.site/Seven-5-7a8d6502371a49f8baa2c6e0127040f4"
    },
    {
      "object": "page",
      "id": "48389da8-9151-4994-9902-2166f2208925",
      "created_time": "2023-07-04T15:51:00.000Z",
      "last_edited_time": "2023-08-26T15:34:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/graduate_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-04T15:51:00.000Z",
        "date": "2023-07-04",
        "type": "Post",
        "slug": "day-7",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "FlowUs X",
        "更新时间": "2023-08-26T15:34:00.000Z",
        "title": "Seven的成长笔记【第7篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "48389da8-9151-4994-9902-2166f2208925",
        "updated": "2023-08-26 15:34:00"
      },
      "url": "https://www.notion.so/Seven-7-48389da89151499499022166f2208925",
      "public_url": "https://1874.notion.site/Seven-7-48389da89151499499022166f2208925"
    },
    {
      "object": "page",
      "id": "cf511d6f-d2c2-49c2-a3a2-84a1f55a546a",
      "created_time": "2023-07-05T15:26:00.000Z",
      "last_edited_time": "2023-08-26T15:28:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/graduate_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-05T15:26:00.000Z",
        "date": "2023-07-05",
        "type": "Post",
        "slug": "day-8",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:28:00.000Z",
        "title": "Seven的成长笔记【第8篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "cf511d6f-d2c2-49c2-a3a2-84a1f55a546a",
        "updated": "2023-08-26 15:28:00"
      },
      "url": "https://www.notion.so/Seven-8-cf511d6fd2c249c2a3a284a1f55a546a",
      "public_url": "https://1874.notion.site/Seven-8-cf511d6fd2c249c2a3a284a1f55a546a"
    },
    {
      "object": "page",
      "id": "dce9227d-2771-4829-8748-2f85fe4f57ca",
      "created_time": "2023-07-08T15:34:00.000Z",
      "last_edited_time": "2023-08-26T15:28:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/graduate_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-08T15:34:00.000Z",
        "date": "2023-07-09",
        "type": "Post",
        "slug": "day-9",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:28:00.000Z",
        "title": "Seven的成长笔记【第9篇】",
        "category": "随笔",
        "tags": [
          "随笔"
        ],
        "status": "Archived",
        "urlname": "dce9227d-2771-4829-8748-2f85fe4f57ca",
        "updated": "2023-08-26 15:28:00"
      },
      "url": "https://www.notion.so/Seven-9-dce9227d2771482987482f85fe4f57ca",
      "public_url": "https://1874.notion.site/Seven-9-dce9227d2771482987482f85fe4f57ca"
    },
    {
      "object": "page",
      "id": "0b80c709-5327-47c1-80e4-383090c64040",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:26:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🧧"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-03-29",
        "type": "Post",
        "slug": "react-state",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第六章 状态更新",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "0b80c709-5327-47c1-80e4-383090c64040",
        "updated": "2023-08-26 15:26:00"
      },
      "url": "https://www.notion.so/0b80c709532747c180e4383090c64040",
      "public_url": "https://1874.notion.site/0b80c709532747c180e4383090c64040"
    },
    {
      "object": "page",
      "id": "8c1f610f-80e0-45a6-821f-ba595c26e48a",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:26:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🎰"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-03-28",
        "type": "Post",
        "slug": "react-diff",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第五章 Diff算法",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "8c1f610f-80e0-45a6-821f-ba595c26e48a",
        "updated": "2023-08-26 15:26:00"
      },
      "url": "https://www.notion.so/Diff-8c1f610f80e045a6821fba595c26e48a",
      "public_url": "https://1874.notion.site/Diff-8c1f610f80e045a6821fba595c26e48a"
    },
    {
      "object": "page",
      "id": "dcac3fa7-a41d-42ed-837b-79311b3e6e3c",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:26:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🛁"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-02-19",
        "type": "Post",
        "slug": "react-commit",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第四章 React架构-commit阶段",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "dcac3fa7-a41d-42ed-837b-79311b3e6e3c",
        "updated": "2023-08-26 15:26:00"
      },
      "url": "https://www.notion.so/React-commit-dcac3fa7a41d42ed837b79311b3e6e3c",
      "public_url": "https://1874.notion.site/React-commit-dcac3fa7a41d42ed837b79311b3e6e3c"
    },
    {
      "object": "page",
      "id": "5a79a465-3cd6-4cd0-be23-29de458313ce",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:26:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🖨️"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-12-15",
        "type": "Post",
        "slug": "react",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第一章 React理念",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "5a79a465-3cd6-4cd0-be23-29de458313ce",
        "updated": "2023-08-26 15:26:00"
      },
      "url": "https://www.notion.so/React-5a79a4653cd64cd0be2329de458313ce",
      "public_url": "https://1874.notion.site/React-5a79a4653cd64cd0be2329de458313ce"
    },
    {
      "object": "page",
      "id": "43bfb7df-683e-4e53-a9a9-dfe9ab6e67ba",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:26:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🎥"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-12-16",
        "type": "Post",
        "slug": "react-jsx",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第二章 React架构-JSX",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "43bfb7df-683e-4e53-a9a9-dfe9ab6e67ba",
        "updated": "2023-08-26 15:26:00"
      },
      "url": "https://www.notion.so/React-JSX-43bfb7df683e4e53a9a9dfe9ab6e67ba",
      "public_url": "https://1874.notion.site/React-JSX-43bfb7df683e4e53a9a9dfe9ab6e67ba"
    },
    {
      "object": "page",
      "id": "423e426b-161e-4b67-9c5c-8f82af9f8feb",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:26:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🚧"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-02-09",
        "type": "Post",
        "slug": "react-render",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:26:00.000Z",
        "title": "第三章 React架构-render阶段",
        "category": "学习笔记",
        "tags": [
          "自顶向下学习React源码",
          "React"
        ],
        "status": "Draft",
        "urlname": "423e426b-161e-4b67-9c5c-8f82af9f8feb",
        "updated": "2023-08-26 15:26:00"
      },
      "url": "https://www.notion.so/React-render-423e426b161e4b679c5c8f82af9f8feb",
      "public_url": "https://1874.notion.site/React-render-423e426b161e4b679c5c8f82af9f8feb"
    },
    {
      "object": "page",
      "id": "6c0aa69b-7ec6-47ac-b2fd-4984e2f4e020",
      "created_time": "2023-04-14T18:04:00.000Z",
      "last_edited_time": "2023-08-26T15:24:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/images/page-cover/woodcuts_4.jpg"
        }
      },
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/notification_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-14T18:04:00.000Z",
        "date": "2023-04-15",
        "type": "Post",
        "slug": "notion-weekly-board",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何在Notion中打造TODO List，包括看板和数据库属性的设置，以及高级筛选和函数的使用。此外，还分享了Notion模板。",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "玩转Notion系列——TODO List",
        "category": "技术分享",
        "tags": [
          "Notion"
        ],
        "status": "Archived",
        "urlname": "6c0aa69b-7ec6-47ac-b2fd-4984e2f4e020",
        "updated": "2023-08-26 15:24:00"
      },
      "url": "https://www.notion.so/Notion-TODO-List-6c0aa69b7ec647acb2fd4984e2f4e020",
      "public_url": "https://1874.notion.site/Notion-TODO-List-6c0aa69b7ec647acb2fd4984e2f4e020"
    },
    {
      "object": "page",
      "id": "0feb7c90-7c54-4806-9ade-d9ae5bab5946",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:24:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🪗"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-02-09",
        "type": "Post",
        "slug": "oelsu8",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "注解式配置dubbo服务",
        "category": "学习笔记",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "0feb7c90-7c54-4806-9ade-d9ae5bab5946",
        "updated": "2023-08-26 15:24:00"
      },
      "url": "https://www.notion.so/dubbo-0feb7c907c5448069aded9ae5bab5946",
      "public_url": "https://1874.notion.site/dubbo-0feb7c907c5448069aded9ae5bab5946"
    },
    {
      "object": "page",
      "id": "31d9494b-7c68-4d94-a407-7625e31421fb",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:24:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🚧"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-02-17",
        "type": "Post",
        "slug": "fh1na3",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "Spring Security安全框架入门",
        "category": "学习笔记",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "31d9494b-7c68-4d94-a407-7625e31421fb",
        "updated": "2023-08-26 15:24:00"
      },
      "url": "https://www.notion.so/Spring-Security-31d9494b7c684d94a4077625e31421fb",
      "public_url": "https://1874.notion.site/Spring-Security-31d9494b7c684d94a4077625e31421fb"
    },
    {
      "object": "page",
      "id": "51cd7a47-863b-49a3-8064-8797159d298e",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:24:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "💊"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2020-03-01",
        "type": "Post",
        "slug": "vkdsce",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "Git常用命令",
        "category": "学习笔记",
        "tags": [
          "Git"
        ],
        "status": "Archived",
        "urlname": "51cd7a47-863b-49a3-8064-8797159d298e",
        "updated": "2023-08-26 15:24:00"
      },
      "url": "https://www.notion.so/Git-51cd7a47863b49a380648797159d298e",
      "public_url": "https://1874.notion.site/Git-51cd7a47863b49a380648797159d298e"
    },
    {
      "object": "page",
      "id": "d9d157b7-9c7f-4375-8d60-d4b58d51882a",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:24:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🎹"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2020-04-15",
        "type": "Post",
        "slug": "ymxk6u",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "阿里canal数据库命令总结",
        "category": "学习笔记",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "d9d157b7-9c7f-4375-8d60-d4b58d51882a",
        "updated": "2023-08-26 15:24:00"
      },
      "url": "https://www.notion.so/canal-d9d157b79c7f43758d60d4b58d51882a",
      "public_url": "https://1874.notion.site/canal-d9d157b79c7f43758d60d4b58d51882a"
    },
    {
      "object": "page",
      "id": "02209783-f54d-4d2e-9a4e-508c42e43ad9",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:24:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🎊"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-07-16",
        "type": "Post",
        "slug": "zbbxv0",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文记录了在语雀云端写作 Hexo+Github Actions+COS 持续集成中，搭建 Node 项目作为中转站的过程。通过初始化 Midway，编写 GithubController 和 GithubService，实现了通过 Github Actions 的接口触发构建流程。详细内容请见文章。",
        "更新时间": "2023-08-26T15:24:00.000Z",
        "title": "Midway项目搭建记录",
        "category": "学习笔记",
        "tags": [
          "Node",
          "Midway"
        ],
        "status": "Archived",
        "urlname": "02209783-f54d-4d2e-9a4e-508c42e43ad9",
        "updated": "2023-08-26 15:24:00"
      },
      "url": "https://www.notion.so/Midway-02209783f54d4d2e9a4e508c42e43ad9",
      "public_url": "https://1874.notion.site/Midway-02209783f54d4d2e9a4e508c42e43ad9"
    },
    {
      "object": "page",
      "id": "c28edc25-f869-45dd-875e-0e7396067ac4",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:22:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🚖"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-02-12",
        "type": "Post",
        "slug": "nvikqw",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "这是一个支持多个图床的插件，用于在博客中上传图片。目前已适配的图床包括腾讯云、阿里云和七牛云。该插件提供了一个接口适配层，使得上层在使用时可以传入不同的配置参数选择不同的图床。更多详情请查看yuqe-hexo-with-cdn。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "yuqe-hexo-with-cdn插件支持多图床",
        "category": "技术分享",
        "tags": [
          "Hexo"
        ],
        "status": "Archived",
        "urlname": "c28edc25-f869-45dd-875e-0e7396067ac4",
        "updated": "2023-08-26 15:22:00"
      },
      "url": "https://www.notion.so/yuqe-hexo-with-cdn-c28edc25f86945dd875e0e7396067ac4",
      "public_url": "https://1874.notion.site/yuqe-hexo-with-cdn-c28edc25f86945dd875e0e7396067ac4"
    },
    {
      "object": "page",
      "id": "49a7c01d-86a0-4cf9-bb14-7a55a4651215",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:22:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🏢"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-01-19",
        "type": "Post",
        "slug": "roeayv",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "该文档介绍了如何使用语雀云端写作Hexo+Github Actions+COS进行持续集成，以及如何配置腾讯云函数和语雀webhook，最后介绍了一些常见问题及解决方案。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "语雀云端写作Hexo+Github Actions+COS持续集成",
        "category": "技术分享",
        "tags": [
          "CI/CD",
          "Hexo"
        ],
        "status": "Archived",
        "urlname": "49a7c01d-86a0-4cf9-bb14-7a55a4651215",
        "updated": "2023-08-26 15:22:00"
      },
      "url": "https://www.notion.so/Hexo-Github-Actions-COS-49a7c01d86a04cf9bb147a55a4651215",
      "public_url": "https://1874.notion.site/Hexo-Github-Actions-COS-49a7c01d86a04cf9bb147a55a4651215"
    },
    {
      "object": "page",
      "id": "451fde56-fb4a-475d-a152-82ebe33d6a74",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:22:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🎏"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2020-04-20",
        "type": "Post",
        "slug": "ulvcm5",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何使用webpack的url-loader和image-webpack-loader插件来优化图片。其中，url-loader可以将小于1kb的图片转换成base64编码进行存储，而image-webpack-loader可以对大一点的图片进行压缩。还介绍了各个优化器的作用，如mozjpeg、optipng、pngquant等，并提供了相应的配置参数说明。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "Webpack配置-图片优化",
        "category": "技术分享",
        "tags": [
          "Webpack"
        ],
        "status": "Archived",
        "urlname": "451fde56-fb4a-475d-a152-82ebe33d6a74",
        "updated": "2023-08-26 15:22:00"
      },
      "url": "https://www.notion.so/Webpack-451fde56fb4a475da15282ebe33d6a74",
      "public_url": "https://1874.notion.site/Webpack-451fde56fb4a475da15282ebe33d6a74"
    },
    {
      "object": "page",
      "id": "8e09392b-f4ba-4969-8f3f-d47d779f6ff3",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:22:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🎳"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-01-09",
        "type": "Post",
        "slug": "fqx1vy",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "webpack-dev-server启动找不到config-yargs",
        "category": "技术分享",
        "tags": [
          "Webpack"
        ],
        "status": "Archived",
        "urlname": "8e09392b-f4ba-4969-8f3f-d47d779f6ff3",
        "updated": "2023-08-26 15:22:00"
      },
      "url": "https://www.notion.so/webpack-dev-server-config-yargs-8e09392bf4ba49698f3fd47d779f6ff3",
      "public_url": "https://1874.notion.site/webpack-dev-server-config-yargs-8e09392bf4ba49698f3fd47d779f6ff3"
    },
    {
      "object": "page",
      "id": "506adb06-6632-4133-be32-171a4ec0af21",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:22:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🛵"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-01-15",
        "type": "Post",
        "slug": "ar658s",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了前端开发规范中使用的Eslint。作者介绍了自己和团队在使用Eslint过程中遇到的问题，最终选择了Eslint + Prettier的组合，并使用了腾讯AlloyTeam创立的一套Eslint规则。本文详细介绍了Eslint规则的设计理念和样式相关的规则交给Prettier来管理的思想，以及如何开始配置Eslint。同时，作者还介绍了如何适配WebStorm来使用Eslint进行代码检查。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "前端开发规范之Eslint",
        "category": "技术分享",
        "tags": [
          "Eslint",
          "代码规范"
        ],
        "status": "Archived",
        "urlname": "506adb06-6632-4133-be32-171a4ec0af21",
        "updated": "2023-08-26 15:22:00"
      },
      "url": "https://www.notion.so/Eslint-506adb0666324133be32171a4ec0af21",
      "public_url": "https://1874.notion.site/Eslint-506adb0666324133be32171a4ec0af21"
    },
    {
      "object": "page",
      "id": "e7200c3e-ae64-4093-8ecc-4d249b091349",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:22:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🛡️"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-02-01",
        "type": "Post",
        "slug": "hemk59",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何在Vue中维护路由跳转记录，以解决使用this.$router.go(-1)返回上一个路由时，无法拿到上个路由的路由地址的问题，并避免进入死循环。作者提出了通过路由守卫，利用堆栈的方式维护页面跳转的历史记录的思路，并给出了具体实现方法。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "在Vue中维护路由跳转记录",
        "category": "技术分享",
        "tags": [
          "Vue"
        ],
        "status": "Archived",
        "urlname": "e7200c3e-ae64-4093-8ecc-4d249b091349",
        "updated": "2023-08-26 15:22:00"
      },
      "url": "https://www.notion.so/Vue-e7200c3eae6440938ecc4d249b091349",
      "public_url": "https://1874.notion.site/Vue-e7200c3eae6440938ecc4d249b091349"
    },
    {
      "object": "page",
      "id": "701f9876-9f7a-4f28-b225-7077e45cfeab",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:22:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🌡️"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-05-08",
        "type": "Post",
        "slug": "zqsrm2",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文主要介绍了 npm 依赖管理的机制，包括 npm 安装机制、npm 2 和 npm 3 模块安装机制的差异、npm 3 对于同一依赖的不同版本的处理、package-lock.json 文件的结构和作用等内容。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "探究npm 依赖管理",
        "category": "技术分享",
        "tags": [
          "Npm"
        ],
        "status": "Archived",
        "urlname": "701f9876-9f7a-4f28-b225-7077e45cfeab",
        "updated": "2023-08-26 15:22:00"
      },
      "url": "https://www.notion.so/npm-701f98769f7a4f28b2257077e45cfeab",
      "public_url": "https://1874.notion.site/npm-701f98769f7a4f28b2257077e45cfeab"
    },
    {
      "object": "page",
      "id": "530f1e97-1df5-45a3-a1e4-4b0fa0ef957d",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:22:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🩺"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-05-16",
        "type": "Post",
        "slug": "xelwzw",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "代码的马斯洛金字塔",
        "category": "技术分享",
        "tags": [
          "代码规范"
        ],
        "status": "Archived",
        "urlname": "530f1e97-1df5-45a3-a1e4-4b0fa0ef957d",
        "updated": "2023-08-26 15:22:00"
      },
      "url": "https://www.notion.so/530f1e971df545a3a1e44b0fa0ef957d",
      "public_url": "https://1874.notion.site/530f1e971df545a3a1e44b0fa0ef957d"
    },
    {
      "object": "page",
      "id": "aea49f8c-44b2-44d5-a269-c0d1ff23625d",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:22:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🏏"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-10-12",
        "type": "Post",
        "slug": "peqmq8",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了一个 React 中后台系统多页签方案，包括标签页功能、页面数据缓存、权限相关等功能点。同时，还涉及到路由结构和 Layout 布局组件等方面的问题。本文旨在帮助读者理解多页签实现的原理及其应用场景。",
        "更新时间": "2023-08-26T15:22:00.000Z",
        "title": "React 中后台系统多页签方案",
        "category": "技术分享",
        "tags": [
          "React"
        ],
        "status": "Archived",
        "urlname": "aea49f8c-44b2-44d5-a269-c0d1ff23625d",
        "updated": "2023-08-26 15:22:00"
      },
      "url": "https://www.notion.so/React-aea49f8c44b244d5a269c0d1ff23625d",
      "public_url": "https://1874.notion.site/React-aea49f8c44b244d5a269c0d1ff23625d"
    },
    {
      "object": "page",
      "id": "cbd49264-58c3-4052-b267-0ec9109cb24d",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:21:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "⛳"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2020-10-16",
        "type": "Post",
        "slug": "hryfur",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文主要介绍了如何使用 Nginx 配置重定向和 HTTPS，包括如何将 HTTP 请求重定向到 HTTPS，以及如何申请和配置 SSL 证书。此外，本文还提供了一个简单的脚本，用于自动化启动 Nginx。",
        "更新时间": "2023-08-26T15:21:00.000Z",
        "title": "Nginx配置重定向和Https的实践",
        "category": "技术分享",
        "tags": [
          "Nginx",
          "SSL"
        ],
        "status": "Archived",
        "urlname": "cbd49264-58c3-4052-b267-0ec9109cb24d",
        "updated": "2023-08-26 15:21:00"
      },
      "url": "https://www.notion.so/Nginx-Https-cbd4926458c34052b2670ec9109cb24d",
      "public_url": "https://1874.notion.site/Nginx-Https-cbd4926458c34052b2670ec9109cb24d"
    },
    {
      "object": "page",
      "id": "b043b306-f082-4e6d-bd82-f4be2262de22",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T15:20:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "💧"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-05-14",
        "type": "Post",
        "slug": "qfvyux",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T15:20:00.000Z",
        "title": "HBase集群搭建过程中容易出现的Bug汇总及解决方案",
        "category": "技术分享",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "b043b306-f082-4e6d-bd82-f4be2262de22",
        "updated": "2023-08-26 15:20:00"
      },
      "url": "https://www.notion.so/HBase-Bug-b043b306f0824e6dbd82f4be2262de22",
      "public_url": "https://1874.notion.site/HBase-Bug-b043b306f0824e6dbd82f4be2262de22"
    },
    {
      "object": "page",
      "id": "5608118c-f262-4b39-999d-d67a5424cd82",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T14:48:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🥁"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-02-21",
        "type": "Post",
        "slug": "di6uo5",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:48:00.000Z",
        "title": "在腾讯云服务器上安装FastDFS",
        "category": "学习笔记",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "5608118c-f262-4b39-999d-d67a5424cd82",
        "updated": "2023-08-26 14:48:00"
      },
      "url": "https://www.notion.so/FastDFS-5608118cf2624b39999dd67a5424cd82",
      "public_url": "https://1874.notion.site/FastDFS-5608118cf2624b39999dd67a5424cd82"
    },
    {
      "object": "page",
      "id": "b3c87db0-ebc5-4eb3-9529-2ea17e5d4bc8",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T14:48:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🏅"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-01-15",
        "type": "Post",
        "slug": "sbgn9r",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:48:00.000Z",
        "title": "Tinymce-Vue初体验",
        "category": "学习笔记",
        "tags": [
          "富文本",
          "Vue"
        ],
        "status": "Archived",
        "urlname": "b3c87db0-ebc5-4eb3-9529-2ea17e5d4bc8",
        "updated": "2023-08-26 14:48:00"
      },
      "url": "https://www.notion.so/Tinymce-Vue-b3c87db0ebc54eb395292ea17e5d4bc8",
      "public_url": "https://1874.notion.site/Tinymce-Vue-b3c87db0ebc54eb395292ea17e5d4bc8"
    },
    {
      "object": "page",
      "id": "53037fea-b13b-4fc6-8c6b-a254bb871dcd",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T14:43:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🏢"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-05-04",
        "type": "Post",
        "slug": "olp6f6",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:43:00.000Z",
        "title": "Centos命令提示符显示完整路径",
        "category": "学习笔记",
        "tags": [
          "Linux"
        ],
        "status": "Archived",
        "urlname": "53037fea-b13b-4fc6-8c6b-a254bb871dcd",
        "updated": "2023-08-26 14:43:00"
      },
      "url": "https://www.notion.so/Centos-53037feab13b4fc68c6ba254bb871dcd",
      "public_url": "https://1874.notion.site/Centos-53037feab13b4fc68c6ba254bb871dcd"
    },
    {
      "object": "page",
      "id": "969bc5c0-227e-40fc-bed8-74216c1c53a9",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T14:43:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🥏"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2020-04-17",
        "type": "Post",
        "slug": "oslix7",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:43:00.000Z",
        "title": "谈一谈二进制",
        "category": "技术分享",
        "tags": [
          "数据结构"
        ],
        "status": "Archived",
        "urlname": "969bc5c0-227e-40fc-bed8-74216c1c53a9",
        "updated": "2023-08-26 14:43:00"
      },
      "url": "https://www.notion.so/969bc5c0227e40fcbed874216c1c53a9",
      "public_url": "https://1874.notion.site/969bc5c0227e40fcbed874216c1c53a9"
    },
    {
      "object": "page",
      "id": "af91247d-4fac-406b-8272-9a807defeefd",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T14:43:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🥉"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-04-02",
        "type": "Post",
        "slug": "qykfat",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "这篇文章介绍了如何使用 SpringBoot、ActiveMQ 和腾讯云 SMS 搭建 Java 短信微服务，并提供了详细的步骤和代码示例。",
        "更新时间": "2023-08-26T14:43:00.000Z",
        "title": "Java短信微服务开发 SpringBoot+ActiveMQ+腾讯云SMS",
        "category": "技术分享",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "af91247d-4fac-406b-8272-9a807defeefd",
        "updated": "2023-08-26 14:43:00"
      },
      "url": "https://www.notion.so/Java-SpringBoot-ActiveMQ-SMS-af91247d4fac406b82729a807defeefd",
      "public_url": "https://1874.notion.site/Java-SpringBoot-ActiveMQ-SMS-af91247d4fac406b82729a807defeefd"
    },
    {
      "object": "page",
      "id": "e9a8c0ae-05f5-4bb4-b40b-2df593e8814d",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T14:42:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🚝"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-08-14",
        "type": "Post",
        "slug": "epmi4g",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "关于接口的请求的一些思考",
        "category": "技术分享",
        "tags": [
          "并发"
        ],
        "status": "Archived",
        "urlname": "e9a8c0ae-05f5-4bb4-b40b-2df593e8814d",
        "updated": "2023-08-26 14:42:00"
      },
      "url": "https://www.notion.so/e9a8c0ae05f54bb4b40b2df593e8814d",
      "public_url": "https://1874.notion.site/e9a8c0ae05f54bb4b40b2df593e8814d"
    },
    {
      "object": "page",
      "id": "9a588e82-f423-4887-a07b-159f06e02b09",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T14:42:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🕓"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-04-22",
        "type": "Post",
        "slug": "is8lw3",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何在MacOS上卸载nvm/node并重新安装。包括卸载nvm、node、yarn、npm的步骤，以及安装node和nvm的过程。同时，还提供了解决node地址问题的两种方法。",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "MacOS开发环境治理-卸载nvm/node并重新安装",
        "category": "技术分享",
        "tags": [
          "Node"
        ],
        "status": "Archived",
        "urlname": "9a588e82-f423-4887-a07b-159f06e02b09",
        "updated": "2023-08-26 14:42:00"
      },
      "url": "https://www.notion.so/MacOS-nvm-node-9a588e82f4234887a07b159f06e02b09",
      "public_url": "https://1874.notion.site/MacOS-nvm-node-9a588e82f4234887a07b159f06e02b09"
    },
    {
      "object": "page",
      "id": "88e73589-a9b1-4652-b05e-116b288aa5b8",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T14:42:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🏗️"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2019-02-08",
        "type": "Post",
        "slug": "ywdq07",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "Mybatis分页插件警告解决办法",
        "category": "技术分享",
        "tags": [
          "Java"
        ],
        "status": "Archived",
        "urlname": "88e73589-a9b1-4652-b05e-116b288aa5b8",
        "updated": "2023-08-26 14:42:00"
      },
      "url": "https://www.notion.so/Mybatis-88e73589a9b14652b05e116b288aa5b8",
      "public_url": "https://1874.notion.site/Mybatis-88e73589a9b14652b05e116b288aa5b8"
    },
    {
      "object": "page",
      "id": "ed1e7737-88f0-4197-8f29-47ceb92792f0",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T14:42:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "📔"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-02-06",
        "type": "Post",
        "slug": "kolyq9",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了在Webpack中使用多进程/多实例解析资源的方法，以及优化Webpack性能的两种方法：在Webpack4中使用hard-source-webpack-plugin插件，在Webpack5中使用cache选项。本文还提到了使用hard-source-webpack-plugin插件的注意事项。",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "Webpack配置-多进程/多实例解析资源",
        "category": "技术分享",
        "tags": [
          "Webpack"
        ],
        "status": "Archived",
        "urlname": "ed1e7737-88f0-4197-8f29-47ceb92792f0",
        "updated": "2023-08-26 14:42:00"
      },
      "url": "https://www.notion.so/Webpack-ed1e773788f041978f2947ceb92792f0",
      "public_url": "https://1874.notion.site/Webpack-ed1e773788f041978f2947ceb92792f0"
    },
    {
      "object": "page",
      "id": "4df7c95e-9f18-437e-a4fa-34f2dfd07c74",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T14:42:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "👟"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-09-03",
        "type": "Post",
        "slug": "fgligg",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "跨域场景汇总",
        "category": "技术分享",
        "tags": [
          "Bugs"
        ],
        "status": "Archived",
        "urlname": "4df7c95e-9f18-437e-a4fa-34f2dfd07c74",
        "updated": "2023-08-26 14:42:00"
      },
      "url": "https://www.notion.so/4df7c95e9f18437ea4fa34f2dfd07c74",
      "public_url": "https://1874.notion.site/4df7c95e9f18437ea4fa34f2dfd07c74"
    },
    {
      "object": "page",
      "id": "74a06a6c-40b4-4408-8636-14cf996b3a71",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-08-26T14:42:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "📿"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2021-02-24",
        "type": "Post",
        "slug": "owidng",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了一种利用 pdf.js 和 pdfbox 技术实现大文件 PDF 预览的解决方案。通过采用前端 pdf.js 插件解析 PDF 文件并转化为图片，后端 pdfbox 进行 PDF 处理和切图，实现了大文件的分片上传和处理。同时，本文介绍了在实践过程中遇到的内存溢出问题和解决方案。",
        "更新时间": "2023-08-26T14:42:00.000Z",
        "title": "大文件pdf预览解决方案",
        "category": "技术分享",
        "tags": [
          "Vue",
          "Java"
        ],
        "status": "Archived",
        "urlname": "74a06a6c-40b4-4408-8636-14cf996b3a71",
        "updated": "2023-08-26 14:42:00"
      },
      "url": "https://www.notion.so/pdf-74a06a6c40b44408863614cf996b3a71",
      "public_url": "https://1874.notion.site/pdf-74a06a6c40b44408863614cf996b3a71"
    },
    {
      "object": "page",
      "id": "a0d6553b-62bf-4019-8aa9-4219242f7b9a",
      "created_time": "2023-07-14T10:17:00.000Z",
      "last_edited_time": "2023-07-25T15:31:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/images/page-cover/gradients_8.png"
        }
      },
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/mathematics_blue.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-14T10:17:00.000Z",
        "date": "2023-07-14",
        "type": "Post",
        "slug": "leetcode-day-3",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-07-25T15:31:00.000Z",
        "title": "【代码随想录】算法训练营第3天",
        "category": "算法刷题",
        "tags": [
          "算法训练营"
        ],
        "status": "Invisible",
        "urlname": "a0d6553b-62bf-4019-8aa9-4219242f7b9a",
        "updated": "2023-07-25 15:31:00"
      },
      "url": "https://www.notion.so/3-a0d6553b62bf40198aa94219242f7b9a",
      "public_url": "https://1874.notion.site/3-a0d6553b62bf40198aa94219242f7b9a"
    },
    {
      "object": "page",
      "id": "dff5c177-a377-4ba9-9924-54113ce1ec5e",
      "created_time": "2023-07-10T15:33:00.000Z",
      "last_edited_time": "2023-07-10T15:33:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/binoculars_brown.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-10T15:33:00.000Z",
        "date": "2023-07-10 15:33:00",
        "type": "Post",
        "slug": "beyond-code-2023-w28",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-07-10T15:33:00.000Z",
        "title": "代码之外 2023-W28",
        "category": "代码之外",
        "tags": [],
        "status": "Draft",
        "urlname": "dff5c177-a377-4ba9-9924-54113ce1ec5e",
        "updated": "2023-07-10 15:33:00"
      },
      "url": "https://www.notion.so/2023-W28-dff5c177a3774ba9992454113ce1ec5e",
      "public_url": "https://1874.notion.site/2023-W28-dff5c177a3774ba9992454113ce1ec5e"
    },
    {
      "object": "page",
      "id": "346c9ff0-8751-4367-9d60-a88c2fff08b4",
      "created_time": "2023-07-10T14:49:00.000Z",
      "last_edited_time": "2023-07-10T15:10:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🚨"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-07-10T14:49:00.000Z",
        "date": "2023-07-10",
        "type": "Post",
        "slug": "weekly-2023-w28",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "",
        "更新时间": "2023-07-10T15:10:00.000Z",
        "title": "技术周刊 2023-W28",
        "category": "技术周刊",
        "tags": [],
        "status": "Draft",
        "urlname": "346c9ff0-8751-4367-9d60-a88c2fff08b4",
        "updated": "2023-07-10 15:10:00"
      },
      "url": "https://www.notion.so/2023-W28-346c9ff0875143679d60a88c2fff08b4",
      "public_url": "https://1874.notion.site/2023-W28-346c9ff0875143679d60a88c2fff08b4"
    },
    {
      "object": "page",
      "id": "4296105d-56f7-4dc7-be6a-ac69ba786d50",
      "created_time": "2023-04-09T18:39:00.000Z",
      "last_edited_time": "2023-07-10T13:15:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "external",
        "external": {
          "url": "https://www.notion.so/icons/gym_purple.svg"
        }
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-09T18:39:00.000Z",
        "date": "2023-04-10",
        "type": "Post",
        "slug": "migrate-blog-to-notion",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "博客迁移记录",
        "更新时间": "2023-07-10T13:15:00.000Z",
        "title": "迁移博客到 Notion",
        "category": "技术分享",
        "tags": [
          "Notion"
        ],
        "status": "Published",
        "urlname": "4296105d-56f7-4dc7-be6a-ac69ba786d50",
        "updated": "2023-07-10 13:15:00"
      },
      "url": "https://www.notion.so/Notion-4296105d56f74dc7be6aac69ba786d50",
      "public_url": "https://1874.notion.site/Notion-4296105d56f74dc7be6aac69ba786d50"
    },
    {
      "object": "page",
      "id": "335ae226-1802-4706-98b5-2a09bde056a1",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-05-31T16:23:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🏢"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-06-23",
        "type": "Post",
        "slug": "qzmpp5",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何使用Github Actions自动化发布npm包，以及如何打造一个同时导出cjs和esm的npm包。文章详细介绍了配置文件的目录结构和关键参数，以及自动化发布的具体步骤。",
        "更新时间": "2023-05-31T16:23:00.000Z",
        "title": "利用github actions自动化发布npm",
        "category": "技术分享",
        "tags": [
          "Github Actions",
          "Node"
        ],
        "status": "Published",
        "urlname": "335ae226-1802-4706-98b5-2a09bde056a1",
        "updated": "2023-05-31 16:23:00"
      },
      "url": "https://www.notion.so/github-actions-npm-335ae2261802470698b52a09bde056a1",
      "public_url": "https://1874.notion.site/github-actions-npm-335ae2261802470698b52a09bde056a1"
    },
    {
      "object": "page",
      "id": "d7b1453e-530d-4614-8d41-c5ac6972e351",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-05-31T16:23:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🏬"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-07-16",
        "type": "Post",
        "slug": "ovugli",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "本文介绍了如何使用 Github Actions 持续集成 Docker 构建并部署 Node 项目到云服务器。具体流程包括搭建 Node 服务、开通腾讯云容器镜像服务、配置 Github Actions、编写 workflows 流程、连接云服务器、配置 DockerFile 等。最终实现推送代码到 master 分支自动部署项目。",
        "更新时间": "2023-05-31T16:23:00.000Z",
        "title": "Github Actions持续集成 Docker构建并部署Node项目到云服务器",
        "category": "技术分享",
        "tags": [
          "Docker",
          "CI/CD",
          "Node",
          "Github Actions"
        ],
        "status": "Published",
        "urlname": "d7b1453e-530d-4614-8d41-c5ac6972e351",
        "updated": "2023-05-31 16:23:00"
      },
      "url": "https://www.notion.so/Github-Actions-Docker-Node-d7b1453e530d46148d41c5ac6972e351",
      "public_url": "https://1874.notion.site/Github-Actions-Docker-Node-d7b1453e530d46148d41c5ac6972e351"
    },
    {
      "object": "page",
      "id": "f674c03b-a560-4d80-984a-ede9d0ec6d9f",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-05-31T16:23:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "🎇"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-04-28",
        "type": "Post",
        "slug": "wqx8a7",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "该文档介绍了如何使用node-agile-client为开源社区做贡献，开发AgileConfig的NodeJS客户端。该客户端包括了异步获取agile配置、从缓存中获取agile配置、从服务端获取配置并写入缓存、同步获取Agile配置等功能。通过该客户端，可以轻松获取到Agile配置。",
        "更新时间": "2023-05-31T16:23:00.000Z",
        "title": "为开源社区做贡献-开发AgileConfig的NodeJS客户端：node-agile-client",
        "category": "技术分享",
        "tags": [
          "Node"
        ],
        "status": "Published",
        "urlname": "f674c03b-a560-4d80-984a-ede9d0ec6d9f",
        "updated": "2023-05-31 16:23:00"
      },
      "url": "https://www.notion.so/AgileConfig-NodeJS-node-agile-client-f674c03ba5604d80984aede9d0ec6d9f",
      "public_url": "https://1874.notion.site/AgileConfig-NodeJS-node-agile-client-f674c03ba5604d80984aede9d0ec6d9f"
    },
    {
      "object": "page",
      "id": "08ccfc16-c8cb-42a2-ad65-b37c4d49ce78",
      "created_time": "2023-04-07T19:15:00.000Z",
      "last_edited_time": "2023-04-10T05:04:00.000Z",
      "created_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "last_edited_by": {
        "object": "user",
        "id": "b82f6c4e-be35-49b9-b539-7f72b6e7e246"
      },
      "cover": null,
      "icon": {
        "type": "emoji",
        "emoji": "📅"
      },
      "parent": {
        "type": "database_id",
        "database_id": "eefc9490-e29c-4969-a7a1-fdd99bf743e0"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "创建时间": "2023-04-07T19:15:00.000Z",
        "date": "2022-04-19",
        "type": "Post",
        "slug": "rm057k",
        "配置类型": {
          "type": "string",
          "string": "文档"
        },
        "summary": "Alfred YYDS",
        "更新时间": "2023-04-10T05:04:00.000Z",
        "title": "程序员必备——Mac效率工具Alfred Workflows配置",
        "category": "技术分享",
        "tags": [
          "效率工具"
        ],
        "status": "Published",
        "urlname": "08ccfc16-c8cb-42a2-ad65-b37c4d49ce78",
        "updated": "2023-04-10 05:04:00"
      },
      "url": "https://www.notion.so/Mac-Alfred-Workflows-08ccfc16c8cb42a2ad65b37c4d49ce78",
      "public_url": "https://1874.notion.site/Mac-Alfred-Workflows-08ccfc16c8cb42a2ad65b37c4d49ce78"
    }
  ]
}